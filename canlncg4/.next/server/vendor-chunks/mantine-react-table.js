"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mantine-react-table";
exports.ids = ["vendor-chunks/mantine-react-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/mantine-react-table/dist/cjs/index.js":
/*!************************************************************!*\
  !*** ./node_modules/mantine-react-table/dist/cjs/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/shared/react-jsx-runtime.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar reactTable = __webpack_require__(/*! @tanstack/react-table */ \"(ssr)/./node_modules/@tanstack/react-table/build/lib/index.js\");\nvar matchSorterUtils = __webpack_require__(/*! @tanstack/match-sorter-utils */ \"(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.js\");\nvar iconsReact = __webpack_require__(/*! @tabler/icons-react */ \"(ssr)/./node_modules/@tabler/icons-react/dist/esm/tabler-icons-react.js\");\nvar reactVirtual = __webpack_require__(/*! @tanstack/react-virtual */ \"(ssr)/./node_modules/@tanstack/react-virtual/build/lib/index.js\");\nvar core = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/cjs/index.js\");\nvar hooks = __webpack_require__(/*! @mantine/hooks */ \"(ssr)/./node_modules/@mantine/hooks/cjs/index.js\");\nvar dates = __webpack_require__(/*! @mantine/dates */ \"(ssr)/./node_modules/@mantine/dates/cjs/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nconst MRT_AggregationFns = Object.assign({}, reactTable.aggregationFns);\n\nconst fuzzy$1 = (row, columnId, filterValue, addMeta) => {\n    const itemRank = matchSorterUtils.rankItem(row.getValue(columnId), filterValue, {\n        threshold: matchSorterUtils.rankings.MATCHES,\n    });\n    addMeta(itemRank);\n    return itemRank.passed;\n};\nfuzzy$1.autoRemove = (val) => !val;\nconst contains = (row, id, filterValue) => row\n    .getValue(id)\n    .toString()\n    .toLowerCase()\n    .trim()\n    .includes(filterValue.toString().toLowerCase().trim());\ncontains.autoRemove = (val) => !val;\nconst startsWith = (row, id, filterValue) => row\n    .getValue(id)\n    .toString()\n    .toLowerCase()\n    .trim()\n    .startsWith(filterValue.toString().toLowerCase().trim());\nstartsWith.autoRemove = (val) => !val;\nconst endsWith = (row, id, filterValue) => row\n    .getValue(id)\n    .toString()\n    .toLowerCase()\n    .trim()\n    .endsWith(filterValue.toString().toLowerCase().trim());\nendsWith.autoRemove = (val) => !val;\nconst equals = (row, id, filterValue) => filterValue === null\n    ? true\n    : row.getValue(id).toString().toLowerCase().trim() ===\n        filterValue.toString().toLowerCase().trim();\nequals.autoRemove = (val) => !val;\nconst notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !==\n    filterValue.toString().toLowerCase().trim();\nnotEquals.autoRemove = (val) => !val;\nconst greaterThan = (row, id, filterValue) => filterValue === null\n    ? true\n    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))\n        ? +row.getValue(id) > +filterValue\n        : row.getValue(id).toString().toLowerCase().trim() >\n            filterValue.toString().toLowerCase().trim();\ngreaterThan.autoRemove = (val) => !val;\nconst greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);\ngreaterThanOrEqualTo.autoRemove = (val) => !val;\nconst lessThan = (row, id, filterValue) => filterValue === null\n    ? true\n    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))\n        ? +row.getValue(id) < +filterValue\n        : row.getValue(id).toString().toLowerCase().trim() <\n            filterValue.toString().toLowerCase().trim();\nlessThan.autoRemove = (val) => !val;\nconst lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);\nlessThanOrEqualTo.autoRemove = (val) => !val;\nconst between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||\n    greaterThan(row, id, filterValues[0])) &&\n    ((!isNaN(+filterValues[0]) &&\n        !isNaN(+filterValues[1]) &&\n        +filterValues[0] > +filterValues[1]) ||\n        ['', undefined].includes(filterValues[1]) ||\n        lessThan(row, id, filterValues[1]));\nbetween.autoRemove = (val) => !val;\nconst betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||\n    greaterThanOrEqualTo(row, id, filterValues[0])) &&\n    ((!isNaN(+filterValues[0]) &&\n        !isNaN(+filterValues[1]) &&\n        +filterValues[0] > +filterValues[1]) ||\n        ['', undefined].includes(filterValues[1]) ||\n        lessThanOrEqualTo(row, id, filterValues[1]));\nbetweenInclusive.autoRemove = (val) => !val;\nconst empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();\nempty.autoRemove = (val) => !val;\nconst notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();\nnotEmpty.autoRemove = (val) => !val;\nconst MRT_FilterFns = Object.assign(Object.assign({}, reactTable.filterFns), { between,\n    betweenInclusive,\n    contains,\n    empty,\n    endsWith,\n    equals,\n    fuzzy: fuzzy$1,\n    greaterThan,\n    greaterThanOrEqualTo,\n    lessThan,\n    lessThanOrEqualTo,\n    notEmpty,\n    notEquals,\n    startsWith });\n\nconst fuzzy = (rowA, rowB, columnId) => {\n    let dir = 0;\n    if (rowA.columnFiltersMeta[columnId]) {\n        dir = matchSorterUtils.compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);\n    }\n    // Provide a fallback for when the item ranks are equal\n    return dir === 0\n        ? reactTable.sortingFns.alphanumeric(rowA, rowB, columnId)\n        : dir;\n};\nconst MRT_SortingFns = Object.assign(Object.assign({}, reactTable.sortingFns), { fuzzy });\nconst rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) -\n    Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));\n\nconst getColumnId = (columnDef) => { var _a, _b, _c, _d; return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header; };\nconst getAllLeafColumnDefs = (columns) => {\n    const allLeafColumnDefs = [];\n    const getLeafColumns = (cols) => {\n        cols.forEach((col) => {\n            if (col.columns) {\n                getLeafColumns(col.columns);\n            }\n            else {\n                allLeafColumnDefs.push(col);\n            }\n        });\n    };\n    getLeafColumns(columns);\n    return allLeafColumnDefs;\n};\nconst prepareColumns = ({ aggregationFns, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns, sortingFns, }) => columnDefs.map((columnDef) => {\n    var _a, _b;\n    //assign columnId\n    if (!columnDef.id)\n        columnDef.id = getColumnId(columnDef);\n    if ( true && !columnDef.id) {\n        console.error('Column definitions must have a valid `accessorKey` or `id` property');\n    }\n    //assign columnDefType\n    if (!columnDef.columnDefType)\n        columnDef.columnDefType = 'data';\n    if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {\n        columnDef.columnDefType = 'group';\n        //recursively prepare columns if this is a group column\n        columnDef.columns = prepareColumns({\n            aggregationFns,\n            columnDefs: columnDef.columns,\n            columnFilterFns,\n            defaultDisplayColumn,\n            filterFns,\n            sortingFns,\n        });\n    }\n    else if (columnDef.columnDefType === 'data') {\n        //assign aggregationFns if multiple aggregationFns are provided\n        if (Array.isArray(columnDef.aggregationFn)) {\n            const aggFns = columnDef.aggregationFn;\n            columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => { var _a; return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows); });\n        }\n        //assign filterFns\n        if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {\n            columnDef.filterFn =\n                (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;\n            columnDef._filterFn =\n                columnFilterFns[columnDef.id];\n        }\n        //assign sortingFns\n        if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {\n            // @ts-ignore\n            columnDef.sortingFn = sortingFns[columnDef.sortingFn];\n        }\n    }\n    else if (columnDef.columnDefType === 'display') {\n        columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);\n    }\n    return columnDef;\n});\nconst reorderColumn = (draggedColumn, targetColumn, columnOrder) => {\n    if (draggedColumn.getCanPin()) {\n        draggedColumn.pin(targetColumn.getIsPinned());\n    }\n    columnOrder.splice(columnOrder.indexOf(targetColumn.id), 0, columnOrder.splice(columnOrder.indexOf(draggedColumn.id), 1)[0]);\n    return [...columnOrder];\n};\nconst showExpandColumn = (props, grouping) => !!(props.enableExpanding ||\n    (props.enableGrouping && (grouping === undefined || (grouping === null || grouping === void 0 ? void 0 : grouping.length))) ||\n    props.renderDetailPanel);\nconst getLeadingDisplayColumnIds = (props) => {\n    var _a;\n    return [\n        (props.enableRowDragging || props.enableRowOrdering) && 'mrt-row-drag',\n        props.positionActionsColumn === 'first' &&\n            (props.enableRowActions ||\n                (props.enableEditing &&\n                    ['row', 'modal', 'custom'].includes((_a = props.editDisplayMode) !== null && _a !== void 0 ? _a : ''))) &&\n            'mrt-row-actions',\n        props.positionExpandColumn === 'first' &&\n            showExpandColumn(props) &&\n            'mrt-row-expand',\n        props.enableRowSelection && 'mrt-row-select',\n        props.enableRowNumbers && 'mrt-row-numbers',\n    ].filter(Boolean);\n};\nconst getTrailingDisplayColumnIds = (props) => {\n    var _a;\n    return [\n        props.positionActionsColumn === 'last' &&\n            (props.enableRowActions ||\n                (props.enableEditing &&\n                    ['row', 'modal'].includes((_a = props.editDisplayMode) !== null && _a !== void 0 ? _a : ''))) &&\n            'mrt-row-actions',\n        props.positionExpandColumn === 'last' &&\n            showExpandColumn(props) &&\n            'mrt-row-expand',\n    ].filter(Boolean);\n};\nconst getDefaultColumnOrderIds = (props) => {\n    const leadingDisplayCols = getLeadingDisplayColumnIds(props);\n    const trailingDisplayCols = getTrailingDisplayColumnIds(props);\n    const allLeafColumnDefs = getAllLeafColumnDefs(props.columns)\n        .map((columnDef) => getColumnId(columnDef))\n        .filter((columnId) => !leadingDisplayCols.includes(columnId) &&\n        !trailingDisplayCols.includes(columnId));\n    return [...leadingDisplayCols, ...allLeafColumnDefs, ...trailingDisplayCols];\n};\nconst getDefaultColumnFilterFn = (columnDef) => {\n    const { filterVariant } = columnDef;\n    if (filterVariant === 'multi-select')\n        return 'arrIncludesSome';\n    if (['range', 'date-range', 'range-slider'].includes(filterVariant || ''))\n        return 'betweenInclusive';\n    if (['select', 'checkbox', 'date'].includes(filterVariant || ''))\n        return 'equals';\n    return 'fuzzy';\n};\nconst getIsFirstColumn = (column, table) => {\n    return table.getVisibleLeafColumns()[0].id === column.id;\n};\nconst getIsLastColumn = (column, table) => {\n    const columns = table.getVisibleLeafColumns();\n    return columns[columns.length - 1].id === column.id;\n};\nconst getIsLastLeftPinnedColumn = (table, column) => {\n    return (column.getIsPinned() === 'left' &&\n        table.getLeftLeafHeaders().length - 1 === column.getPinnedIndex());\n};\nconst getIsFirstRightPinnedColumn = (column) => {\n    return column.getIsPinned() === 'right' && column.getPinnedIndex() === 0;\n};\nconst getTotalRight = (table, column) => {\n    return table\n        .getRightLeafHeaders()\n        .slice(column.getPinnedIndex() + 1)\n        .reduce((acc, col) => acc + col.getSize(), 0);\n};\nconst getCanRankRows = (table) => {\n    const { options, getState } = table;\n    const { manualExpanding, manualFiltering, manualGrouping, manualSorting, enableGlobalFilterRankedResults, } = options;\n    const { globalFilterFn, expanded } = getState();\n    return (!manualExpanding &&\n        !manualFiltering &&\n        !manualGrouping &&\n        !manualSorting &&\n        enableGlobalFilterRankedResults &&\n        globalFilterFn === 'fuzzy' &&\n        expanded !== true &&\n        !Object.values(expanded).some(Boolean));\n};\nconst getCommonCellStyles = ({ column, header, isStriped, row, table, tableCellProps, theme, }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const widthStyles = {\n        minWidth: `max(calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = column.columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,\n        width: `calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`,\n    };\n    return Object.assign(Object.assign(Object.assign({ backgroundColor: row\n            ? (row === null || row === void 0 ? void 0 : row.getIsSelected())\n                ? theme.fn.rgba(getPrimaryColor(theme), 0.1)\n                : column.getIsPinned() && column.columnDef.columnDefType !== 'group'\n                    ? theme.fn.rgba(theme.colorScheme === 'dark'\n                        ? theme.fn.darken(theme.colors.dark[7], 0.02)\n                        : theme.white, 0.97)\n                    : isStriped\n                        ? 'inherit'\n                        : theme.colorScheme === 'dark'\n                            ? theme.fn.lighten(theme.colors.dark[7], 0.02)\n                            : theme.white\n            : 'inherit', backgroundClip: 'padding-box', boxShadow: getIsLastLeftPinnedColumn(table, column)\n            ? `-4px 0 8px -6px ${theme.fn.rgba(theme.black, 0.2)} inset`\n            : getIsFirstRightPinnedColumn(column)\n                ? `4px 0 8px -6px ${theme.fn.rgba(theme.black, 0.2)} inset`\n                : undefined, display: table.options.layoutMode === 'grid' ? 'flex' : 'table-cell', flex: table.options.layoutMode === 'grid'\n            ? `var(--${header ? 'header' : 'col'}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size) 0 auto`\n            : undefined, left: column.getIsPinned() === 'left'\n            ? `${column.getStart('left')}px`\n            : undefined, ml: table.options.enableColumnVirtualization &&\n            column.getIsPinned() === 'left' &&\n            column.getPinnedIndex() === 0\n            ? `-${column.getSize() *\n                ((_f = (_e = table.getState().columnPinning.left) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 1)}px`\n            : undefined, mr: table.options.enableColumnVirtualization &&\n            column.getIsPinned() === 'right' &&\n            column.getPinnedIndex() === table.getVisibleLeafColumns().length - 1\n            ? `-${column.getSize() *\n                ((_h = (_g = table.getState().columnPinning.right) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 1) *\n                1.2}px`\n            : undefined, opacity: ((_j = table.getState().draggingColumn) === null || _j === void 0 ? void 0 : _j.id) === column.id ||\n            ((_k = table.getState().hoveredColumn) === null || _k === void 0 ? void 0 : _k.id) === column.id\n            ? 0.5\n            : 1, position: column.getIsPinned() && column.columnDef.columnDefType !== 'group'\n            ? 'sticky'\n            : undefined, right: column.getIsPinned() === 'right'\n            ? `${getTotalRight(table, column)}px`\n            : undefined, transition: table.options.enableColumnVirtualization\n            ? 'none'\n            : `padding 100ms ease-in-out` }, (!table.options.enableColumnResizing && widthStyles)), ((tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function\n        ? tableCellProps.sx(theme)\n        : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx)), (table.options.enableColumnResizing && widthStyles));\n};\nconst MRT_DefaultColumn = {\n    filterVariant: 'text',\n    minSize: 40,\n    maxSize: 1000,\n    size: 180,\n};\nconst MRT_DefaultDisplayColumn = {\n    columnDefType: 'display',\n    enableClickToCopy: false,\n    enableColumnActions: false,\n    enableColumnDragging: false,\n    enableColumnFilter: false,\n    enableColumnOrdering: false,\n    enableEditing: false,\n    enableGlobalFilter: false,\n    enableGrouping: false,\n    enableHiding: false,\n    enableResizing: false,\n    enableSorting: false,\n};\nconst getPrimaryShade = (theme) => {\n    var _a, _b, _c, _d, _e;\n    return (_e = (theme.colorScheme === 'dark'\n        ? // @ts-ignore\n            (_b = (_a = theme.primaryShade) === null || _a === void 0 ? void 0 : _a.dark) !== null && _b !== void 0 ? _b : theme.primaryShade\n        : // @ts-ignore\n            (_d = (_c = theme.primaryShade) === null || _c === void 0 ? void 0 : _c.light) !== null && _d !== void 0 ? _d : theme.primaryShade)) !== null && _e !== void 0 ? _e : 7;\n};\nconst getPrimaryColor = (theme, shade) => theme.colors[theme.primaryColor][shade !== null && shade !== void 0 ? shade : getPrimaryShade(theme)];\nconst parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, '_');\nconst flexRender = reactTable.flexRender;\nconst createRow = (table, originalRow) => reactTable.createRow(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns)\n    .filter((c) => c.columnDefType === 'data')\n    .map((col) => ({\n    [getColumnId(col)]: '',\n}))), -1, 0);\n\nconst MRT_Localization_EN = {\n    actions: 'Actions',\n    and: 'and',\n    cancel: 'Cancel',\n    changeFilterMode: 'Change filter mode',\n    changeSearchMode: 'Change search mode',\n    clearFilter: 'Clear filter',\n    clearSearch: 'Clear search',\n    clearSort: 'Clear sort',\n    clickToCopy: 'Click to copy',\n    collapse: 'Collapse',\n    collapseAll: 'Collapse all',\n    columnActions: 'Column Actions',\n    copiedToClipboard: 'Copied to clipboard',\n    dropToGroupBy: 'Drop to group by {column}',\n    edit: 'Edit',\n    expand: 'Expand',\n    expandAll: 'Expand all',\n    filterArrIncludes: 'Includes',\n    filterArrIncludesAll: 'Includes all',\n    filterArrIncludesSome: 'Includes',\n    filterBetween: 'Between',\n    filterBetweenInclusive: 'Between Inclusive',\n    filterByColumn: 'Filter by {column}',\n    filterContains: 'Contains',\n    filterEmpty: 'Empty',\n    filterEndsWith: 'Ends With',\n    filterEquals: 'Equals',\n    filterEqualsString: 'Equals',\n    filterFuzzy: 'Fuzzy',\n    filterGreaterThan: 'Greater Than',\n    filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',\n    filterInNumberRange: 'Between',\n    filterIncludesString: 'Contains',\n    filterIncludesStringSensitive: 'Contains',\n    filterLessThan: 'Less Than',\n    filterLessThanOrEqualTo: 'Less Than Or Equal To',\n    filterMode: 'Filter Mode: {filterType}',\n    filterNotEmpty: 'Not Empty',\n    filterNotEquals: 'Not Equals',\n    filterStartsWith: 'Starts With',\n    filterWeakEquals: 'Equals',\n    filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',\n    goToFirstPage: 'Go to first page',\n    goToLastPage: 'Go to last page',\n    goToNextPage: 'Go to next page',\n    goToPreviousPage: 'Go to previous page',\n    grab: 'Grab',\n    groupByColumn: 'Group by {column}',\n    groupedBy: 'Grouped by ',\n    hideAll: 'Hide all',\n    hideColumn: 'Hide {column} column',\n    max: 'Max',\n    min: 'Min',\n    move: 'Move',\n    noRecordsToDisplay: 'No records to display',\n    noResultsFound: 'No results found',\n    of: 'of',\n    or: 'or',\n    pinToLeft: 'Pin to left',\n    pinToRight: 'Pin to right',\n    resetColumnSize: 'Reset column size',\n    resetOrder: 'Reset order',\n    rowActions: 'Row Actions',\n    rowNumber: '#',\n    rowNumbers: 'Row Numbers',\n    rowsPerPage: 'Rows per page',\n    save: 'Save',\n    search: 'Search',\n    selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',\n    select: 'Select',\n    showAll: 'Show all',\n    showAllColumns: 'Show all columns',\n    showHideColumns: 'Show/Hide columns',\n    showHideFilters: 'Show/Hide filters',\n    showHideSearch: 'Show/Hide search',\n    sortByColumnAsc: 'Sort by {column} ascending',\n    sortByColumnDesc: 'Sort by {column} descending',\n    sortedByColumnAsc: 'Sorted by {column} ascending',\n    sortedByColumnDesc: 'Sorted by {column} descending',\n    thenBy: ', then by ',\n    toggleDensity: 'Toggle density',\n    toggleFullScreen: 'Toggle full screen',\n    toggleSelectAll: 'Toggle select all',\n    toggleSelectRow: 'Toggle select row',\n    toggleVisibility: 'Toggle visibility',\n    ungroupByColumn: 'Ungroup by {column}',\n    unpin: 'Unpin',\n    unpinAll: 'Unpin all',\n};\n\nconst MRT_Default_Icons = {\n    IconArrowAutofitContent: iconsReact.IconArrowAutofitContent,\n    IconArrowsSort: iconsReact.IconArrowsSort,\n    IconBaselineDensityLarge: iconsReact.IconBaselineDensityLarge,\n    IconBaselineDensityMedium: iconsReact.IconBaselineDensityMedium,\n    IconBaselineDensitySmall: iconsReact.IconBaselineDensitySmall,\n    IconBoxMultiple: iconsReact.IconBoxMultiple,\n    IconChevronDown: iconsReact.IconChevronDown,\n    IconChevronLeft: iconsReact.IconChevronLeft,\n    IconChevronLeftPipe: iconsReact.IconChevronLeftPipe,\n    IconChevronRight: iconsReact.IconChevronRight,\n    IconChevronRightPipe: iconsReact.IconChevronRightPipe,\n    IconChevronsDown: iconsReact.IconChevronsDown,\n    IconCircleX: iconsReact.IconCircleX,\n    IconClearAll: iconsReact.IconClearAll,\n    IconColumns: iconsReact.IconColumns,\n    IconDeviceFloppy: iconsReact.IconDeviceFloppy,\n    IconDots: iconsReact.IconDots,\n    IconDotsVertical: iconsReact.IconDotsVertical,\n    IconEdit: iconsReact.IconEdit,\n    IconEyeOff: iconsReact.IconEyeOff,\n    IconFilter: iconsReact.IconFilter,\n    IconFilterCog: iconsReact.IconFilterCog,\n    IconFilterOff: iconsReact.IconFilterOff,\n    IconGripHorizontal: iconsReact.IconGripHorizontal,\n    IconMaximize: iconsReact.IconMaximize,\n    IconMinimize: iconsReact.IconMinimize,\n    IconPinned: iconsReact.IconPinned,\n    IconPinnedOff: iconsReact.IconPinnedOff,\n    IconSearch: iconsReact.IconSearch,\n    IconSearchOff: iconsReact.IconSearchOff,\n    IconSortAscending: iconsReact.IconSortAscending,\n    IconSortDescending: iconsReact.IconSortDescending,\n    IconX: iconsReact.IconX,\n};\n\nconst useMRT_TableOptions = (_a) => {\n    var _b;\n    var { aggregationFns, autoResetExpanded = false, columnFilterDisplayMode = 'subheader', columnResizeMode = 'onChange', createDisplayMode = 'modal', defaultColumn, defaultDisplayColumn, editDisplayMode = 'modal', enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnResizing = false, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enablePinning = false, enableRowSelection = false, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns, icons, layoutMode = 'semantic', localization, manualFiltering, manualGrouping, manualPagination, manualSorting, paginationDisplayMode = 'default', positionActionsColumn = 'first', positionExpandColumn = 'first', positionGlobalFilter = 'right', positionPagination = 'bottom', positionToolbarAlertBanner = 'top', positionToolbarDropZone = 'top', rowNumberMode = 'static', selectAllMode = 'page', sortingFns } = _a, rest = __rest(_a, [\"aggregationFns\", \"autoResetExpanded\", \"columnFilterDisplayMode\", \"columnResizeMode\", \"createDisplayMode\", \"defaultColumn\", \"defaultDisplayColumn\", \"editDisplayMode\", \"enableBottomToolbar\", \"enableColumnActions\", \"enableColumnFilters\", \"enableColumnOrdering\", \"enableColumnResizing\", \"enableDensityToggle\", \"enableExpandAll\", \"enableExpanding\", \"enableFilterMatchHighlighting\", \"enableFilters\", \"enableFullScreenToggle\", \"enableGlobalFilter\", \"enableGlobalFilterRankedResults\", \"enableGrouping\", \"enableHiding\", \"enableMultiRowSelection\", \"enableMultiSort\", \"enablePagination\", \"enablePinning\", \"enableRowSelection\", \"enableSelectAll\", \"enableSorting\", \"enableStickyHeader\", \"enableTableFooter\", \"enableTableHead\", \"enableToolbarInternalActions\", \"enableTopToolbar\", \"filterFns\", \"icons\", \"layoutMode\", \"localization\", \"manualFiltering\", \"manualGrouping\", \"manualPagination\", \"manualSorting\", \"paginationDisplayMode\", \"positionActionsColumn\", \"positionExpandColumn\", \"positionGlobalFilter\", \"positionPagination\", \"positionToolbarAlertBanner\", \"positionToolbarDropZone\", \"rowNumberMode\", \"selectAllMode\", \"sortingFns\"]);\n    const _icons = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Default_Icons), icons)), [icons]);\n    const _localization = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Localization_EN), localization)), [localization]);\n    const _aggregationFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns)), []);\n    const _filterFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_FilterFns), filterFns)), []);\n    const _sortingFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_SortingFns), sortingFns)), []);\n    const _defaultColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn)), [defaultColumn]);\n    const _defaultDisplayColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn)), [defaultDisplayColumn]);\n    if (rest.enableRowVirtualization || rest.enableColumnVirtualization) {\n        layoutMode = 'grid';\n    }\n    if (rest.enableRowVirtualization) {\n        enableStickyHeader = true;\n    }\n    if (enablePagination === false && manualPagination === undefined) {\n        manualPagination = true;\n    }\n    if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {\n        manualFiltering = true;\n        manualGrouping = true;\n        manualPagination = true;\n        manualSorting = true;\n    }\n    return Object.assign({ aggregationFns: _aggregationFns, autoResetExpanded,\n        columnFilterDisplayMode,\n        columnResizeMode,\n        createDisplayMode, defaultColumn: _defaultColumn, defaultDisplayColumn: _defaultDisplayColumn, editDisplayMode,\n        enableBottomToolbar,\n        enableColumnActions,\n        enableColumnFilters,\n        enableColumnOrdering,\n        enableColumnResizing,\n        enableDensityToggle,\n        enableExpandAll,\n        enableExpanding,\n        enableFilterMatchHighlighting,\n        enableFilters,\n        enableFullScreenToggle,\n        enableGlobalFilter,\n        enableGlobalFilterRankedResults,\n        enableGrouping,\n        enableHiding,\n        enableMultiRowSelection,\n        enableMultiSort,\n        enablePagination,\n        enablePinning,\n        enableRowSelection,\n        enableSelectAll,\n        enableSorting,\n        enableStickyHeader,\n        enableTableFooter,\n        enableTableHead,\n        enableToolbarInternalActions,\n        enableTopToolbar, filterFns: _filterFns, icons: _icons, layoutMode, localization: _localization, manualFiltering,\n        manualGrouping,\n        manualPagination,\n        manualSorting,\n        paginationDisplayMode,\n        positionActionsColumn,\n        positionExpandColumn,\n        positionGlobalFilter,\n        positionPagination,\n        positionToolbarAlertBanner,\n        positionToolbarDropZone,\n        rowNumberMode,\n        selectAllMode, sortingFns: _sortingFns }, rest);\n};\n\nconst MRT_EditCellTextInput = ({ cell, table, }) => {\n    var _a;\n    const { getState, options: { createDisplayMode, editDisplayMode, mantineEditTextInputProps, mantineEditSelectProps, }, refs: { editInputRefs }, setEditingCell, setEditingRow, setCreatingRow, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { creatingRow, editingRow } = getState();\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const isSelectEdit = columnDef.editVariant === 'select';\n    const [value, setValue] = react.useState(() => cell.getValue());\n    const mTableBodyCellEditTextInputProps = mantineEditTextInputProps instanceof Function\n        ? mantineEditTextInputProps({ cell, column, row, table })\n        : mantineEditTextInputProps;\n    const mcTableBodyCellEditTextInputProps = columnDef.mantineEditTextInputProps instanceof Function\n        ? columnDef.mantineEditTextInputProps({\n            cell,\n            column,\n            row,\n            table,\n        })\n        : columnDef.mantineEditTextInputProps;\n    const textInputProps = Object.assign(Object.assign({}, mTableBodyCellEditTextInputProps), mcTableBodyCellEditTextInputProps);\n    const mTableBodyCellEditSelectProps = mantineEditSelectProps instanceof Function\n        ? mantineEditSelectProps({ cell, column, row, table })\n        : mantineEditSelectProps;\n    const mcTableBodyCellEditSelectProps = columnDef.mantineEditSelectProps instanceof Function\n        ? columnDef.mantineEditSelectProps({\n            cell,\n            column,\n            row,\n            table,\n        })\n        : columnDef.mantineEditSelectProps;\n    const selectProps = Object.assign(Object.assign({}, mTableBodyCellEditSelectProps), mcTableBodyCellEditSelectProps);\n    const saveInputValueToRowCache = (newValue) => {\n        //@ts-ignore\n        row._valuesCache[column.id] = newValue;\n        if (isCreating) {\n            setCreatingRow(row);\n        }\n        else if (isEditing) {\n            setEditingRow(row);\n        }\n    };\n    const handleBlur = (event) => {\n        var _a;\n        (_a = textInputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);\n        saveInputValueToRowCache(value);\n        setEditingCell(null);\n    };\n    const handleEnterKeyDown = (event) => {\n        var _a, _b;\n        (_a = textInputProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);\n        if (event.key === 'Enter') {\n            (_b = editInputRefs.current[cell.id]) === null || _b === void 0 ? void 0 : _b.blur();\n        }\n    };\n    if (columnDef.Edit) {\n        return (_a = columnDef.Edit) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table });\n    }\n    const commonProps = {\n        disabled: (columnDef.enableEditing instanceof Function\n            ? columnDef.enableEditing(row)\n            : columnDef.enableEditing) === false,\n        label: ['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))\n            ? column.columnDef.header\n            : undefined,\n        name: cell.id,\n        placeholder: !['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))\n            ? columnDef.header\n            : undefined,\n        value,\n        variant: editDisplayMode === 'table' ? 'unstyled' : 'default',\n        onClick: (e) => {\n            var _a;\n            e.stopPropagation();\n            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, e);\n        },\n    };\n    if (isSelectEdit) {\n        return (\n        // @ts-ignore\n        jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { searchable: true, value: value, withinPortal: true }, selectProps, { onBlur: handleBlur, onChange: (value) => {\n                var _a;\n                (_a = selectProps.onChange) === null || _a === void 0 ? void 0 : _a.call(selectProps, value);\n                setValue(value);\n            }, onClick: (e) => {\n                var _a;\n                e.stopPropagation();\n                (_a = selectProps === null || selectProps === void 0 ? void 0 : selectProps.onClick) === null || _a === void 0 ? void 0 : _a.call(selectProps, e);\n            }, ref: (node) => {\n                if (node) {\n                    editInputRefs.current[cell.id] = node;\n                    if (selectProps.ref) {\n                        selectProps.ref.current = node;\n                    }\n                }\n            } })));\n    }\n    return (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { onKeyDown: handleEnterKeyDown, value: value !== null && value !== void 0 ? value : '' }, textInputProps, { onBlur: handleBlur, onChange: (event) => {\n            var _a;\n            (_a = textInputProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);\n            setValue(event.target.value);\n        }, onClick: (event) => {\n            var _a;\n            event.stopPropagation();\n            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);\n        }, ref: (node) => {\n            if (node) {\n                editInputRefs.current[cell.id] = node;\n                if (textInputProps.ref) {\n                    textInputProps.ref.current = node;\n                }\n            }\n        } })));\n};\n\nconst MRT_CopyButton = ({ cell, children, table, }) => {\n    const { options: { localization, mantineCopyButtonProps }, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const mTableBodyCellCopyButtonProps = mantineCopyButtonProps instanceof Function\n        ? mantineCopyButtonProps({ cell, column, row, table })\n        : mantineCopyButtonProps;\n    const mcTableBodyCellCopyButtonProps = columnDef.mantineCopyButtonProps instanceof Function\n        ? columnDef.mantineCopyButtonProps({\n            cell,\n            column,\n            row,\n            table,\n        })\n        : columnDef.mantineCopyButtonProps;\n    const buttonProps = Object.assign(Object.assign({}, mTableBodyCellCopyButtonProps), mcTableBodyCellCopyButtonProps);\n    return (jsxRuntime.jsx(core.CopyButton, { value: cell.getValue(), children: ({ copied, copy }) => {\n            var _a;\n            return (jsxRuntime.jsx(core.Tooltip, { color: copied ? 'green' : undefined, withinPortal: true, openDelay: 1000, label: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : (copied ? localization.copiedToClipboard : localization.clickToCopy), children: jsxRuntime.jsx(core.UnstyledButton, Object.assign({}, buttonProps, { onClick: (e) => {\n                        e.stopPropagation();\n                        copy();\n                    }, sx: (theme) => (Object.assign({ backgroundColor: 'transparent', border: 'none', borderRadius: '4px', color: 'inherit', cursor: 'copy', fontFamily: 'inherit', fontSize: 'inherit', fontWeight: 'inherit', justifyContent: 'inherit', letterSpacing: 'inherit', margin: '-4px', minWidth: 'unset', padding: '4px', textAlign: 'inherit', textTransform: 'inherit', '&:active': {\n                            transform: 'translateY(1px)',\n                        }, '&:hover': {\n                            backgroundColor: theme.fn.rgba(getPrimaryColor(theme), 0.1),\n                        } }, ((buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx) instanceof Function\n                        ? buttonProps.sx(theme)\n                        : buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx))), title: undefined, children: children })) }));\n        } }));\n};\n\nconst allowedTypes = ['string', 'number'];\nconst allowedFilterVariants = ['text', 'autocomplete'];\nconst MRT_TableBodyCellValue = ({ cell, table, }) => {\n    var _a, _b;\n    const { getState, options: { enableFilterMatchHighlighting, mantineHighlightProps }, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { globalFilter, globalFilterFn } = getState();\n    const filterValue = column.getFilterValue();\n    const highlightProps = (mantineHighlightProps instanceof Function\n        ? mantineHighlightProps({ cell, column, row, table })\n        : mantineHighlightProps);\n    let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell\n        ? columnDef.AggregatedCell({\n            cell,\n            column,\n            row,\n            table,\n        })\n        : row.getIsGrouped() && !cell.getIsGrouped()\n            ? null\n            : cell.getIsGrouped() && columnDef.GroupedCell\n                ? columnDef.GroupedCell({\n                    cell,\n                    column,\n                    row,\n                    table,\n                })\n                : undefined;\n    const isGroupedValue = renderedCellValue !== undefined;\n    if (!isGroupedValue) {\n        renderedCellValue = cell.renderValue();\n    }\n    if (enableFilterMatchHighlighting &&\n        columnDef.enableFilterMatchHighlighting !== false &&\n        renderedCellValue &&\n        allowedTypes.includes(typeof renderedCellValue) &&\n        ((filterValue &&\n            allowedTypes.includes(typeof filterValue) &&\n            allowedFilterVariants.includes(columnDef.filterVariant)) ||\n            (globalFilter &&\n                allowedTypes.includes(typeof globalFilter) &&\n                column.getCanGlobalFilter()))) {\n        let highlight = ((_b = (_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : globalFilter) !== null && _b !== void 0 ? _b : '').toString();\n        if ((filterValue ? columnDef._filterFn : globalFilterFn) === 'fuzzy') {\n            highlight = highlight.split(' ');\n        }\n        renderedCellValue = (jsxRuntime.jsx(core.Highlight, Object.assign({ highlightColor: \"yellow.3\", highlight: highlight }, highlightProps, { children: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString() })));\n    }\n    if (columnDef.Cell && !isGroupedValue) {\n        renderedCellValue = columnDef.Cell({\n            cell,\n            renderedCellValue,\n            column,\n            row,\n            table,\n        });\n    }\n    return renderedCellValue;\n};\n\nconst MRT_TableBodyCell = ({ cell, isStriped, measureElement, numRows, rowIndex, rowRef, table, virtualCell, }) => {\n    var _a, _b, _c, _d;\n    const theme = core.useMantineTheme();\n    const { getState, options: { createDisplayMode, editDisplayMode, enableClickToCopy, enableColumnOrdering, enableEditing, enableGrouping, enableRowNumbers, layoutMode, mantineTableBodyCellProps, mantineSkeletonProps, rowNumberMode, }, refs: { editInputRefs }, setEditingCell, setHoveredColumn, } = table;\n    const { creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons, } = getState();\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const mTableCellBodyProps = mantineTableBodyCellProps instanceof Function\n        ? mantineTableBodyCellProps({ cell, column, row, table })\n        : mantineTableBodyCellProps;\n    const mcTableCellBodyProps = columnDef.mantineTableBodyCellProps instanceof Function\n        ? columnDef.mantineTableBodyCellProps({ cell, column, row, table })\n        : columnDef.mantineTableBodyCellProps;\n    const tableCellProps = Object.assign(Object.assign({}, mTableCellBodyProps), mcTableCellBodyProps);\n    const skeletonProps = mantineSkeletonProps instanceof Function\n        ? mantineSkeletonProps({ cell, column, row, table })\n        : mantineSkeletonProps;\n    const [skeletonWidth, setSkeletonWidth] = react.useState(100);\n    react.useEffect(() => {\n        if ((!isLoading && !showSkeletons) || skeletonWidth !== 100)\n            return;\n        const size = column.getSize();\n        setSkeletonWidth(columnDefType === 'display'\n            ? size / 2\n            : Math.round(Math.random() * (size - size / 3) + size / 3));\n    }, [isLoading, showSkeletons]);\n    const draggingBorders = react.useMemo(() => {\n        const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;\n        const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;\n        const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;\n        const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;\n        const isFirstColumn = getIsFirstColumn(column, table);\n        const isLastColumn = getIsLastColumn(column, table);\n        const isLastRow = rowIndex === numRows && numRows - 1;\n        const borderStyle = isDraggingColumn || isDraggingRow\n            ? `1px dashed ${theme.colors.gray[7]} !important`\n            : isHoveredColumn || isHoveredRow\n                ? `2px dashed ${getPrimaryColor(theme)} !important`\n                : undefined;\n        return borderStyle\n            ? {\n                borderLeft: isDraggingColumn ||\n                    isHoveredColumn ||\n                    ((isDraggingRow || isHoveredRow) && isFirstColumn)\n                    ? borderStyle\n                    : undefined,\n                borderRight: isDraggingColumn ||\n                    isHoveredColumn ||\n                    ((isDraggingRow || isHoveredRow) && isLastColumn)\n                    ? borderStyle\n                    : undefined,\n                borderBottom: isDraggingRow || isHoveredRow || isLastRow\n                    ? borderStyle\n                    : undefined,\n                borderTop: isDraggingRow || isHoveredRow ? borderStyle : undefined,\n            }\n            : undefined;\n    }, [draggingColumn, draggingRow, hoveredColumn, hoveredRow, rowIndex]);\n    const isEditable = (enableEditing instanceof Function ? enableEditing(row) : enableEditing) &&\n        (columnDef.enableEditing instanceof Function\n            ? columnDef.enableEditing(row)\n            : columnDef.enableEditing) !== false;\n    const isEditing = isEditable &&\n        !['modal', 'custom'].includes(editDisplayMode) &&\n        (editDisplayMode === 'table' ||\n            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id ||\n            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) &&\n        !row.getIsGrouped();\n    const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const handleDoubleClick = (event) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n        if (isEditable && editDisplayMode === 'cell') {\n            setEditingCell(cell);\n            setTimeout(() => {\n                var _a;\n                const textField = editInputRefs.current[cell.id];\n                if (textField) {\n                    textField.focus();\n                    (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);\n                }\n            }, 100);\n        }\n    };\n    const handleDragEnter = (e) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);\n        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            setHoveredColumn(null);\n        }\n        if (enableColumnOrdering && draggingColumn) {\n            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n        }\n    };\n    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: \"td\", \"data-index\": virtualCell === null || virtualCell === void 0 ? void 0 : virtualCell.index, ref: (node) => {\n            if (node) {\n                measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);\n            }\n        } }, tableCellProps, { onDragEnter: handleDragEnter, onDoubleClick: handleDoubleClick, sx: (theme) => (Object.assign(Object.assign({ alignItems: layoutMode === 'grid' ? 'center' : undefined, cursor: isEditable && editDisplayMode === 'cell' ? 'pointer' : 'inherit', justifyContent: layoutMode === 'grid' ? tableCellProps.align : undefined, overflow: 'hidden', paddingLeft: column.id === 'mrt-row-expand'\n                ? `${row.depth + 1}rem !important`\n                : undefined, textOverflow: columnDefType !== 'display' ? 'ellipsis' : undefined, whiteSpace: density === 'xs' ? 'nowrap' : 'normal', zIndex: (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : column.getIsPinned() ? 1 : 0, '&:hover': {\n                outline: isEditing &&\n                    ['table', 'cell'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '') &&\n                    columnDefType !== 'display'\n                    ? `1px solid ${theme.colors.gray[7]}`\n                    : undefined,\n                outlineOffset: '-1px',\n                textOverflow: 'clip',\n            } }, getCommonCellStyles({\n            column,\n            isStriped,\n            row,\n            table,\n            theme,\n            tableCellProps,\n        })), draggingBorders)), children: [jsxRuntime.jsx(jsxRuntime.Fragment, { children: cell.getIsPlaceholder() ? ((_b = (_a = columnDef.PlaceholderCell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table })) !== null && _b !== void 0 ? _b : null) : (isLoading || showSkeletons) &&\n                    [undefined, null].includes(cell.getValue()) ? (jsxRuntime.jsx(core.Skeleton, Object.assign({ height: 20, width: skeletonWidth }, skeletonProps))) : enableRowNumbers &&\n                    rowNumberMode === 'static' &&\n                    column.id === 'mrt-row-numbers' ? (rowIndex + 1) : columnDefType === 'display' &&\n                    (['mrt-row-drag', 'mrt-row-expand', 'mrt-row-select'].includes(column.id) ||\n                        !row.getIsGrouped()) ? ((_c = columnDef.Cell) === null || _c === void 0 ? void 0 : _c.call(columnDef, {\n                    cell,\n                    column,\n                    row,\n                    rowRef,\n                    renderedCellValue: jsxRuntime.jsx(jsxRuntime.Fragment, { children: cell.getValue() }),\n                    table,\n                })) : isCreating || isEditing ? (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table })) : (enableClickToCopy || columnDef.enableClickToCopy) &&\n                    columnDef.enableClickToCopy !== false ? (jsxRuntime.jsx(MRT_CopyButton, { cell: cell, table: table, children: jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table }) })) : (jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table })) }), cell.getIsGrouped() && !columnDef.GroupedCell && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [\" (\", (_d = row.subRows) === null || _d === void 0 ? void 0 : _d.length, \")\"] }))] })));\n};\nconst Memo_MRT_TableBodyCell = react.memo(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);\n\nconst MRT_TableDetailPanel = ({ parentRowRef, row, rowIndex, table, virtualRow, }) => {\n    const { getVisibleLeafColumns, getState, options: { layoutMode, mantineTableBodyRowProps, mantineDetailPanelProps, renderDetailPanel, }, } = table;\n    const { isLoading } = getState();\n    const tableRowProps = mantineTableBodyRowProps instanceof Function\n        ? mantineTableBodyRowProps({\n            isDetailPanel: true,\n            row,\n            staticRowIndex: rowIndex,\n            table,\n        })\n        : mantineTableBodyRowProps;\n    const tableCellProps = mantineDetailPanelProps instanceof Function\n        ? mantineDetailPanelProps({ row, table })\n        : mantineDetailPanelProps;\n    return (jsxRuntime.jsx(core.Box, Object.assign({ component: \"tr\", className: \"mantine-TableBodyCell-DetailPanel\" }, tableRowProps, { sx: (theme) => {\n            var _a, _b;\n            return (Object.assign({ display: layoutMode === 'grid' ? 'flex' : 'table-row', position: virtualRow ? 'absolute' : undefined, top: virtualRow\n                    ? `${(_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px`\n                    : undefined, transform: virtualRow\n                    ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)`\n                    : undefined, width: '100%', zIndex: virtualRow ? 2 : undefined }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function\n                ? tableRowProps.sx(theme)\n                : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx)));\n        }, children: jsxRuntime.jsx(core.Box, Object.assign({ component: \"td\", className: \"mantine-TableBodyCell-DetailPanel\", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => (Object.assign({ backgroundColor: virtualRow\n                    ? theme.fn.lighten(theme.colors.dark[7], 0.06)\n                    : undefined, borderBottom: !row.getIsExpanded() ? 'none' : undefined, display: layoutMode === 'grid' ? 'flex' : 'table-cell', paddingBottom: row.getIsExpanded()\n                    ? '16px !important'\n                    : '0 !important', paddingTop: row.getIsExpanded() ? '16px !important' : '0 !important', transition: 'all 100ms ease-in-out', width: `${table.getTotalSize()}px` }, ((tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function\n                ? tableCellProps.sx(theme)\n                : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx))), children: renderDetailPanel && (jsxRuntime.jsx(core.Collapse, { in: row.getIsExpanded(), children: !isLoading && renderDetailPanel({ row, table }) })) })) })));\n};\n\nconst MRT_TableBodyRow = ({ columnVirtualizer, enableHover, isStriped, measureElement, numRows, row, rowIndex, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, virtualRow, }) => {\n    const { getState, options: { enableRowOrdering, layoutMode, memoMode, mantineTableBodyRowProps, renderDetailPanel, }, setHoveredRow, } = table;\n    const { draggingColumn, draggingRow, editingCell, editingRow, hoveredRow } = getState();\n    const tableRowProps = mantineTableBodyRowProps instanceof Function\n        ? mantineTableBodyRowProps({ row, staticRowIndex: rowIndex, table })\n        : mantineTableBodyRowProps;\n    const handleDragEnter = (_e) => {\n        if (enableRowOrdering && draggingRow) {\n            setHoveredRow(row);\n        }\n    };\n    const rowRef = react.useRef(null);\n    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(core.Box, Object.assign({ component: \"tr\", \"data-index\": virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.index, onDragEnter: handleDragEnter, ref: (node) => {\n                    if (node) {\n                        rowRef.current = node;\n                        measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);\n                    }\n                } }, tableRowProps, { sx: (theme) => (Object.assign({ boxSizing: 'border-box', display: layoutMode === 'grid' ? 'flex' : 'table-row', opacity: (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id || (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id ? 0.5 : 1, position: virtualRow ? 'absolute' : undefined, top: virtualRow ? 0 : undefined, transition: virtualRow ? 'none' : 'all 100ms ease-in-out', width: '100%', '&:hover td': {\n                        backgroundColor: enableHover !== false\n                            ? row.getIsSelected()\n                                ? theme.fn.rgba(getPrimaryColor(theme), 0.2)\n                                : theme.colorScheme === 'dark'\n                                    ? `${theme.fn.lighten(theme.colors.dark[7], 0.12)}`\n                                    : `${theme.fn.darken(theme.white, 0.05)}`\n                            : undefined,\n                    } }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function\n                    ? tableRowProps.sx(theme)\n                    : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx))), style: Object.assign({ transform: virtualRow\n                        ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)`\n                        : undefined }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), children: [virtualPaddingLeft ? (jsxRuntime.jsx(\"td\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : row.getVisibleCells()).map((cellOrVirtualCell) => {\n                        var _a, _b;\n                        const cell = columnVirtualizer\n                            ? row.getVisibleCells()[cellOrVirtualCell.index]\n                            : cellOrVirtualCell;\n                        const props = {\n                            cell,\n                            isStriped,\n                            measureElement: columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement,\n                            numRows,\n                            rowIndex,\n                            rowRef,\n                            table,\n                            virtualCell: columnVirtualizer\n                                ? cellOrVirtualCell\n                                : undefined,\n                        };\n                        return memoMode === 'cells' &&\n                            cell.column.columnDef.columnDefType === 'data' &&\n                            !draggingColumn &&\n                            !draggingRow &&\n                            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id &&\n                            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (jsxRuntime.jsx(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_a = cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString()))) : (jsxRuntime.jsx(MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_b = cell.getValue) === null || _b === void 0 ? void 0 : _b.toString())));\n                    }), virtualPaddingRight ? (jsxRuntime.jsx(\"td\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })), renderDetailPanel && !row.getIsGrouped() && (jsxRuntime.jsx(MRT_TableDetailPanel, { parentRowRef: rowRef, row: row, rowIndex: rowIndex, table: table, virtualRow: virtualRow }))] }));\n};\nconst Memo_MRT_TableBodyRow = react.memo(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.rowIndex === next.rowIndex);\n\nconst MRT_TableBody = ({ columnVirtualizer, enableHover, isStriped, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {\n    var _a, _b, _c;\n    const { getRowModel, getPrePaginationRowModel, getState, options: { createDisplayMode, enableGlobalFilterRankedResults, enablePagination, enableRowVirtualization, layoutMode, localization, mantineTableBodyProps, manualExpanding, manualFiltering, manualGrouping, manualPagination, manualSorting, memoMode, renderEmptyRowsFallback, rowVirtualizerInstanceRef, rowVirtualizerProps, }, refs: { tableContainerRef, tablePaperRef }, } = table;\n    const { creatingRow, columnFilters, density, expanded, globalFilter, pagination, sorting, } = getState();\n    const tableBodyProps = mantineTableBodyProps instanceof Function\n        ? mantineTableBodyProps({ table })\n        : mantineTableBodyProps;\n    const vProps = rowVirtualizerProps instanceof Function\n        ? rowVirtualizerProps({ table })\n        : rowVirtualizerProps;\n    const shouldRankRows = react.useMemo(() => getCanRankRows(table) &&\n        !Object.values(sorting).some(Boolean) &&\n        globalFilter, [\n        enableGlobalFilterRankedResults,\n        expanded,\n        globalFilter,\n        manualExpanding,\n        manualFiltering,\n        manualGrouping,\n        manualSorting,\n        sorting,\n    ]);\n    const rows = react.useMemo(() => {\n        if (!shouldRankRows)\n            return getRowModel().rows;\n        const rankedRows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));\n        if (enablePagination && !manualPagination) {\n            const start = pagination.pageIndex * pagination.pageSize;\n            return rankedRows.slice(start, start + pagination.pageSize);\n        }\n        return rankedRows;\n    }, [\n        shouldRankRows,\n        shouldRankRows ? getPrePaginationRowModel().rows : getRowModel().rows,\n        pagination.pageIndex,\n        pagination.pageSize,\n    ]);\n    const rowVirtualizer = enableRowVirtualization\n        ? reactVirtual.useVirtualizer(Object.assign({ count: rows.length, estimateSize: () => density === 'xs' ? 42.7 : density === 'md' ? 54.7 : 70.7, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== 'undefined' &&\n                navigator.userAgent.indexOf('Firefox') === -1\n                ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height\n                : undefined, overscan: 4 }, vProps))\n        : undefined;\n    if (rowVirtualizerInstanceRef && rowVirtualizer) {\n        rowVirtualizerInstanceRef.current = rowVirtualizer;\n    }\n    const virtualRows = rowVirtualizer\n        ? rowVirtualizer.getVirtualItems()\n        : undefined;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: \"tbody\" }, tableBodyProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-row-group', height: rowVirtualizer\n                ? `${rowVirtualizer.getTotalSize()}px`\n                : 'inherit', minHeight: !rows.length ? '100px' : undefined, position: 'relative' }, ((tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx) instanceof Function\n            ? tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx(theme)\n            : tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx))), children: [creatingRow && createDisplayMode === 'row' && (jsxRuntime.jsx(MRT_TableBodyRow, { table: table, row: creatingRow, rowIndex: -1 })), !rows.length ? (jsxRuntime.jsx(\"tr\", { style: { display: layoutMode === 'grid' ? 'grid' : 'table-row' }, children: jsxRuntime.jsx(\"td\", { colSpan: table.getVisibleLeafColumns().length, style: { display: layoutMode === 'grid' ? 'grid' : 'table-cell' }, children: (_a = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsx(core.Text, { sx: {\n                            color: 'gray',\n                            fontStyle: 'italic',\n                            maxWidth: `min(100vw, ${(_c = (_b = tablePaperRef.current) === null || _b === void 0 ? void 0 : _b.clientWidth) !== null && _c !== void 0 ? _c : 360}px)`,\n                            paddingTop: '2rem',\n                            paddingBottom: '2rem',\n                            textAlign: 'center',\n                            width: '100%',\n                        }, children: globalFilter || columnFilters.length\n                            ? localization.noResultsFound\n                            : localization.noRecordsToDisplay })) }) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, rowIndex) => {\n                    const row = rowVirtualizer\n                        ? rows[rowOrVirtualRow.index]\n                        : rowOrVirtualRow;\n                    const props = {\n                        columnVirtualizer,\n                        enableHover,\n                        isStriped,\n                        measureElement: rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement,\n                        numRows: rows.length,\n                        row,\n                        rowIndex: rowVirtualizer ? rowOrVirtualRow.index : rowIndex,\n                        table,\n                        virtualColumns,\n                        virtualPaddingLeft,\n                        virtualPaddingRight,\n                        virtualRow: rowVirtualizer\n                            ? rowOrVirtualRow\n                            : undefined,\n                    };\n                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id || `mrt-${row.index}`)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id || `mrt-${row.index}`));\n                }) }))] })));\n};\nconst Memo_MRT_TableBody = react.memo(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);\n\nconst MRT_GrabHandleButton = ({ actionIconProps, onDragEnd, onDragStart, table, }) => {\n    var _a;\n    const { options: { icons: { IconGripHorizontal }, localization, }, } = table;\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : localization.move, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ draggable: \"true\", size: \"sm\" }, actionIconProps, { onClick: (e) => {\n                var _a;\n                e.stopPropagation();\n                (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, e);\n            }, onDragStart: onDragStart, onDragEnd: onDragEnd, sx: (theme) => (Object.assign({ cursor: 'grab', margin: '0 -0.16px', opacity: 0.5, padding: '2px', transition: 'opacity 100ms ease-in-out', '&:hover': {\n                    backgroundColor: 'transparent',\n                    opacity: 1,\n                }, '&:active': {\n                    cursor: 'grabbing',\n                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function\n                ? actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx(theme)\n                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: jsxRuntime.jsx(IconGripHorizontal, {}) })) }));\n};\n\nconst MRT_TableBodyRowGrabHandle = ({ row, rowRef, table, }) => {\n    const { options: { mantineRowDragHandleProps }, } = table;\n    const actionIconProps = mantineRowDragHandleProps instanceof Function\n        ? mantineRowDragHandleProps({ row, table })\n        : mantineRowDragHandleProps;\n    const handleDragStart = (event) => {\n        var _a;\n        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);\n        event.dataTransfer.setDragImage(rowRef.current, 0, 0);\n        table.setDraggingRow(row);\n    };\n    const handleDragEnd = (event) => {\n        var _a;\n        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);\n        table.setDraggingRow(null);\n        table.setHoveredRow(null);\n    };\n    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));\n};\n\nconst MRT_ExpandAllButton = ({ table, }) => {\n    var _a, _b;\n    const { getIsAllRowsExpanded, getIsSomeRowsExpanded, getCanSomeRowsExpand, getState, options: { icons: { IconChevronsDown }, localization, mantineExpandAllButtonProps, renderDetailPanel, }, toggleAllRowsExpanded, } = table;\n    const { density, isLoading } = getState();\n    const actionIconProps = mantineExpandAllButtonProps instanceof Function\n        ? mantineExpandAllButtonProps({ table })\n        : mantineExpandAllButtonProps;\n    const isAllRowsExpanded = getIsAllRowsExpanded();\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isAllRowsExpanded)\n            ? localization.collapseAll\n            : localization.expandAll, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.expandAll, disabled: isLoading || (!renderDetailPanel && !getCanSomeRowsExpand()), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, actionIconProps, { sx: (theme) => (Object.assign({ marginLeft: density === 'xl' ? '-6px' : density === 'md' ? '0' : '6px', opacity: 0.8, '&:disabled': {\n                    backgroundColor: 'transparent',\n                    border: 'none',\n                }, '&:hover': {\n                    opacity: 1,\n                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function\n                ? actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx(theme)\n                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronsDown, { style: {\n                    transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,\n                    transition: 'transform 100ms',\n                } })) })) }));\n};\n\nconst MRT_ExpandButton = ({ row, table, }) => {\n    var _a, _b;\n    const { options: { icons: { IconChevronDown }, localization, mantineExpandButtonProps, renderDetailPanel, }, } = table;\n    const actionIconProps = mantineExpandButtonProps instanceof Function\n        ? mantineExpandButtonProps({ table, row })\n        : mantineExpandButtonProps;\n    const canExpand = row.getCanExpand();\n    const isExpanded = row.getIsExpanded();\n    const handleToggleExpand = (event) => {\n        var _a;\n        event.stopPropagation();\n        row.toggleExpanded();\n        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);\n    };\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, disabled: !canExpand && !renderDetailPanel, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isExpanded)\n            ? localization.collapse\n            : localization.expand, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.expand, disabled: !canExpand && !renderDetailPanel }, actionIconProps, { onClick: handleToggleExpand, sx: (theme) => (Object.assign({ opacity: 0.8, '&:disabled': {\n                    backgroundColor: 'transparent',\n                    border: 'none',\n                }, '&:hover': {\n                    opacity: 1,\n                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function\n                ? actionIconProps.sx(theme)\n                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronDown, { style: {\n                    transform: `rotate(${!canExpand && !renderDetailPanel ? -90 : isExpanded ? -180 : 0}deg)`,\n                    transition: 'transform 100ms',\n                } })) })) }));\n};\n\nconst MRT_RowActionMenu = ({ handleEdit, row, table, }) => {\n    const { options: { editDisplayMode, enableEditing, icons: { IconEdit, IconDots }, localization, positionActionsColumn, renderRowActionMenuItems, }, } = table;\n    return (jsxRuntime.jsxs(core.Menu, { position: positionActionsColumn === 'first'\n            ? 'bottom-start'\n            : positionActionsColumn === 'last'\n                ? 'bottom-end'\n                : undefined, closeOnItemClick: true, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.rowActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.rowActions, onClick: (event) => event.stopPropagation(), size: \"sm\", children: jsxRuntime.jsx(IconDots, {}) }) }) }), jsxRuntime.jsxs(core.Menu.Dropdown, { onClick: (event) => event.stopPropagation(), children: [enableEditing && editDisplayMode !== 'table' && (jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconEdit, {}), onClick: handleEdit, children: localization.edit })), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({\n                        row,\n                        table,\n                    })] })] }));\n};\n\nconst MRT_EditActionButtons = ({ row, table, variant = 'icon', }) => {\n    const { getState, options: { icons: { IconCircleX, IconDeviceFloppy }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowSave, onEditingRowCancel, }, refs: { editInputRefs }, setCreatingRow, setEditingRow, } = table;\n    const { creatingRow, editingRow, isSaving } = getState();\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const handleCancel = () => {\n        if (isCreating) {\n            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });\n            setCreatingRow(null);\n        }\n        else if (isEditing) {\n            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });\n            setEditingRow(null);\n        }\n        row._valuesCache = {}; //reset values cache\n    };\n    const handleSubmitRow = () => {\n        var _a;\n        //look for auto-filled input values\n        (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)\n            .filter((inputRef) => { var _a, _b; return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]); })) === null || _a === void 0 ? void 0 : _a.forEach((input) => {\n            if (input.value !== undefined &&\n                Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {\n                // @ts-ignore\n                row._valuesCache[input.name] = input.value;\n            }\n        });\n        if (isCreating)\n            onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({\n                exitCreatingMode: () => setCreatingRow(null),\n                row,\n                table,\n                values: row._valuesCache,\n            });\n        else if (isEditing) {\n            onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({\n                exitEditingMode: () => setEditingRow(null),\n                row,\n                table,\n                values: row === null || row === void 0 ? void 0 : row._valuesCache,\n            });\n        }\n    };\n    return (jsxRuntime.jsx(core.Box, { onClick: (e) => e.stopPropagation(), sx: { display: 'flex', gap: '12px' }, children: variant === 'icon' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.cancel, children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.cancel, onClick: handleCancel, children: jsxRuntime.jsx(IconCircleX, {}) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.save, children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.save, color: \"blue\", onClick: handleSubmitRow, loading: isSaving, children: jsxRuntime.jsx(IconDeviceFloppy, {}) }) })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Button, { onClick: handleCancel, variant: \"subtle\", children: localization.cancel }), jsxRuntime.jsx(core.Button, { onClick: handleSubmitRow, variant: \"filled\", loading: isSaving, children: localization.save })] })) }));\n};\n\nconst MRT_ToggleRowActionMenuButton = ({ cell, row, table, }) => {\n    const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { IconEdit }, localization, renderRowActionMenuItems, renderRowActions, }, setEditingRow, } = table;\n    const { creatingRow, editingRow } = getState();\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const handleStartEditMode = (event) => {\n        event.stopPropagation();\n        setEditingRow(Object.assign({}, row));\n    };\n    const showEditActionButtons = (isCreating && createDisplayMode === 'row') ||\n        (isEditing && editDisplayMode === 'row');\n    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderRowActions && !showEditActionButtons ? (renderRowActions({ cell, row, table })) : showEditActionButtons ? (jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table })) : !renderRowActionMenuItems &&\n            (enableEditing instanceof Function\n                ? enableEditing(row)\n                : enableEditing) ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, position: \"right\", label: localization.edit, children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.edit, disabled: !!editingRow && editingRow.id !== row.id, onClick: handleStartEditMode, sx: {\n                    opacity: 0.8,\n                    '&:hover': {\n                        opacity: 1,\n                    },\n                    '&:disabled': {\n                        backgroundColor: 'transparent',\n                        border: 'none',\n                    },\n                }, children: jsxRuntime.jsx(IconEdit, {}) }) })) : renderRowActionMenuItems ? (jsxRuntime.jsx(MRT_RowActionMenu, { handleEdit: handleStartEditMode, row: row, table: table })) : null }));\n};\n\nconst MRT_SelectCheckbox = ({ row, selectAll, table, }) => {\n    var _a;\n    const { getState, options: { enableMultiRowSelection, localization, mantineSelectAllCheckboxProps, mantineSelectCheckboxProps, selectAllMode, selectDisplayMode, }, } = table;\n    const { density, isLoading } = getState();\n    const checkboxProps = !row\n        ? mantineSelectAllCheckboxProps instanceof Function\n            ? mantineSelectAllCheckboxProps({ table })\n            : mantineSelectAllCheckboxProps\n        : mantineSelectCheckboxProps instanceof Function\n            ? mantineSelectCheckboxProps({ row, table })\n            : mantineSelectCheckboxProps;\n    const allRowsSelected = selectAll\n        ? selectAllMode === 'page'\n            ? table.getIsAllPageRowsSelected()\n            : table.getIsAllRowsSelected()\n        : undefined;\n    const commonProps = Object.assign(Object.assign({ 'aria-label': selectAll\n            ? localization.toggleSelectAll\n            : localization.toggleSelectRow, checked: selectAll ? allRowsSelected : row === null || row === void 0 ? void 0 : row.getIsSelected(), disabled: isLoading || (row && !row.getCanSelect()), onChange: row\n            ? row.getToggleSelectedHandler()\n            : selectAllMode === 'all'\n                ? table.getToggleAllRowsSelectedHandler()\n                : table.getToggleAllPageRowsSelectedHandler(), size: density === 'xs' ? 'sm' : 'md' }, checkboxProps), { onClick: (e) => {\n            var _a;\n            e.stopPropagation();\n            (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n        }, title: undefined });\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _a !== void 0 ? _a : (selectAll\n            ? localization.toggleSelectAll\n            : localization.toggleSelectRow), children: jsxRuntime.jsx(\"span\", { children: selectDisplayMode === 'switch' ? (jsxRuntime.jsx(core.Switch, Object.assign({}, commonProps))) : selectDisplayMode === 'radio' ||\n                enableMultiRowSelection === false ? (jsxRuntime.jsx(core.Radio, Object.assign({}, commonProps))) : (jsxRuntime.jsx(core.Checkbox, Object.assign({ indeterminate: selectAll\n                    ? table.getIsSomeRowsSelected() && !allRowsSelected\n                    : row === null || row === void 0 ? void 0 : row.getIsSomeSelected() }, commonProps))) }) }));\n};\n\nconst useMRT_DisplayColumns = ({ creatingRow, columnOrder, grouping, tableOptions, }) => {\n    var _a, _b;\n    return react.useMemo(() => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n        return [\n            ((_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnOrder) !== null && _b !== void 0 ? _b : columnOrder).includes('mrt-row-drag') && Object.assign(Object.assign(Object.assign({ Cell: ({ row, rowRef, table }) => (jsxRuntime.jsx(MRT_TableBodyRowGrabHandle, { row: row, rowRef: rowRef, table: table })), header: tableOptions.localization.move, size: 60 }, tableOptions.defaultDisplayColumn), (_c = tableOptions.displayColumnDefOptions) === null || _c === void 0 ? void 0 : _c['mrt-row-drag']), { id: 'mrt-row-drag' }),\n            (((_e = (_d = tableOptions.state) === null || _d === void 0 ? void 0 : _d.columnOrder) !== null && _e !== void 0 ? _e : columnOrder).includes('mrt-row-actions') ||\n                (creatingRow && tableOptions.createDisplayMode === 'row')) && Object.assign(Object.assign(Object.assign({ Cell: ({ cell, row, table }) => (jsxRuntime.jsx(MRT_ToggleRowActionMenuButton, { cell: cell, row: row, table: table })), header: tableOptions.localization.actions, size: 70 }, tableOptions.defaultDisplayColumn), (_f = tableOptions.displayColumnDefOptions) === null || _f === void 0 ? void 0 : _f['mrt-row-actions']), { id: 'mrt-row-actions' }),\n            ((_h = (_g = tableOptions.state) === null || _g === void 0 ? void 0 : _g.columnOrder) !== null && _h !== void 0 ? _h : columnOrder).includes('mrt-row-expand') &&\n                showExpandColumn(tableOptions, (_k = (_j = tableOptions.state) === null || _j === void 0 ? void 0 : _j.grouping) !== null && _k !== void 0 ? _k : grouping) && Object.assign(Object.assign(Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_ExpandButton, { row: row, table: table })), Header: tableOptions.enableExpandAll\n                    ? ({ table }) => jsxRuntime.jsx(MRT_ExpandAllButton, { table: table })\n                    : null, header: tableOptions.localization.expand, size: 60 }, tableOptions.defaultDisplayColumn), (_l = tableOptions.displayColumnDefOptions) === null || _l === void 0 ? void 0 : _l['mrt-row-expand']), { id: 'mrt-row-expand' }),\n            ((_o = (_m = tableOptions.state) === null || _m === void 0 ? void 0 : _m.columnOrder) !== null && _o !== void 0 ? _o : columnOrder).includes('mrt-row-select') && Object.assign(Object.assign(Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_SelectCheckbox, { row: row, table: table })), Header: tableOptions.enableSelectAll &&\n                    tableOptions.enableMultiRowSelection\n                    ? ({ table }) => jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })\n                    : null, header: tableOptions.localization.select, size: 60 }, tableOptions.defaultDisplayColumn), (_p = tableOptions.displayColumnDefOptions) === null || _p === void 0 ? void 0 : _p['mrt-row-select']), { id: 'mrt-row-select' }),\n            ((_r = (_q = tableOptions.state) === null || _q === void 0 ? void 0 : _q.columnOrder) !== null && _r !== void 0 ? _r : columnOrder).includes('mrt-row-numbers') && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => row.index + 1, Header: () => tableOptions.localization.rowNumber, header: tableOptions.localization.rowNumbers, size: 60 }, tableOptions.defaultDisplayColumn), (_s = tableOptions.displayColumnDefOptions) === null || _s === void 0 ? void 0 : _s['mrt-row-numbers']), { id: 'mrt-row-numbers' }),\n        ].filter(Boolean);\n    }, [\n        columnOrder,\n        grouping,\n        tableOptions.displayColumnDefOptions,\n        tableOptions.editDisplayMode,\n        tableOptions.enableColumnDragging,\n        tableOptions.enableColumnFilterModes,\n        tableOptions.enableColumnOrdering,\n        tableOptions.enableEditing,\n        tableOptions.enableExpandAll,\n        tableOptions.enableExpanding,\n        tableOptions.enableGrouping,\n        tableOptions.enableRowActions,\n        tableOptions.enableRowDragging,\n        tableOptions.enableRowNumbers,\n        tableOptions.enableRowOrdering,\n        tableOptions.enableRowSelection,\n        tableOptions.enableSelectAll,\n        tableOptions.localization,\n        tableOptions.positionActionsColumn,\n        tableOptions.renderDetailPanel,\n        tableOptions.renderRowActionMenuItems,\n        tableOptions.renderRowActions,\n        (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnOrder,\n        (_b = tableOptions.state) === null || _b === void 0 ? void 0 : _b.grouping,\n    ]);\n};\n\nconst useMRT_Effects = (table) => {\n    const { getState, options: { enablePagination, rowCount }, } = table;\n    const { globalFilter, isFullScreen, pagination, sorting, isLoading, showSkeletons, } = getState();\n    const isMounted = react.useRef(false);\n    const initialBodyHeight = react.useRef();\n    const previousTop = react.useRef();\n    react.useEffect(() => {\n        if (typeof window !== 'undefined') {\n            initialBodyHeight.current = document.body.style.height;\n        }\n    }, []);\n    react.useEffect(() => {\n        if (isMounted && typeof window !== 'undefined') {\n            if (isFullScreen) {\n                previousTop.current = document.body.getBoundingClientRect().top; //save scroll position\n                document.body.style.height = '100vh'; //hide page scrollbars when table is in full screen mode\n            }\n            else {\n                document.body.style.height = initialBodyHeight.current;\n                if (!previousTop.current)\n                    return;\n                //restore scroll position\n                window.scrollTo({\n                    top: -1 * previousTop.current,\n                    behavior: 'instant',\n                });\n            }\n        }\n        isMounted.current = true;\n    }, [isFullScreen]);\n    //if page index is out of bounds, set it to the last page\n    react.useEffect(() => {\n        if (!enablePagination || isLoading || showSkeletons)\n            return;\n        const { pageIndex, pageSize } = pagination;\n        const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : table.getPrePaginationRowModel().rows.length;\n        const firstVisibleRowIndex = pageIndex * pageSize;\n        if (firstVisibleRowIndex > totalRowCount) {\n            table.setPageIndex(Math.floor(totalRowCount / pageSize));\n        }\n    }, [rowCount, table.getPrePaginationRowModel().rows.length]);\n    //turn off sort when global filter is looking for ranked results\n    const appliedSort = react.useRef(sorting);\n    react.useEffect(() => {\n        if (sorting.length) {\n            appliedSort.current = sorting;\n        }\n    }, [sorting]);\n    react.useEffect(() => {\n        if (!getCanRankRows(table))\n            return;\n        if (globalFilter) {\n            table.setSorting([]);\n        }\n        else {\n            table.setSorting(() => appliedSort.current || []);\n        }\n    }, [globalFilter]);\n};\n\nconst useMRT_TableInstance = (tableOptions) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;\n    const bottomToolbarRef = react.useRef(null);\n    const editInputRefs = react.useRef({});\n    const filterInputRefs = react.useRef({});\n    const searchInputRef = react.useRef(null);\n    const tableContainerRef = react.useRef(null);\n    const tableHeadCellRefs = react.useRef({});\n    const tablePaperRef = react.useRef(null);\n    const topToolbarRef = react.useRef(null);\n    const initialState = react.useMemo(() => {\n        var _a, _b, _c;\n        const initState = (_a = tableOptions.initialState) !== null && _a !== void 0 ? _a : {};\n        initState.columnOrder =\n            (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(tableOptions);\n        initState.globalFilterFn = (_c = tableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';\n        return initState;\n    }, []);\n    const [creatingRow, _setCreatingRow] = react.useState((_a = initialState.creatingRow) !== null && _a !== void 0 ? _a : null);\n    const [columnFilterFns, setColumnFilterFns] = react.useState(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => {\n        var _a, _b, _c, _d;\n        return ({\n            [getColumnId(col)]: col.filterFn instanceof Function\n                ? (_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom'\n                : (_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col),\n        });\n    })));\n    const [columnOrder, setColumnOrder] = react.useState((_b = initialState.columnOrder) !== null && _b !== void 0 ? _b : []);\n    const [density, setDensity] = react.useState((_c = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _c !== void 0 ? _c : 'md');\n    const [draggingColumn, setDraggingColumn] = react.useState((_d = initialState.draggingColumn) !== null && _d !== void 0 ? _d : null);\n    const [draggingRow, setDraggingRow] = react.useState((_e = initialState.draggingRow) !== null && _e !== void 0 ? _e : null);\n    const [editingCell, setEditingCell] = react.useState((_f = initialState.editingCell) !== null && _f !== void 0 ? _f : null);\n    const [editingRow, setEditingRow] = react.useState((_g = initialState.editingRow) !== null && _g !== void 0 ? _g : null);\n    const [globalFilterFn, setGlobalFilterFn] = react.useState((_h = initialState.globalFilterFn) !== null && _h !== void 0 ? _h : 'fuzzy');\n    const [grouping, setGrouping] = react.useState((_j = initialState.grouping) !== null && _j !== void 0 ? _j : []);\n    const [hoveredColumn, setHoveredColumn] = react.useState((_k = initialState.hoveredColumn) !== null && _k !== void 0 ? _k : null);\n    const [hoveredRow, setHoveredRow] = react.useState((_l = initialState.hoveredRow) !== null && _l !== void 0 ? _l : null);\n    const [isFullScreen, setIsFullScreen] = react.useState((_m = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _m !== void 0 ? _m : false);\n    const [showAlertBanner, setShowAlertBanner] = react.useState((_p = (_o = tableOptions.initialState) === null || _o === void 0 ? void 0 : _o.showAlertBanner) !== null && _p !== void 0 ? _p : false);\n    const [showColumnFilters, setShowColumnFilters] = react.useState((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _q !== void 0 ? _q : false);\n    const [showGlobalFilter, setShowGlobalFilter] = react.useState((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _r !== void 0 ? _r : false);\n    const [showToolbarDropZone, setShowToolbarDropZone] = react.useState((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _s !== void 0 ? _s : false);\n    const displayColumns = useMRT_DisplayColumns({\n        columnOrder,\n        creatingRow,\n        grouping,\n        tableOptions,\n    });\n    const columnDefs = react.useMemo(() => {\n        var _a, _b, _c;\n        return prepareColumns({\n            aggregationFns: tableOptions.aggregationFns,\n            columnDefs: [...displayColumns, ...tableOptions.columns],\n            columnFilterFns: (_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnFilterFns) !== null && _b !== void 0 ? _b : columnFilterFns,\n            defaultDisplayColumn: (_c = tableOptions.defaultDisplayColumn) !== null && _c !== void 0 ? _c : {},\n            filterFns: tableOptions.filterFns,\n            sortingFns: tableOptions.sortingFns,\n        });\n    }, [\n        columnFilterFns,\n        displayColumns,\n        tableOptions.columns,\n        (_t = tableOptions.state) === null || _t === void 0 ? void 0 : _t.columnFilterFns,\n    ]);\n    const data = react.useMemo(() => {\n        var _a, _b, _c, _d, _e;\n        return (((_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.isLoading) || ((_b = tableOptions.state) === null || _b === void 0 ? void 0 : _b.showSkeletons)) &&\n            !tableOptions.data.length\n            ? [\n                ...Array(((_d = (_c = tableOptions.state) === null || _c === void 0 ? void 0 : _c.pagination) === null || _d === void 0 ? void 0 : _d.pageSize) ||\n                    ((_e = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) === null || _e === void 0 ? void 0 : _e.pageSize) ||\n                    10).fill(null),\n            ].map(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => ({\n                [getColumnId(col)]: null,\n            }))))\n            : tableOptions.data;\n    }, [\n        tableOptions.data,\n        (_u = tableOptions.state) === null || _u === void 0 ? void 0 : _u.isLoading,\n        (_v = tableOptions.state) === null || _v === void 0 ? void 0 : _v.showSkeletons,\n    ]);\n    //@ts-ignore\n    const table = reactTable.useReactTable(Object.assign(Object.assign({ getCoreRowModel: reactTable.getCoreRowModel(), getExpandedRowModel: tableOptions.enableExpanding || tableOptions.enableGrouping\n            ? reactTable.getExpandedRowModel()\n            : undefined, getFacetedMinMaxValues: tableOptions.enableFacetedValues\n            ? reactTable.getFacetedMinMaxValues()\n            : undefined, getFacetedRowModel: tableOptions.enableFacetedValues\n            ? reactTable.getFacetedRowModel()\n            : undefined, getFacetedUniqueValues: tableOptions.enableFacetedValues\n            ? reactTable.getFacetedUniqueValues()\n            : undefined, getFilteredRowModel: tableOptions.enableColumnFilters ||\n            tableOptions.enableGlobalFilter ||\n            tableOptions.enableFilters\n            ? reactTable.getFilteredRowModel()\n            : undefined, getGroupedRowModel: tableOptions.enableGrouping\n            ? reactTable.getGroupedRowModel()\n            : undefined, getPaginationRowModel: tableOptions.enablePagination\n            ? reactTable.getPaginationRowModel()\n            : undefined, getSortedRowModel: tableOptions.enableSorting\n            ? reactTable.getSortedRowModel()\n            : undefined, onColumnOrderChange: setColumnOrder, onGroupingChange: setGrouping, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows }, tableOptions), { \n        //@ts-ignore\n        columns: columnDefs, data, globalFilterFn: (_w = tableOptions.filterFns) === null || _w === void 0 ? void 0 : _w[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy'], initialState, state: Object.assign({ creatingRow,\n            columnFilterFns,\n            columnOrder,\n            density,\n            draggingColumn,\n            draggingRow,\n            editingCell,\n            editingRow,\n            globalFilterFn,\n            grouping,\n            hoveredColumn,\n            hoveredRow,\n            isFullScreen,\n            showAlertBanner,\n            showColumnFilters,\n            showGlobalFilter,\n            showToolbarDropZone }, tableOptions.state) }));\n    // @ts-ignore\n    table.refs = {\n        // @ts-ignore\n        bottomToolbarRef,\n        editInputRefs,\n        filterInputRefs,\n        // @ts-ignore\n        searchInputRef,\n        // @ts-ignore\n        tableContainerRef,\n        tableHeadCellRefs,\n        // @ts-ignore\n        tablePaperRef,\n        // @ts-ignore\n        topToolbarRef,\n    };\n    const setCreatingRow = (row) => {\n        var _a, _b;\n        let _row = row;\n        if (row === true) {\n            _row = createRow(table);\n        }\n        (_b = (_a = tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(tableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);\n    };\n    table.setCreatingRow = setCreatingRow;\n    table.setColumnFilterFns =\n        (_x = tableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;\n    table.setDensity = (_y = tableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;\n    table.setDraggingColumn =\n        (_z = tableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;\n    table.setDraggingRow = (_0 = tableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;\n    table.setEditingCell = (_1 = tableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;\n    table.setEditingRow = (_2 = tableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;\n    table.setGlobalFilterFn =\n        (_3 = tableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;\n    table.setHoveredColumn =\n        (_4 = tableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;\n    table.setHoveredRow = (_5 = tableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;\n    table.setIsFullScreen = (_6 = tableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;\n    table.setShowAlertBanner =\n        (_7 = tableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;\n    table.setShowColumnFilters =\n        (_8 = tableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;\n    table.setShowGlobalFilter =\n        (_9 = tableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;\n    table.setShowToolbarDropZone =\n        (_10 = tableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;\n    useMRT_Effects(table);\n    return table;\n};\n\nconst useMantineReactTable = (tableOptions) => {\n    const parsedTableOptions = useMRT_TableOptions(tableOptions);\n    const tableInstance = useMRT_TableInstance(parsedTableOptions);\n    return tableInstance;\n};\n\nconst mrtFilterOptions = (localization) => [\n    {\n        option: 'fuzzy',\n        symbol: '≈',\n        label: localization.filterFuzzy,\n        divider: false,\n    },\n    {\n        option: 'contains',\n        symbol: '*',\n        label: localization.filterContains,\n        divider: false,\n    },\n    {\n        option: 'startsWith',\n        symbol: 'a',\n        label: localization.filterStartsWith,\n        divider: false,\n    },\n    {\n        option: 'endsWith',\n        symbol: 'z',\n        label: localization.filterEndsWith,\n        divider: true,\n    },\n    {\n        option: 'equals',\n        symbol: '=',\n        label: localization.filterEquals,\n        divider: false,\n    },\n    {\n        option: 'notEquals',\n        symbol: '≠',\n        label: localization.filterNotEquals,\n        divider: true,\n    },\n    {\n        option: 'between',\n        symbol: '⇿',\n        label: localization.filterBetween,\n        divider: false,\n    },\n    {\n        option: 'betweenInclusive',\n        symbol: '⬌',\n        label: localization.filterBetweenInclusive,\n        divider: true,\n    },\n    {\n        option: 'greaterThan',\n        symbol: '>',\n        label: localization.filterGreaterThan,\n        divider: false,\n    },\n    {\n        option: 'greaterThanOrEqualTo',\n        symbol: '≥',\n        label: localization.filterGreaterThanOrEqualTo,\n        divider: false,\n    },\n    {\n        option: 'lessThan',\n        symbol: '<',\n        label: localization.filterLessThan,\n        divider: false,\n    },\n    {\n        option: 'lessThanOrEqualTo',\n        symbol: '≤',\n        label: localization.filterLessThanOrEqualTo,\n        divider: true,\n    },\n    {\n        option: 'empty',\n        symbol: '∅',\n        label: localization.filterEmpty,\n        divider: false,\n    },\n    {\n        option: 'notEmpty',\n        symbol: '!∅',\n        label: localization.filterNotEmpty,\n        divider: false,\n    },\n];\nconst rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];\nconst emptyModes = ['empty', 'notEmpty'];\nconst arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];\nconst rangeVariants = ['range-slider', 'date-range', 'range'];\nconst MRT_FilterOptionMenu = ({ header, onSelect, table, }) => {\n    var _a, _b, _c, _d;\n    const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems, }, setColumnFilterFns, setGlobalFilterFn, } = table;\n    const { globalFilterFn } = getState();\n    const { column } = header !== null && header !== void 0 ? header : {};\n    const { columnDef } = column !== null && column !== void 0 ? column : {};\n    const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();\n    let allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;\n    if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {\n        allowedColumnFilterOptions = [\n            ...rangeModes,\n            ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []),\n        ].filter((option) => rangeModes.includes(option));\n    }\n    const internalFilterOptions = react.useMemo(() => mrtFilterOptions(localization).filter((filterOption) => columnDef\n        ? allowedColumnFilterOptions === undefined ||\n            (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option))\n        : (!globalFilterModeOptions ||\n            globalFilterModeOptions.includes(filterOption.option)) &&\n            ['fuzzy', 'contains', 'startsWith'].includes(filterOption.option)), []);\n    const handleSelectFilterMode = (option) => {\n        var _a;\n        const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';\n        if (!header || !column) {\n            // global filter mode\n            setGlobalFilterFn(option);\n        }\n        else if (option !== prevFilterMode) {\n            // column filter mode\n            setColumnFilterFns((prev) => (Object.assign(Object.assign({}, prev), { [header.id]: option })));\n            // reset filter value and/or perform new filter render\n            if (emptyModes.includes(option)) {\n                // will now be empty/notEmpty filter mode\n                if (currentFilterValue !== ' ' &&\n                    !emptyModes.includes(prevFilterMode)) {\n                    column.setFilterValue(' ');\n                }\n                else if (currentFilterValue) {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' ||\n                arrModes.includes(option)) {\n                // will now be array filter mode\n                if (currentFilterValue instanceof String ||\n                    (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {\n                    column.setFilterValue([]);\n                }\n                else if (currentFilterValue) {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) ||\n                rangeModes.includes(option)) {\n                // will now be range filter mode\n                if (!Array.isArray(currentFilterValue) ||\n                    (!(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === '')) &&\n                        !rangeModes.includes(prevFilterMode))) {\n                    column.setFilterValue(['', '']);\n                }\n                else {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else {\n                // will now be single value filter mode\n                if (Array.isArray(currentFilterValue)) {\n                    column.setFilterValue('');\n                }\n                else {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n        }\n        onSelect === null || onSelect === void 0 ? void 0 : onSelect();\n    };\n    const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;\n    return (jsxRuntime.jsx(core.Menu.Dropdown, { children: (_d = (header && column && columnDef\n            ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {\n                column: column,\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({\n                column: column,\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            })\n            : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            }))) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ option, label, divider, symbol }, index) => (jsxRuntime.jsxs(react.Fragment, { children: [jsxRuntime.jsxs(core.Menu.Item, { onClick: () => handleSelectFilterMode(option), color: option === filterOption ? 'blue' : undefined, sx: {\n                        '& > .mantine-Menu-itemLabel': {\n                            display: 'flex',\n                            flexWrap: 'nowrap',\n                            gap: '1ch',\n                        },\n                    }, value: option, children: [jsxRuntime.jsx(core.Flex, { sx: {\n                                fontSize: '20px',\n                                transform: 'translateY(-2px)',\n                                width: '2ch',\n                            }, children: symbol }), jsxRuntime.jsx(core.Flex, { align: \"center\", children: label })] }), divider && jsxRuntime.jsx(core.Menu.Divider, {})] }, index))) }));\n};\n\nconst MRT_GlobalFilterTextInput = ({ table, }) => {\n    const { getState, setGlobalFilter, options: { enableGlobalFilterModes, icons: { IconSearch, IconX }, localization, manualFiltering, mantineSearchTextInputProps, }, refs: { searchInputRef }, } = table;\n    const { globalFilter, showGlobalFilter } = getState();\n    const textFieldProps = mantineSearchTextInputProps instanceof Function\n        ? mantineSearchTextInputProps({ table })\n        : mantineSearchTextInputProps;\n    const isMounted = react.useRef(false);\n    const [searchValue, setSearchValue] = react.useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');\n    const [debouncedSearchValue] = hooks.useDebouncedValue(searchValue, manualFiltering ? 500 : 250);\n    react.useEffect(() => {\n        setGlobalFilter(debouncedSearchValue || undefined);\n    }, [debouncedSearchValue]);\n    const handleClear = () => {\n        setSearchValue('');\n        setGlobalFilter(undefined);\n    };\n    react.useEffect(() => {\n        if (isMounted.current) {\n            if (globalFilter === undefined) {\n                handleClear();\n            }\n            else {\n                setSearchValue(globalFilter);\n            }\n        }\n        isMounted.current = true;\n    }, [globalFilter]);\n    return (jsxRuntime.jsxs(core.Collapse, { in: showGlobalFilter, sx: {\n            '& > div': {\n                display: 'flex',\n                alignItems: 'center',\n                gap: '16px',\n                flexWrap: 'nowrap',\n            },\n        }, children: [enableGlobalFilterModes && (jsxRuntime.jsxs(core.Menu, { withinPortal: true, children: [jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.changeSearchMode, size: \"sm\", children: jsxRuntime.jsx(IconSearch, {}) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { table: table, onSelect: handleClear })] })), jsxRuntime.jsx(core.TextInput, Object.assign({ placeholder: localization.search, onChange: (event) => setSearchValue(event.target.value), value: searchValue !== null && searchValue !== void 0 ? searchValue : '', variant: \"filled\", icon: !enableGlobalFilterModes && jsxRuntime.jsx(IconSearch, {}), rightSection: searchValue ? (jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: \"sm\", children: jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.clearSearch, children: jsxRuntime.jsx(IconX, {}) }) })) : null }, textFieldProps, { ref: (node) => {\n                    if (node) {\n                        searchInputRef.current = node;\n                        if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.ref) {\n                            // @ts-ignore\n                            textFieldProps.ref = node;\n                        }\n                    }\n                }, sx: (theme) => (Object.assign({ minWidth: '250px' }, ((textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx) instanceof Function\n                    ? textFieldProps.sx(theme)\n                    : textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx))) }))] }));\n};\n\nconst MRT_ProgressBar = ({ isTopToolbar, table, }) => {\n    const { options: { mantineProgressProps }, getState, } = table;\n    const { isSaving, showProgressBars } = getState();\n    const linearProgressProps = mantineProgressProps instanceof Function\n        ? mantineProgressProps({ isTopToolbar, table })\n        : mantineProgressProps;\n    return (jsxRuntime.jsx(core.Collapse, { in: isSaving || showProgressBars, sx: {\n            bottom: isTopToolbar ? 0 : undefined,\n            position: 'absolute',\n            top: !isTopToolbar ? 0 : undefined,\n            width: '100%',\n        }, children: jsxRuntime.jsx(core.Progress, Object.assign({ animate: true, \"aria-busy\": \"true\", \"aria-label\": \"Loading\", radius: 0, value: 100 }, linearProgressProps)) }));\n};\n\nconst commonActionButtonStyles = {\n    userSelect: 'none',\n    '&:disabled': {\n        backgroundColor: 'transparent',\n        border: 'none',\n    },\n};\nconst MRT_TablePagination = ({ table, position = 'bottom', }) => {\n    var _a;\n    const { getPrePaginationRowModel, getState, setPageIndex, setPageSize, options: { enableToolbarInternalActions, icons: { IconChevronLeftPipe, IconChevronRightPipe, IconChevronLeft, IconChevronRight, }, localization, mantinePaginationProps, paginationDisplayMode, rowCount, }, } = table;\n    const { pagination: { pageSize = 10, pageIndex = 0 }, showGlobalFilter, } = getState();\n    const paginationProps = mantinePaginationProps instanceof Function\n        ? mantinePaginationProps({ table })\n        : mantinePaginationProps;\n    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;\n    const numberOfPages = Math.ceil(totalRowCount / pageSize);\n    const showFirstLastPageButtons = numberOfPages > 2 && (paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.withEdges) !== false;\n    const firstRowIndex = pageIndex * pageSize;\n    const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);\n    return (jsxRuntime.jsxs(core.Flex, { align: \"center\", justify: \"space-between\", gap: \"lg\", py: \"xs\", px: \"sm\", mt: position === 'top' && enableToolbarInternalActions && !showGlobalFilter\n            ? '3rem'\n            : undefined, p: \"relative\", sx: { zIndex: 2 }, children: [(paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.showRowsPerPage) !== false && (jsxRuntime.jsx(core.Select, { data: (_a = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.rowsPerPageOptions) !== null && _a !== void 0 ? _a : [\n                    '5',\n                    '10',\n                    '15',\n                    '20',\n                    '25',\n                    '30',\n                    '50',\n                    '100',\n                ], label: localization.rowsPerPage, onChange: (value) => setPageSize(+value), value: pageSize.toString(), sx: {\n                    '@media (min-width: 720px)': {\n                        display: 'flex',\n                        alignItems: 'center',\n                        gap: '8px',\n                    },\n                    '& .mantine-Select-input': {\n                        width: '80px',\n                    },\n                }, withinPortal: true })), paginationDisplayMode === 'pages' ? (jsxRuntime.jsx(core.Pagination, Object.assign({ onChange: (newPageIndex) => setPageIndex(newPageIndex - 1), total: numberOfPages, value: pageIndex + 1, withEdges: showFirstLastPageButtons, nextIcon: IconChevronRight, previousIcon: IconChevronLeft, firstIcon: IconChevronLeftPipe, lastIcon: IconChevronRightPipe }, paginationProps))) : paginationDisplayMode === 'default' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Text, { children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), jsxRuntime.jsxs(core.Flex, { gap: \"xs\", children: [showFirstLastPageButtons && (jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.goToFirstPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(0), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronLeftPipe, {}) })), jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.goToPreviousPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(pageIndex - 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronLeft, {}) }), jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.goToNextPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(pageIndex + 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronRight, {}) }), showFirstLastPageButtons && (jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.goToLastPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(numberOfPages - 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronRightPipe, {}) }))] })] })) : null] }));\n};\n\nconst MRT_FilterCheckbox = ({ column, table, }) => {\n    var _a, _b, _c;\n    const { getState, options: { localization, mantineFilterCheckboxProps }, } = table;\n    const { density } = getState();\n    const { columnDef } = column;\n    const mTableHeadCellFilterCheckboxProps = mantineFilterCheckboxProps instanceof Function\n        ? mantineFilterCheckboxProps({\n            column,\n            table,\n        })\n        : mantineFilterCheckboxProps;\n    const mcTableHeadCellFilterCheckboxProps = columnDef.mantineFilterCheckboxProps instanceof Function\n        ? columnDef.mantineFilterCheckboxProps({\n            column,\n            table,\n        })\n        : columnDef.mantineFilterCheckboxProps;\n    const checkboxProps = Object.assign(Object.assign({}, mTableHeadCellFilterCheckboxProps), mcTableHeadCellFilterCheckboxProps);\n    const filterLabel = (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', columnDef.header);\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : filterLabel, children: jsxRuntime.jsx(core.Checkbox, Object.assign({ checked: column.getFilterValue() === 'true', indeterminate: column.getFilterValue() === undefined, color: column.getFilterValue() === undefined ? 'default' : 'primary', size: density === 'xs' ? 'sm' : 'md', label: (_c = checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel }, checkboxProps, { onClick: (e) => {\n                var _a;\n                e.stopPropagation();\n                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n            }, onChange: (e) => {\n                var _a;\n                column.setFilterValue(column.getFilterValue() === undefined\n                    ? 'true'\n                    : column.getFilterValue() === 'true'\n                        ? 'false'\n                        : undefined);\n                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n            }, sx: (theme) => (Object.assign({ fontWeight: 'normal', marginTop: '8px' }, ((checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function\n                ? checkboxProps.sx(theme)\n                : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx))), title: undefined })) }));\n};\n\nconst MRT_FilterTextInput = ({ header, rangeFilterIndex, table, }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const { options: { columnFilterDisplayMode, columnFilterModeOptions, icons: { IconX }, localization, mantineFilterAutocompleteProps, mantineFilterDateInputProps, mantineFilterMultiSelectProps, mantineFilterSelectProps, mantineFilterTextInputProps, manualFiltering, }, refs: { filterInputRefs }, setColumnFilterFns, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const mFilterTextInputProps = mantineFilterTextInputProps instanceof Function\n        ? mantineFilterTextInputProps({\n            column,\n            table,\n            rangeFilterIndex,\n        })\n        : mantineFilterTextInputProps;\n    const mcFilterTextInputProps = columnDef.mantineFilterTextInputProps instanceof Function\n        ? columnDef.mantineFilterTextInputProps({\n            column,\n            table,\n            rangeFilterIndex,\n        })\n        : columnDef.mantineFilterTextInputProps;\n    const textInputProps = Object.assign(Object.assign({}, mFilterTextInputProps), mcFilterTextInputProps);\n    const mSelectProps = mantineFilterSelectProps instanceof Function\n        ? mantineFilterSelectProps({ column, table, rangeFilterIndex })\n        : mantineFilterSelectProps;\n    const mcSelectProps = columnDef.mantineFilterSelectProps instanceof Function\n        ? columnDef.mantineFilterSelectProps({ column, table, rangeFilterIndex })\n        : columnDef.mantineFilterSelectProps;\n    const selectProps = Object.assign(Object.assign({}, mSelectProps), mcSelectProps);\n    const mMultiSelectProps = mantineFilterMultiSelectProps instanceof Function\n        ? mantineFilterMultiSelectProps({ column, table, rangeFilterIndex })\n        : mantineFilterMultiSelectProps;\n    const mcMultiSelectProps = columnDef.mantineFilterMultiSelectProps instanceof Function\n        ? columnDef.mantineFilterMultiSelectProps({\n            column,\n            table,\n            rangeFilterIndex,\n        })\n        : columnDef.mantineFilterMultiSelectProps;\n    const multiSelectProps = Object.assign(Object.assign({}, mMultiSelectProps), mcMultiSelectProps);\n    const mDateInputProps = mantineFilterDateInputProps instanceof Function\n        ? mantineFilterDateInputProps({ column, table, rangeFilterIndex })\n        : mantineFilterDateInputProps;\n    const mcDateInputProps = columnDef.mantineFilterDateInputProps instanceof Function\n        ? columnDef.mantineFilterDateInputProps({\n            column,\n            table,\n            rangeFilterIndex,\n        })\n        : columnDef.mantineFilterDateInputProps;\n    const dateInputProps = Object.assign(Object.assign({}, mDateInputProps), mcDateInputProps);\n    const mAutoCompleteProps = mantineFilterAutocompleteProps instanceof Function\n        ? mantineFilterAutocompleteProps({ column, table, rangeFilterIndex })\n        : mantineFilterAutocompleteProps;\n    const mcAutoCompleteProps = columnDef.mantineFilterAutocompleteProps instanceof Function\n        ? columnDef.mantineFilterAutocompleteProps({\n            column,\n            table,\n            rangeFilterIndex,\n        })\n        : columnDef.mantineFilterAutocompleteProps;\n    const autoCompleteProps = Object.assign(Object.assign({}, mAutoCompleteProps), mcAutoCompleteProps);\n    const isRangeFilter = columnDef.filterVariant === 'range' ||\n        columnDef.filterVariant === 'date-range' ||\n        rangeFilterIndex !== undefined;\n    const isSelectFilter = columnDef.filterVariant === 'select';\n    const isMultiSelectFilter = columnDef.filterVariant === 'multi-select';\n    const isDateFilter = columnDef.filterVariant === 'date' ||\n        columnDef.filterVariant === 'date-range';\n    const isAutoCompleteFilter = columnDef.filterVariant === 'autocomplete';\n    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;\n    const currentFilterOption = columnDef._filterFn;\n    const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption)\n        ? //@ts-ignore\n            localization[`filter${((_c = (_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b === void 0 ? void 0 : _b.call(currentFilterOption, 0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +\n                (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]\n        : '';\n    const filterPlaceholder = !isRangeFilter\n        ? (_d = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.placeholder) !== null && _d !== void 0 ? _d : (_e = localization.filterByColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header))\n        : rangeFilterIndex === 0\n            ? localization.min\n            : rangeFilterIndex === 1\n                ? localization.max\n                : '';\n    const facetedUniqueValues = column.getFacetedUniqueValues();\n    const filterSelectOptions = react.useMemo(() => {\n        var _a, _b, _c;\n        return ((_c = (_b = (_a = autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data) !== null && _a !== void 0 ? _a : selectProps === null || selectProps === void 0 ? void 0 : selectProps.data) !== null && _b !== void 0 ? _b : multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data) !== null && _c !== void 0 ? _c : ((isAutoCompleteFilter || isSelectFilter || isMultiSelectFilter) &&\n            facetedUniqueValues\n            ? Array.from(facetedUniqueValues.keys()).sort((a, b) => a.localeCompare(b))\n            : []))\n            //@ts-ignore\n            .filter((o) => o !== undefined && o !== null);\n    }, [\n        autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data,\n        facetedUniqueValues,\n        isAutoCompleteFilter,\n        isMultiSelectFilter,\n        isSelectFilter,\n        multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data,\n        selectProps === null || selectProps === void 0 ? void 0 : selectProps.data,\n    ]);\n    const isMounted = react.useRef(false);\n    const [filterValue, setFilterValue] = react.useState(() => {\n        var _a, _b;\n        return isMultiSelectFilter\n            ? column.getFilterValue() || []\n            : isRangeFilter\n                ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || ''\n                : (_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '';\n    });\n    const [debouncedFilterValue] = hooks.useDebouncedValue(filterValue, manualFiltering ? 400 : 200);\n    //send debounced filterValue to table instance\n    react.useEffect(() => {\n        if (!isMounted.current)\n            return;\n        if (isRangeFilter) {\n            column.setFilterValue((old) => {\n                const newFilterValues = Array.isArray(old) ? old : ['', ''];\n                newFilterValues[rangeFilterIndex] =\n                    debouncedFilterValue;\n                return newFilterValues;\n            });\n        }\n        else {\n            column.setFilterValue(debouncedFilterValue !== null && debouncedFilterValue !== void 0 ? debouncedFilterValue : undefined);\n        }\n    }, [debouncedFilterValue]);\n    //receive table filter value and set it to local state\n    react.useEffect(() => {\n        if (!isMounted.current) {\n            isMounted.current = true;\n            return;\n        }\n        const tableFilterValue = column.getFilterValue();\n        if (tableFilterValue === undefined) {\n            handleClear();\n        }\n        else if (isRangeFilter && rangeFilterIndex !== undefined) {\n            setFilterValue((tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : ['', ''])[rangeFilterIndex]);\n        }\n        else {\n            setFilterValue(tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : '');\n        }\n    }, [column.getFilterValue()]);\n    const handleClear = () => {\n        if (isMultiSelectFilter) {\n            setFilterValue([]);\n            column.setFilterValue([]);\n        }\n        else if (isRangeFilter) {\n            setFilterValue('');\n            column.setFilterValue((old) => {\n                const newFilterValues = Array.isArray(old) ? old : ['', ''];\n                newFilterValues[rangeFilterIndex] = undefined;\n                return newFilterValues;\n            });\n        }\n        else {\n            setFilterValue('');\n            column.setFilterValue(undefined);\n        }\n    };\n    if (columnDef.Filter) {\n        return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (_f = columnDef.Filter) === null || _f === void 0 ? void 0 : _f.call(columnDef, { column, header, rangeFilterIndex, table }) }));\n    }\n    const handleClearEmptyFilterChip = () => {\n        setFilterValue('');\n        column.setFilterValue(undefined);\n        setColumnFilterFns((prev) => {\n            var _a;\n            return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));\n        });\n    };\n    const commonProps = {\n        disabled: !!filterChipLabel,\n        placeholder: filterPlaceholder,\n        title: filterPlaceholder,\n        onClick: (event) => event.stopPropagation(),\n        onChange: setFilterValue,\n        value: filterValue,\n        variant: 'unstyled',\n        sx: (theme) => (Object.assign({ borderBottom: `2px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 7 : 3]}`, minWidth: isDateFilter\n                ? '125px'\n                : isRangeFilter\n                    ? '80px'\n                    : !filterChipLabel\n                        ? '100px'\n                        : 'auto', width: '100%', '& .mantine-TextInput-input': {\n                overflow: 'hidden',\n                textOverflow: 'ellipsis',\n            }, '& .mantine-DateInput-input': {\n                height: '2.1rem',\n            } }, core.packSx(isMultiSelectFilter\n            ? multiSelectProps.sx\n            : isSelectFilter\n                ? selectProps.sx\n                : isDateFilter\n                    ? dateInputProps.sx\n                    : textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.sx))),\n    };\n    const ClearButton = filterValue ? (jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.clearFilter, onClick: handleClear, size: \"sm\", title: (_g = localization.clearFilter) !== null && _g !== void 0 ? _g : '', children: jsxRuntime.jsx(IconX, {}) })) : null;\n    return filterChipLabel ? (jsxRuntime.jsx(core.Box, { sx: commonProps.sx, children: jsxRuntime.jsx(core.Badge, { size: \"lg\", onClick: handleClearEmptyFilterChip, sx: { margin: '5px' }, rightSection: ClearButton, children: filterChipLabel }) })) : isMultiSelectFilter ? (jsxRuntime.jsx(core.MultiSelect, Object.assign({}, commonProps, { clearable: true, searchable: true, withinPortal: true }, multiSelectProps, { data: filterSelectOptions, ref: (node) => {\n            if (node) {\n                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                    node;\n                if (multiSelectProps.ref) {\n                    multiSelectProps.ref.current = node;\n                }\n            }\n        }, sx: commonProps.sx }))) : isSelectFilter ? (jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { clearable: true, searchable: true, withinPortal: true }, selectProps, { data: filterSelectOptions, ref: (node) => {\n            if (node) {\n                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                    node;\n                if (selectProps.ref) {\n                    selectProps.ref.current = node;\n                }\n            }\n        }, sx: commonProps.sx }))) : isDateFilter ? (jsxRuntime.jsx(dates.DateInput, Object.assign({}, commonProps, { allowDeselect: true, clearable: true, popoverProps: { withinPortal: columnFilterDisplayMode !== 'popover' } }, dateInputProps, { ref: (node) => {\n            if (node) {\n                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                    node;\n                if (dateInputProps.ref) {\n                    dateInputProps.ref.current = node;\n                }\n            }\n        }, sx: commonProps.sx }))) : isAutoCompleteFilter ? (jsxRuntime.jsx(core.Autocomplete, Object.assign({}, commonProps, { rightSection: ((_h = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _h === void 0 ? void 0 : _h.length) ? ClearButton : undefined, onChange: (value) => setFilterValue(value), withinPortal: true }, autoCompleteProps, { data: filterSelectOptions, ref: (node) => {\n            if (node) {\n                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                    node;\n                if (autoCompleteProps.ref) {\n                    autoCompleteProps.ref.current = node;\n                }\n            }\n        }, sx: commonProps.sx }))) : (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { rightSection: ((_j = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j === void 0 ? void 0 : _j.length) ? ClearButton : undefined, onChange: (e) => setFilterValue(e.target.value) }, textInputProps, { ref: (node) => {\n            if (node) {\n                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                    node;\n                if (textInputProps.ref) {\n                    textInputProps.ref.current = node;\n                }\n            }\n        }, sx: commonProps.sx })));\n};\n\nconst MRT_FilterRangeFields = ({ header, table, }) => {\n    return (jsxRuntime.jsxs(core.Box, { sx: { display: 'grid', gridTemplateColumns: '6fr 6fr', gap: '16px' }, children: [jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 0, table: table }), jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 1, table: table })] }));\n};\n\nconst MRT_ToolbarAlertBanner = ({ stackAlertBanner, table, }) => {\n    var _a, _b, _c;\n    const { getPrePaginationRowModel, getSelectedRowModel, getState, options: { enableRowSelection, enableSelectAll, icons: { IconX }, localization, mantineToolbarAlertBannerBadgeProps, mantineToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount, }, } = table;\n    const { grouping, showAlertBanner, density } = getState();\n    const alertProps = mantineToolbarAlertBannerProps instanceof Function\n        ? mantineToolbarAlertBannerProps({ table })\n        : mantineToolbarAlertBannerProps;\n    const badgeProps = mantineToolbarAlertBannerBadgeProps instanceof Function\n        ? mantineToolbarAlertBannerBadgeProps({ table })\n        : mantineToolbarAlertBannerBadgeProps;\n    const selectedAlert = getSelectedRowModel().rows.length > 0\n        ? (_b = (_a = localization.selectedCountOfRowCountRowsSelected) === null || _a === void 0 ? void 0 : _a.replace('{selectedCount}', getSelectedRowModel().rows.length.toString())) === null || _b === void 0 ? void 0 : _b.replace('{rowCount}', (rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length).toString())\n        : null;\n    const groupedAlert = grouping.length > 0 ? (jsxRuntime.jsxs(core.Flex, { children: [localization.groupedBy, ' ', grouping.map((columnId, index) => (jsxRuntime.jsxs(react.Fragment, { children: [index > 0 ? localization.thenBy : '', jsxRuntime.jsxs(core.Badge, Object.assign({ rightSection: jsxRuntime.jsx(core.ActionIcon, { onClick: () => table.getColumn(columnId).toggleGrouping(), size: \"xs\", children: jsxRuntime.jsx(IconX, {}) }), sx: { marginLeft: '1ch' }, variant: \"filled\" }, badgeProps, { children: [table.getColumn(columnId).columnDef.header, ' '] }))] }, `${index}-${columnId}`)))] })) : null;\n    return (jsxRuntime.jsx(core.Collapse, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, transitionDuration: stackAlertBanner ? 200 : 0, children: jsxRuntime.jsx(core.Alert, Object.assign({ color: \"blue\", icon: false }, alertProps, { sx: (theme) => (Object.assign({ borderRadius: 0, fontSize: '16px', left: 0, position: 'relative', marginBottom: stackAlertBanner\n                    ? 0\n                    : positionToolbarAlertBanner === 'bottom'\n                        ? '-16px'\n                        : undefined, padding: '8px', right: 0, top: 0, width: '100%', zIndex: 2 }, ((alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx) instanceof Function\n                ? alertProps.sx(theme)\n                : alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx))), children: (_c = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({\n                groupedAlert,\n                selectedAlert,\n                table,\n            })) !== null && _c !== void 0 ? _c : (jsxRuntime.jsxs(core.Flex, { sx: {\n                    gap: '12px',\n                    padding: positionToolbarAlertBanner === 'head-overlay'\n                        ? density === 'xl'\n                            ? '16px'\n                            : density === 'md'\n                                ? '8px'\n                                : '2px'\n                        : '8px 16px',\n                }, children: [enableRowSelection &&\n                        enableSelectAll &&\n                        positionToolbarAlertBanner === 'head-overlay' && (jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })), jsxRuntime.jsxs(core.Stack, { children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && (jsxRuntime.jsx(\"br\", {})), selectedAlert, selectedAlert && groupedAlert && jsxRuntime.jsx(\"br\", {}), groupedAlert] })] })) })) }));\n};\n\nconst MRT_ToggleFullScreenButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { IconMinimize, IconMaximize }, localization, }, setIsFullScreen, } = table;\n    const { isFullScreen } = getState();\n    const [tooltipOpened, setTooltipOpened] = react.useState(false);\n    const handleToggleFullScreen = () => {\n        setTooltipOpened(false);\n        setIsFullScreen(!isFullScreen);\n    };\n    return (jsxRuntime.jsx(core.Tooltip, { opened: tooltipOpened, withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.toggleFullScreen, onClick: handleToggleFullScreen, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: \"lg\" }, rest, { title: undefined, children: isFullScreen ? jsxRuntime.jsx(IconMinimize, {}) : jsxRuntime.jsx(IconMaximize, {}) })) }));\n};\n\nconst MRT_ColumnPinningButtons = ({ column, table, }) => {\n    const { options: { icons: { IconPinned, IconPinnedOff }, localization, }, } = table;\n    const handlePinColumn = (pinDirection) => {\n        column.pin(pinDirection);\n    };\n    return (jsxRuntime.jsx(core.Flex, { sx: {\n            minWidth: '70px',\n            alignContent: 'center',\n            justifyContent: 'center',\n        }, children: column.getIsPinned() ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.unpin, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn(false), size: \"md\", children: jsxRuntime.jsx(IconPinnedOff, {}) }) })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToLeft, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn('left'), size: \"md\", children: jsxRuntime.jsx(IconPinned, { style: {\n                                transform: 'rotate(90deg)',\n                            } }) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToRight, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn('right'), size: \"md\", children: jsxRuntime.jsx(IconPinned, { style: {\n                                transform: 'rotate(-90deg)',\n                            } }) }) })] })) }));\n};\n\nconst MRT_ShowHideColumnsMenuItems = ({ allColumns, hoveredColumn, setHoveredColumn, column, isSubMenu, table, }) => {\n    var _a;\n    const { getState, options: { enableColumnOrdering, enableHiding, enablePinning, localization, }, setColumnOrder, } = table;\n    const { columnOrder } = getState();\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const switchChecked = (columnDefType !== 'group' && column.getIsVisible()) ||\n        (columnDefType === 'group' &&\n            column.getLeafColumns().some((col) => col.getIsVisible()));\n    const handleToggleColumnHidden = (column) => {\n        var _a, _b;\n        if (columnDefType === 'group') {\n            (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (childColumn) => {\n                childColumn.toggleVisibility(!switchChecked);\n            });\n        }\n        else {\n            column.toggleVisibility();\n        }\n    };\n    const menuItemRef = react.useRef(null);\n    const [isDragging, setIsDragging] = react.useState(false);\n    const handleDragStart = (e) => {\n        setIsDragging(true);\n        e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);\n    };\n    const handleDragEnd = (_e) => {\n        setIsDragging(false);\n        setHoveredColumn(null);\n        if (hoveredColumn) {\n            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));\n        }\n    };\n    const handleDragEnter = (_e) => {\n        if (!isDragging && columnDef.enableColumnOrdering !== false) {\n            setHoveredColumn(column);\n        }\n    };\n    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { component: \"span\", ref: menuItemRef, onDragEnter: handleDragEnter, sx: (theme) => ({\n                    alignItems: 'center',\n                    cursor: 'default',\n                    justifyContent: 'flex-start',\n                    opacity: isDragging ? 0.5 : 1,\n                    outline: isDragging\n                        ? `1px dashed ${theme.colors.gray[7]}`\n                        : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id\n                            ? `2px dashed ${getPrimaryColor(theme)}`\n                            : 'none',\n                    paddingLeft: `${(column.depth + 0.5) * 2}rem`,\n                    paddingTop: '6px',\n                    paddingBottom: '6px',\n                }), children: jsxRuntime.jsxs(core.Box, { sx: {\n                        display: 'flex',\n                        flexWrap: 'nowrap',\n                        gap: '8px',\n                    }, children: [!isSubMenu &&\n                            columnDefType !== 'group' &&\n                            enableColumnOrdering &&\n                            !allColumns.some((col) => col.columnDef.columnDefType === 'group') &&\n                            (columnDef.enableColumnOrdering !== false ? (jsxRuntime.jsx(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })) : (jsxRuntime.jsx(core.Box, { sx: { width: '22px' } }))), !isSubMenu &&\n                            enablePinning &&\n                            (column.getCanPin() ? (jsxRuntime.jsx(MRT_ColumnPinningButtons, { column: column, table: table })) : (jsxRuntime.jsx(core.Box, { sx: { width: '70px' } }))), enableHiding ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.toggleVisibility, children: jsxRuntime.jsx(core.Switch, { checked: switchChecked, disabled: (isSubMenu && switchChecked) || !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column), sx: {\n                                    cursor: 'pointer !important',\n                                } }) })) : (jsxRuntime.jsx(core.Text, { sx: { alignSelf: 'center' }, children: columnDef.header }))] }) }), (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: c, hoveredColumn: hoveredColumn, isSubMenu: isSubMenu, setHoveredColumn: setHoveredColumn, table: table }, `${i}-${c.id}`)))] }));\n};\n\nconst MRT_ShowHideColumnsMenu = ({ isSubMenu, table, }) => {\n    const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, toggleAllColumnsVisible, options: { enableColumnOrdering, enableHiding, enablePinning, localization, }, } = table;\n    const { columnOrder, columnPinning } = getState();\n    const hideAllColumns = () => {\n        getAllLeafColumns()\n            .filter((col) => col.columnDef.enableHiding !== false)\n            .forEach((col) => col.toggleVisibility(false));\n    };\n    const allColumns = react.useMemo(() => {\n        const columns = getAllColumns();\n        if (columnOrder.length > 0 &&\n            !columns.some((col) => col.columnDef.columnDefType === 'group')) {\n            return [\n                ...getLeftLeafColumns(),\n                ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),\n                ...getRightLeafColumns(),\n            ].filter(Boolean);\n        }\n        return columns;\n    }, [\n        columnOrder,\n        columnPinning,\n        getAllColumns(),\n        getCenterLeafColumns(),\n        getLeftLeafColumns(),\n        getRightLeafColumns(),\n    ]);\n    const [hoveredColumn, setHoveredColumn] = react.useState(null);\n    return (jsxRuntime.jsxs(core.Menu.Dropdown, { sx: {\n            maxHeight: 'calc(80vh - 100px)',\n            overflowY: 'auto',\n        }, children: [jsxRuntime.jsxs(core.Flex, { sx: {\n                    justifyContent: isSubMenu ? 'center' : 'space-between',\n                    padding: '8px',\n                    gap: '8px',\n                }, children: [!isSubMenu && enableHiding && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsVisible(), onClick: hideAllColumns, variant: \"subtle\", children: localization.hideAll })), !isSubMenu && enableColumnOrdering && (jsxRuntime.jsx(core.Button, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)), variant: \"subtle\", children: localization.resetOrder })), !isSubMenu && enablePinning && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), variant: \"subtle\", children: localization.unpinAll })), enableHiding && (jsxRuntime.jsx(core.Button, { disabled: getIsAllColumnsVisible(), onClick: () => toggleAllColumnsVisible(true), variant: \"subtle\", children: localization.showAll }))] }), jsxRuntime.jsx(core.Divider, {}), allColumns.map((column, index) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: column, hoveredColumn: hoveredColumn, isSubMenu: isSubMenu, setHoveredColumn: setHoveredColumn, table: table }, `${index}-${column.id}`)))] }));\n};\n\nconst MRT_ShowHideColumnsButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { options: { icons: { IconColumns }, localization, }, } = table;\n    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: false, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.showHideColumns, size: \"lg\" }, rest, { title: undefined, children: jsxRuntime.jsx(IconColumns, {}) })) }) }), jsxRuntime.jsx(MRT_ShowHideColumnsMenu, { table: table })] }));\n};\n\nconst sizes = ['xs', 'md', 'xl'];\nconst MRT_ToggleDensePaddingButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization, }, setDensity, } = table;\n    const { density } = getState();\n    const handleToggleDensePadding = () => {\n        var _a;\n        setDensity((_a = sizes[(sizes.indexOf(density) - 1) % sizes.length]) !== null && _a !== void 0 ? _a : 'xl');\n    };\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.toggleDensity, onClick: handleToggleDensePadding, size: \"lg\" }, rest, { title: undefined, children: density === 'xs' ? (jsxRuntime.jsx(IconBaselineDensitySmall, {})) : density === 'md' ? (jsxRuntime.jsx(IconBaselineDensityMedium, {})) : (jsxRuntime.jsx(IconBaselineDensityLarge, {})) })) }));\n};\n\nconst MRT_ToggleFiltersButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { IconFilter, IconFilterOff }, localization, }, setShowColumnFilters, } = table;\n    const { showColumnFilters } = getState();\n    const handleToggleShowFilters = () => {\n        setShowColumnFilters(!showColumnFilters);\n    };\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.showHideFilters, onClick: handleToggleShowFilters, size: \"lg\" }, rest, { title: undefined, children: showColumnFilters ? jsxRuntime.jsx(IconFilterOff, {}) : jsxRuntime.jsx(IconFilter, {}) })) }));\n};\n\nconst MRT_ToggleGlobalFilterButton = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { IconSearch, IconSearchOff }, localization, }, refs: { searchInputRef }, setShowGlobalFilter, } = table;\n    const { globalFilter, showGlobalFilter } = getState();\n    const handleToggleSearch = () => {\n        setShowGlobalFilter(!showGlobalFilter);\n        setTimeout(() => { var _a; return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);\n    };\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch, size: \"lg\" }, rest, { title: undefined, children: showGlobalFilter ? jsxRuntime.jsx(IconSearchOff, {}) : jsxRuntime.jsx(IconSearch, {}) })) }));\n};\n\nconst MRT_ToolbarInternalButtons = ({ table, }) => {\n    var _a;\n    const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, enablePinning, initialState, renderToolbarInternalActions, }, } = table;\n    return (jsxRuntime.jsx(core.Flex, { sx: {\n            alignItems: 'center',\n            gap: '2px',\n            zIndex: 3,\n        }, children: (_a = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({\n            table,\n        })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableFilters &&\n                    enableGlobalFilter &&\n                    !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (jsxRuntime.jsx(MRT_ToggleGlobalFilterButton, { table: table })), enableFilters &&\n                    enableColumnFilters &&\n                    columnFilterDisplayMode !== 'popover' && (jsxRuntime.jsx(MRT_ToggleFiltersButton, { table: table })), (enableHiding || enableColumnOrdering || enablePinning) && (jsxRuntime.jsx(MRT_ShowHideColumnsButton, { table: table })), enableDensityToggle && (jsxRuntime.jsx(MRT_ToggleDensePaddingButton, { table: table })), enableFullScreenToggle && (jsxRuntime.jsx(MRT_ToggleFullScreenButton, { table: table }))] })) }));\n};\n\nconst MRT_ToolbarDropZone = ({ table, }) => {\n    const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone, } = table;\n    const { draggingColumn, hoveredColumn, grouping, showToolbarDropZone } = getState();\n    const handleDragEnter = (_event) => {\n        setHoveredColumn({ id: 'drop-zone' });\n    };\n    react.useEffect(() => {\n        var _a;\n        if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {\n            setShowToolbarDropZone(!!enableGrouping &&\n                !!draggingColumn &&\n                draggingColumn.columnDef.enableGrouping !== false &&\n                !grouping.includes(draggingColumn.id));\n        }\n    }, [enableGrouping, draggingColumn, grouping]);\n    return (jsxRuntime.jsx(core.Transition, { mounted: showToolbarDropZone, transition: \"fade\", children: (styles) => {\n            var _a, _b;\n            return (jsxRuntime.jsx(core.Flex, { className: \"mantine-ToolbarDropZone\", sx: (theme) => ({\n                    alignItems: 'center',\n                    backgroundColor: theme.fn.rgba(getPrimaryColor(theme), (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' ? 0.2 : 0.1),\n                    border: `dashed ${getPrimaryColor(theme)} 2px`,\n                    justifyContent: 'center',\n                    height: 'calc(100%)',\n                    position: 'absolute',\n                    width: 'calc(100%)',\n                    zIndex: 2,\n                }), onDragEnter: handleDragEnter, style: styles, children: jsxRuntime.jsx(core.Text, { children: localization.dropToGroupBy.replace('{column}', (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : '') }) }));\n        } }));\n};\n\nconst commonToolbarStyles = ({ theme }) => ({\n    alignItems: 'flex-start',\n    backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white,\n    backgroundImage: 'none',\n    display: 'grid',\n    flexWrap: 'wrap-reverse',\n    minHeight: '3.5rem',\n    overflow: 'visible',\n    padding: '0',\n    transition: 'all 100ms ease-in-out',\n    zIndex: 3,\n});\nconst MRT_TopToolbar = ({ table, }) => {\n    var _a;\n    const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, mantineTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions, }, refs: { topToolbarRef }, } = table;\n    const { isFullScreen, showGlobalFilter } = getState();\n    const isMobile = hooks.useMediaQuery('(max-width: 720px)');\n    const toolbarProps = mantineTopToolbarProps instanceof Function\n        ? mantineTopToolbarProps({ table })\n        : mantineTopToolbarProps;\n    const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { ref: (node) => {\n            if (node) {\n                topToolbarRef.current = node;\n                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n                    toolbarProps.ref.current = node;\n                }\n            }\n        }, sx: (theme) => (Object.assign(Object.assign({ position: isFullScreen ? 'sticky' : 'relative', top: isFullScreen ? '0' : undefined }, commonToolbarStyles({ theme })), ((toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function\n            ? toolbarProps.sx(theme)\n            : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx))), children: [positionToolbarAlertBanner === 'top' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Flex, { sx: {\n                    alignItems: 'flex-start',\n                    boxSizing: 'border-box',\n                    justifyContent: 'space-between',\n                    padding: '8px',\n                    position: stackAlertBanner ? 'relative' : 'absolute',\n                    right: 0,\n                    top: 0,\n                    width: '100%',\n                }, children: [enableGlobalFilter && positionGlobalFilter === 'left' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : jsxRuntime.jsx(\"span\", {}), enableToolbarInternalActions ? (jsxRuntime.jsxs(core.Flex, { sx: {\n                            flexWrap: 'wrap-reverse',\n                            justifyContent: 'flex-end',\n                        }, children: [enableGlobalFilter && positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })), jsxRuntime.jsx(MRT_ToolbarInternalButtons, { table: table })] })) : (enableGlobalFilter &&\n                        positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })))] }), enablePagination &&\n                ['top', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(core.Flex, { justify: \"end\", children: jsxRuntime.jsx(MRT_TablePagination, { table: table, position: \"top\" }) })), jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: true, table: table })] })));\n};\n\nconst MRT_BottomToolbar = ({ table, }) => {\n    const { getState, options: { enablePagination, mantineBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions, }, refs: { bottomToolbarRef }, } = table;\n    const { isFullScreen } = getState();\n    const isMobile = hooks.useMediaQuery('(max-width: 720px)');\n    const toolbarProps = mantineBottomToolbarProps instanceof Function\n        ? mantineBottomToolbarProps({ table })\n        : mantineBottomToolbarProps;\n    const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { ref: (node) => {\n            if (node) {\n                bottomToolbarRef.current = node;\n                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n                    toolbarProps.ref.current = node;\n                }\n            }\n        }, sx: (theme) => (Object.assign(Object.assign(Object.assign({}, commonToolbarStyles({ theme })), { bottom: isFullScreen ? '0' : undefined, boxShadow: `0 1px 2px -1px ${theme.fn.rgba(theme.black, 0.1)} inset`, left: 0, position: isFullScreen ? 'fixed' : 'relative', right: 0 }), ((toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function\n            ? toolbarProps.sx(theme)\n            : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx))), children: [jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: false, table: table }), positionToolbarAlertBanner === 'bottom' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Box, { sx: {\n                    alignItems: 'center',\n                    boxSizing: 'border-box',\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                    padding: '8px',\n                    width: '100%',\n                }, children: [renderBottomToolbarCustomActions ? (renderBottomToolbarCustomActions({ table })) : (jsxRuntime.jsx(\"span\", {})), jsxRuntime.jsx(core.Box, { sx: {\n                            display: 'flex',\n                            justifyContent: 'flex-end',\n                            position: stackAlertBanner ? 'relative' : 'absolute',\n                            right: 0,\n                            top: 0,\n                        }, children: enablePagination &&\n                            ['bottom', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(MRT_TablePagination, { table: table, position: \"bottom\" })) })] })] })));\n};\n\nconst MRT_ColumnActionMenu = ({ header, table, }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const { getState, toggleAllColumnsVisible, setColumnOrder, options: { columnFilterDisplayMode, enableColumnFilters, enableColumnResizing, enableGrouping, enableHiding, enablePinning, enableSorting, enableSortingRemoval, icons: { IconArrowAutofitContent, IconBoxMultiple, IconClearAll, IconColumns, IconDotsVertical, IconEyeOff, IconFilter, IconFilterOff, IconPinned, IconPinnedOff, IconSortAscending, IconSortDescending, }, localization, mantineColumnActionsButtonProps, renderColumnActionsMenuItems, }, refs: { filterInputRefs }, setColumnSizingInfo, setShowColumnFilters, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { columnSizing, columnVisibility } = getState();\n    const mTableHeadCellColumnActionsButtonProps = mantineColumnActionsButtonProps instanceof Function\n        ? mantineColumnActionsButtonProps({ column, table })\n        : mantineColumnActionsButtonProps;\n    const mcTableHeadCellColumnActionsButtonProps = columnDef.mantineColumnActionsButtonProps instanceof Function\n        ? columnDef.mantineColumnActionsButtonProps({\n            column,\n            table,\n        })\n        : columnDef.mantineColumnActionsButtonProps;\n    const actionIconProps = Object.assign(Object.assign({}, mTableHeadCellColumnActionsButtonProps), mcTableHeadCellColumnActionsButtonProps);\n    const handleClearSort = () => {\n        column.clearSorting();\n    };\n    const handleSortAsc = () => {\n        column.toggleSorting(false);\n    };\n    const handleSortDesc = () => {\n        column.toggleSorting(true);\n    };\n    const handleResetColumnSize = () => {\n        setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));\n        column.resetSize();\n    };\n    const handleHideColumn = () => {\n        column.toggleVisibility(false);\n    };\n    const handlePinColumn = (pinDirection) => {\n        column.pin(pinDirection);\n    };\n    const handleGroupByColumn = () => {\n        column.toggleGrouping();\n        setColumnOrder((old) => ['mrt-row-expand', ...old]);\n    };\n    const handleClearFilter = () => {\n        column.setFilterValue('');\n    };\n    const handleFilterByColumn = () => {\n        setShowColumnFilters(true);\n        setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);\n    };\n    const handleShowAllColumns = () => {\n        toggleAllColumnsVisible(true);\n    };\n    const internalColumnMenuItems = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSorting && column.getCanSort() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSortingRemoval !== false && (jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsSorted(), icon: jsxRuntime.jsx(IconClearAll, {}), onClick: handleClearSort, children: localization.clearSort })), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsSorted() === 'asc', icon: jsxRuntime.jsx(IconSortAscending, {}), onClick: handleSortAsc, children: (_a = localization.sortByColumnAsc) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header)) }), jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconSortDescending, {}), disabled: column.getIsSorted() === 'desc', onClick: handleSortDesc, children: (_b = localization.sortByColumnDesc) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header)) }), (enableColumnFilters || enableGrouping || enableHiding) && (jsxRuntime.jsx(core.Menu.Divider, {}, 3))] })), enableColumnFilters &&\n                columnFilterDisplayMode !== 'popover' &&\n                column.getCanFilter() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getFilterValue(), icon: jsxRuntime.jsx(IconFilterOff, {}), onClick: handleClearFilter, children: localization.clearFilter }), jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconFilter, {}), onClick: handleFilterByColumn, children: (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)) }), (enableGrouping || enableHiding) && jsxRuntime.jsx(core.Menu.Divider, {}, 2)] })), enableGrouping && column.getCanGroup() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconBoxMultiple, {}), onClick: handleGroupByColumn, children: (_d = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)) }), enablePinning && jsxRuntime.jsx(core.Menu.Divider, {})] })), enablePinning && column.getCanPin() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'left' || !column.getCanPin(), icon: jsxRuntime.jsx(IconPinned, { style: { transform: 'rotate(90deg)' } }), onClick: () => handlePinColumn('left'), children: localization.pinToLeft }), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'right' || !column.getCanPin(), icon: jsxRuntime.jsx(IconPinned, { style: { transform: 'rotate(-90deg)' } }), onClick: () => handlePinColumn('right'), children: localization.pinToRight }), jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsPinned(), icon: jsxRuntime.jsx(IconPinnedOff, {}), onClick: () => handlePinColumn(false), children: localization.unpin }), enableHiding && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnResizing && column.getCanResize() && (jsxRuntime.jsx(core.Menu.Item, { disabled: !columnSizing[column.id], icon: jsxRuntime.jsx(IconArrowAutofitContent, {}), onClick: handleResetColumnSize, children: localization.resetColumnSize }, 0)), enableHiding && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getCanHide(), icon: jsxRuntime.jsx(IconEyeOff, {}), onClick: handleHideColumn, children: (_e = localization.hideColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)) }, 0), jsxRuntime.jsx(core.Menu.Item, { disabled: !Object.values(columnVisibility).filter((visible) => !visible)\n                            .length, icon: jsxRuntime.jsx(IconColumns, {}), onClick: handleShowAllColumns, children: (_f = localization.showAllColumns) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)) }, 1)] }))] }));\n    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: true, withinPortal: true, position: \"bottom-start\", children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_g = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _g !== void 0 ? _g : localization.columnActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ \"aria-label\": localization.columnActions, size: \"sm\" }, actionIconProps, { sx: (theme) => (Object.assign({ opacity: 0.5, transition: 'opacity 100ms', '&:hover': {\n                                opacity: 1,\n                            } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function\n                            ? actionIconProps.sx(theme)\n                            : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), children: jsxRuntime.jsx(IconDotsVertical, {}) })) }) }), jsxRuntime.jsx(core.Menu.Dropdown, { children: (_k = (_j = (_h = columnDef.renderColumnActionsMenuItems) === null || _h === void 0 ? void 0 : _h.call(columnDef, {\n                    column,\n                    table,\n                    internalColumnMenuItems,\n                })) !== null && _j !== void 0 ? _j : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({\n                    column,\n                    table,\n                    internalColumnMenuItems,\n                })) !== null && _k !== void 0 ? _k : internalColumnMenuItems })] }));\n};\n\nconst MRT_FilterRangeSlider = ({ header, table, }) => {\n    var _a;\n    const { options: { mantineFilterRangeSliderProps }, refs: { filterInputRefs }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const mFilterRangeSliderProps = mantineFilterRangeSliderProps instanceof Function\n        ? mantineFilterRangeSliderProps({\n            column,\n            table,\n        })\n        : mantineFilterRangeSliderProps;\n    const mcFilterRangeSliderProps = columnDef.mantineFilterRangeSliderProps instanceof Function\n        ? columnDef.mantineFilterRangeSliderProps({\n            column,\n            table,\n        })\n        : columnDef.mantineFilterRangeSliderProps;\n    const rangeSliderProps = Object.assign(Object.assign({}, mFilterRangeSliderProps), mcFilterRangeSliderProps);\n    let [min, max] = rangeSliderProps.min !== undefined && rangeSliderProps.max !== undefined\n        ? [rangeSliderProps.min, rangeSliderProps.max]\n        : (_a = column.getFacetedMinMaxValues()) !== null && _a !== void 0 ? _a : [0, 1];\n    //fix potential TanStack Table bugs where min or max is an array\n    if (Array.isArray(min))\n        min = min[0];\n    if (Array.isArray(max))\n        max = max[0];\n    if (min === null)\n        min = 0;\n    if (max === null)\n        max = 1;\n    const [filterValues, setFilterValues] = react.useState([\n        min,\n        max,\n    ]);\n    const columnFilterValue = column.getFilterValue();\n    const isMounted = react.useRef(false);\n    react.useEffect(() => {\n        if (isMounted.current) {\n            if (columnFilterValue === undefined) {\n                setFilterValues([min, max]);\n            }\n            else if (Array.isArray(columnFilterValue)) {\n                setFilterValues(columnFilterValue);\n            }\n        }\n        isMounted.current = true;\n    }, [columnFilterValue, min, max]);\n    return (jsxRuntime.jsx(core.RangeSlider, Object.assign({ min: min, max: max, onChange: (values) => {\n            setFilterValues(values);\n        }, onChangeEnd: (values) => {\n            if (Array.isArray(values)) {\n                if (values[0] <= min && values[1] >= max) {\n                    //if the user has selected the entire range, remove the filter\n                    column.setFilterValue(undefined);\n                }\n                else {\n                    column.setFilterValue(values);\n                }\n            }\n        }, value: filterValues }, rangeSliderProps, { ref: (node) => {\n            if (node) {\n                //@ts-ignore\n                filterInputRefs.current[`${column.id}-0`] = node;\n                // @ts-ignore\n                if (rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.ref) {\n                    //@ts-ignore\n                    rangeSliderProps.ref = node;\n                }\n            }\n        }, sx: (theme) => (Object.assign({ margin: 'auto', marginTop: '16px', marginBottom: '6px', width: 'calc(100% - 8px)' }, ((rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.sx) instanceof Function\n            ? rangeSliderProps.sx(theme)\n            : rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.sx))) })));\n};\n\nconst MRT_TableHeadCellFilterContainer = ({ header, table, }) => {\n    var _a, _b, _c;\n    const { getState, options: { columnFilterDisplayMode, enableColumnFilterModes, columnFilterModeOptions, icons: { IconFilterCog }, localization, }, refs: { filterInputRefs }, } = table;\n    const { showColumnFilters } = getState();\n    const { column } = header;\n    const { columnDef } = column;\n    const currentFilterOption = columnDef._filterFn;\n    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;\n    const showChangeModeButton = enableColumnFilterModes &&\n        columnDef.enableColumnFilterModes !== false &&\n        (allowedColumnFilterOptions === undefined ||\n            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));\n    return (jsxRuntime.jsx(core.Collapse, { in: showColumnFilters || columnFilterDisplayMode === 'popover', children: jsxRuntime.jsxs(core.Flex, { direction: \"column\", children: [jsxRuntime.jsxs(core.Flex, { align: \"flex-end\", children: [columnDef.filterVariant === 'checkbox' ? (jsxRuntime.jsx(MRT_FilterCheckbox, { column: column, table: table })) : columnDef.filterVariant === 'range-slider' ? (jsxRuntime.jsx(MRT_FilterRangeSlider, { header: header, table: table })) : ['range', 'date-range'].includes((_b = columnDef.filterVariant) !== null && _b !== void 0 ? _b : '') ||\n                            ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn) ? (jsxRuntime.jsx(MRT_FilterRangeFields, { header: header, table: table })) : (jsxRuntime.jsx(MRT_FilterTextInput, { header: header, table: table })), showChangeModeButton && (jsxRuntime.jsxs(core.Menu, { withinPortal: columnFilterDisplayMode !== 'popover', children: [jsxRuntime.jsx(core.Tooltip, { label: localization.changeFilterMode, position: \"bottom-start\", withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": localization.changeFilterMode, size: \"md\", sx: { transform: 'translateY(-2px)' }, children: jsxRuntime.jsx(IconFilterCog, {}) }) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { header: header, table: table, onSelect: () => setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100) })] }))] }), showChangeModeButton ? (jsxRuntime.jsx(core.Text, { component: \"label\", color: \"dimmed\", sx: { whiteSpace: 'nowrap', marginTop: '4px', fontSize: '10px' }, children: localization.filterMode.replace('{filterType}', \n                    // @ts-ignore\n                    localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +\n                        (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]) })) : null] }) }));\n};\n\nconst MRT_TableHeadCellFilterLabel = ({ header, table, }) => {\n    var _a, _b, _c, _d;\n    const { options: { columnFilterDisplayMode, icons: { IconFilter }, localization, }, refs: { filterInputRefs }, setShowColumnFilters, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const theme = core.useMantineTheme();\n    const filterValue = column.getFilterValue();\n    const [popoverOpened, setPopoverOpened] = react.useState(false);\n    const isFilterActive = (Array.isArray(filterValue) && filterValue.some(Boolean)) ||\n        (!!filterValue && !Array.isArray(filterValue));\n    const isRangeFilter = columnDef.filterVariant === 'range' ||\n        ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);\n    const currentFilterOption = columnDef._filterFn;\n    const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive\n        ? (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header))\n        : localization.filteringByColumn\n            .replace('{column}', String(columnDef.header))\n            .replace('{filterType}', \n        // @ts-ignore\n        localization[`filter${((_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) +\n            (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`])\n            .replace('{filterValue}', `\"${Array.isArray(column.getFilterValue())\n            ? column.getFilterValue().join(`\" ${isRangeFilter ? localization.and : localization.or} \"`)\n            : column.getFilterValue()}\"`)\n            .replace('\" \"', '');\n    return (jsxRuntime.jsxs(core.Popover, { onClose: () => setPopoverOpened(false), opened: popoverOpened, position: \"top\", keepMounted: columnDef.filterVariant === 'range-slider', shadow: \"xl\", width: 360, withinPortal: true, children: [jsxRuntime.jsx(core.Transition, { transition: \"scale\", mounted: columnFilterDisplayMode === 'popover' ||\n                    (!!column.getFilterValue() && !isRangeFilter) ||\n                    (isRangeFilter && // @ts-ignore\n                        (!!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[0]) || !!((_d = column.getFilterValue()) === null || _d === void 0 ? void 0 : _d[1]))), children: (styles) => (jsxRuntime.jsx(core.Box, { component: \"span\", sx: { flex: '0 0' }, style: styles, children: jsxRuntime.jsx(core.Popover.Target, { children: jsxRuntime.jsx(core.Tooltip, { disabled: popoverOpened, label: filterTooltip, multiline: true, width: filterTooltip.length > 40 ? 300 : undefined, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { color: isFilterActive ? getPrimaryColor(theme) : undefined, onClick: (event) => {\n                                    event.stopPropagation();\n                                    if (columnFilterDisplayMode === 'popover') {\n                                        setPopoverOpened((opened) => !opened);\n                                    }\n                                    else {\n                                        setShowColumnFilters(true);\n                                    }\n                                    setTimeout(() => {\n                                        var _a, _b;\n                                        (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus();\n                                        (_b = filterInputRefs.current[`${column.id}-0`]) === null || _b === void 0 ? void 0 : _b.select();\n                                    }, 100);\n                                }, size: \"sm\", sx: {\n                                    opacity: isFilterActive ? 1 : 0.5,\n                                    padding: '2px',\n                                    '&:hover': {\n                                        opacity: 1,\n                                    },\n                                }, children: jsxRuntime.jsx(IconFilter, {}) }) }) }) })) }), columnFilterDisplayMode === 'popover' && (jsxRuntime.jsx(core.Popover.Dropdown, { onClick: (event) => event.stopPropagation(), onKeyDown: (event) => event.key === 'Enter' && setPopoverOpened(false), children: jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }) }))] }));\n};\n\nconst MRT_TableHeadCellGrabHandle = ({ column, table, tableHeadCellRef, }) => {\n    const { getState, options: { enableColumnOrdering, mantineColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn, } = table;\n    const { columnDef } = column;\n    const { hoveredColumn, draggingColumn, columnOrder } = getState();\n    const mActionIconProps = mantineColumnDragHandleProps instanceof Function\n        ? mantineColumnDragHandleProps({ column, table })\n        : mantineColumnDragHandleProps;\n    const mcActionIconProps = columnDef.mantineColumnDragHandleProps instanceof Function\n        ? columnDef.mantineColumnDragHandleProps({ column, table })\n        : columnDef.mantineColumnDragHandleProps;\n    const actionIconProps = Object.assign(Object.assign({}, mActionIconProps), mcActionIconProps);\n    const handleDragStart = (event) => {\n        var _a;\n        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);\n        setDraggingColumn(column);\n        event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);\n    };\n    const handleDragEnd = (event) => {\n        var _a;\n        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);\n        if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            column.toggleGrouping();\n        }\n        else if (enableColumnOrdering &&\n            hoveredColumn &&\n            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {\n            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));\n        }\n        setDraggingColumn(null);\n        setHoveredColumn(null);\n    };\n    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));\n};\n\nconst MRT_TableHeadCellResizeHandle = ({ header, table, }) => {\n    var _a;\n    const { getState, options: { columnResizeMode }, setColumnSizingInfo, } = table;\n    const { density } = getState();\n    const { column } = header;\n    return (jsxRuntime.jsx(core.Box, { onDoubleClick: () => {\n            setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));\n            column.resetSize();\n        }, onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), sx: (theme) => ({\n            cursor: 'col-resize',\n            marginRight: density === 'xl' ? '-24px' : density === 'md' ? '-20px' : '-14px',\n            position: 'absolute',\n            right: '4px',\n            paddingLeft: '1px',\n            paddingRight: '1px',\n            '&:active > .mantine-Divider-vertical': {\n                borderLeftColor: getPrimaryColor(theme),\n            },\n        }), style: {\n            transform: column.getIsResizing() && columnResizeMode === 'onEnd'\n                ? `translateX(${(_a = getState().columnSizingInfo.deltaOffset) !== null && _a !== void 0 ? _a : 0}px)`\n                : undefined,\n        }, children: jsxRuntime.jsx(core.Divider, { orientation: \"vertical\", size: \"lg\", sx: {\n                borderRadius: '2px',\n                borderWidth: '4px',\n                height: '24px',\n                touchAction: 'none',\n                transition: column.getIsResizing()\n                    ? undefined\n                    : 'all 100ms ease-in-out',\n                userSelect: 'none',\n                zIndex: 4,\n            } }) }));\n};\n\nconst MRT_TableHeadCellSortLabel = ({ header, table, }) => {\n    const { getState, options: { icons: { IconSortDescending, IconSortAscending, IconArrowsSort }, localization, }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { sorting } = getState();\n    const theme = core.useMantineTheme();\n    const sortTooltip = column.getIsSorted()\n        ? column.getIsSorted() === 'desc'\n            ? localization.sortedByColumnDesc.replace('{column}', columnDef.header)\n            : localization.sortedByColumnAsc.replace('{column}', columnDef.header)\n        : column.getNextSortingOrder() === 'desc'\n            ? localization.sortByColumnDesc.replace('{column}', columnDef.header)\n            : localization.sortByColumnAsc.replace('{column}', columnDef.header);\n    const showIndicator = sorting.length >= 2 && column.getSortIndex() !== -1;\n    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: sortTooltip, children: jsxRuntime.jsx(core.Indicator, { color: \"transparent\", disabled: !showIndicator, inline: true, label: column.getSortIndex() + 1, offset: 3, children: jsxRuntime.jsx(core.ActionIcon, { \"aria-label\": sortTooltip, color: column.getIsSorted() ? getPrimaryColor(theme) : undefined, size: \"xs\", sx: {\n                    opacity: column.getIsSorted() ? 1 : 0.5,\n                    transform: showIndicator\n                        ? 'translate(-2px, 2px) scale(0.9)'\n                        : undefined,\n                    transition: 'opacity 100ms ease-in-out',\n                    '&:hover': {\n                        opacity: 1,\n                    },\n                }, children: column.getIsSorted() === 'desc' ? (jsxRuntime.jsx(IconSortDescending, {})) : column.getIsSorted() === 'asc' ? (jsxRuntime.jsx(IconSortAscending, {})) : (jsxRuntime.jsx(IconArrowsSort, {})) }) }) }));\n};\n\nconst MRT_TableHeadCell = ({ header, table, }) => {\n    var _a, _b, _c, _d;\n    const theme = core.useMantineTheme();\n    const { getState, options: { columnFilterDisplayMode, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableGrouping, enableMultiSort, layoutMode, mantineTableHeadCellProps, }, refs: { tableHeadCellRefs }, setHoveredColumn, } = table;\n    const { density, draggingColumn, grouping, hoveredColumn } = getState();\n    const { column } = header;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const mTableHeadCellProps = mantineTableHeadCellProps instanceof Function\n        ? mantineTableHeadCellProps({ column, table })\n        : mantineTableHeadCellProps;\n    const mcTableHeadCellProps = columnDef.mantineTableHeadCellProps instanceof Function\n        ? columnDef.mantineTableHeadCellProps({ column, table })\n        : columnDef.mantineTableHeadCellProps;\n    const tableCellProps = Object.assign(Object.assign({}, mTableHeadCellProps), mcTableHeadCellProps);\n    const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) &&\n        columnDef.enableColumnActions !== false;\n    const showDragHandle = enableColumnDragging !== false &&\n        columnDef.enableColumnDragging !== false &&\n        (enableColumnDragging ||\n            (enableColumnOrdering && columnDef.enableColumnOrdering !== false) ||\n            (enableGrouping &&\n                columnDef.enableGrouping !== false &&\n                !grouping.includes(column.id)));\n    const headerPL = react.useMemo(() => {\n        let pl = 0;\n        if (column.getCanSort())\n            pl++;\n        if (showColumnActions)\n            pl += 1.75;\n        if (showDragHandle)\n            pl += 1.25;\n        return pl;\n    }, [showColumnActions, showDragHandle]);\n    const draggingBorder = react.useMemo(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id\n        ? `1px dashed ${theme.colors.gray[7]} !important`\n        : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id\n            ? `2px dashed ${getPrimaryColor(theme)} !important`\n            : undefined, [draggingColumn, hoveredColumn]);\n    const draggingBorders = draggingBorder\n        ? {\n            borderLeft: draggingBorder,\n            borderRight: draggingBorder,\n            borderTop: draggingBorder,\n        }\n        : undefined;\n    const handleDragEnter = (_e) => {\n        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            setHoveredColumn(null);\n        }\n        if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {\n            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n        }\n    };\n    const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function\n        ? (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _a === void 0 ? void 0 : _a.call(columnDef, {\n            column,\n            header,\n            table,\n        })\n        : (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _b !== void 0 ? _b : columnDef.header;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: \"th\", align: columnDefType === 'group' ? 'center' : 'left', colSpan: header.colSpan, onDragEnter: handleDragEnter, ref: (node) => {\n            if (node) {\n                tableHeadCellRefs.current[column.id] = node;\n            }\n        } }, tableCellProps, { sx: (theme) => (Object.assign(Object.assign({ flexDirection: layoutMode === 'grid' ? 'column' : undefined, fontWeight: 'bold', overflow: 'visible', padding: density === 'xl' ? '23px' : density === 'md' ? '16px' : '10px', userSelect: enableMultiSort && column.getCanSort() ? 'none' : undefined, verticalAlign: 'top', zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id\n                ? 3\n                : column.getIsPinned() && columnDefType !== 'group'\n                    ? 2\n                    : 1, '&:hover .mantine-ActionIcon-root': {\n                opacity: 1,\n            } }, getCommonCellStyles({\n            column,\n            header,\n            table,\n            tableCellProps,\n            theme,\n        })), draggingBorders)), children: [header.isPlaceholder ? null : (jsxRuntime.jsxs(core.Flex, { className: \"mantine-TableHeadCell-Content\", sx: {\n                    alignItems: 'flex-start',\n                    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n                    justifyContent: columnDefType === 'group' || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'\n                        ? 'center'\n                        : column.getCanResize()\n                            ? 'space-between'\n                            : 'flex-start',\n                    position: 'relative',\n                    width: '100%',\n                }, children: [jsxRuntime.jsxs(core.Flex, { className: \"mantine-TableHeadCell-Content-Labels\", onClick: column.getToggleSortingHandler(), sx: {\n                            alignItems: 'center',\n                            cursor: column.getCanSort() && columnDefType !== 'group'\n                                ? 'pointer'\n                                : undefined,\n                            flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n                            overflow: columnDefType === 'data' ? 'hidden' : undefined,\n                            paddingLeft: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'\n                                ? `${headerPL}rem`\n                                : undefined,\n                        }, children: [jsxRuntime.jsx(core.Flex, { className: \"mantine-TableHeadCell-Content-Wrapper\", sx: {\n                                    overflow: columnDefType === 'data' ? 'hidden' : undefined,\n                                    textOverflow: 'ellipsis',\n                                    whiteSpace: ((_d = (_c = columnDef.header) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < 20 ? 'nowrap' : 'normal',\n                                }, title: columnDefType === 'data' ? columnDef.header : undefined, children: headerElement }), column.getCanSort() && (jsxRuntime.jsx(MRT_TableHeadCellSortLabel, { header: header, table: table })), column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterLabel, { header: header, table: table }))] }), columnDefType !== 'group' && (jsxRuntime.jsxs(core.Flex, { className: \"mantine-TableHeadCell-Content-Actions\", sx: {\n                            alignItems: 'center',\n                            alignSelf: 'center',\n                            whiteSpace: 'nowrap',\n                        }, children: [showDragHandle && (jsxRuntime.jsx(MRT_TableHeadCellGrabHandle, { column: column, table: table, tableHeadCellRef: {\n                                    current: tableHeadCellRefs.current[column.id],\n                                } })), showColumnActions && (jsxRuntime.jsx(MRT_ColumnActionMenu, { header: header, table: table }))] })), column.getCanResize() && (jsxRuntime.jsx(MRT_TableHeadCellResizeHandle, { header: header, table: table }))] })), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }))] })));\n};\n\nconst MRT_TableHeadRow = ({ headerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {\n    const { getState, options: { enableStickyHeader, layoutMode, mantineTableHeadRowProps }, } = table;\n    const { isFullScreen } = getState();\n    const tableRowProps = mantineTableHeadRowProps instanceof Function\n        ? mantineTableHeadRowProps({ headerGroup, table })\n        : mantineTableHeadRowProps;\n    const stickyHeader = enableStickyHeader || isFullScreen;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: \"tr\" }, tableRowProps, { sx: (theme) => (Object.assign(Object.assign({ backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white, boxShadow: `0 4px 8px ${theme.fn.rgba(theme.black, 0.1)}`, display: layoutMode === 'grid' ? 'flex' : 'table-row', top: stickyHeader ? 0 : undefined }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function\n            ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme)\n            : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx)), { position: stickyHeader ? 'sticky' : undefined })), children: [virtualPaddingLeft ? (jsxRuntime.jsx(\"th\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader) => {\n                const header = virtualColumns\n                    ? headerGroup.headers[headerOrVirtualHeader.index]\n                    : headerOrVirtualHeader;\n                return (jsxRuntime.jsx(MRT_TableHeadCell, { header: header, table: table }, header.id));\n            }), virtualPaddingRight ? (jsxRuntime.jsx(\"th\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));\n};\n\nconst MRT_TableHead = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {\n    const { getHeaderGroups, getSelectedRowModel, getState, options: { enableStickyHeader, layoutMode, mantineTableHeadProps, positionToolbarAlertBanner, }, } = table;\n    const { isFullScreen, showAlertBanner } = getState();\n    const tableHeadProps = mantineTableHeadProps instanceof Function\n        ? mantineTableHeadProps({ table })\n        : mantineTableHeadProps;\n    const stickyHeader = enableStickyHeader || isFullScreen;\n    return (jsxRuntime.jsx(core.Box, Object.assign({ component: \"thead\" }, tableHeadProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-row-group', position: stickyHeader && layoutMode === 'grid' ? 'sticky' : 'relative', opacity: 0.97, top: stickyHeader ? 0 : undefined, zIndex: stickyHeader ? 2 : undefined }, ((tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx) instanceof Function\n            ? tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx(theme)\n            : tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx))), children: positionToolbarAlertBanner === 'head-overlay' &&\n            (showAlertBanner || getSelectedRowModel().rows.length > 0) ? (jsxRuntime.jsx(\"tr\", { style: { display: layoutMode === 'grid' ? 'grid' : 'table-row' }, children: jsxRuntime.jsx(\"th\", { colSpan: table.getVisibleLeafColumns().length, style: {\n                    display: layoutMode === 'grid' ? 'grid' : 'table-cell',\n                    padding: 0,\n                }, children: jsxRuntime.jsx(MRT_ToolbarAlertBanner, { table: table }) }) })) : (getHeaderGroups().map((headerGroup) => (jsxRuntime.jsx(MRT_TableHeadRow, { headerGroup: headerGroup, table: table, virtualColumns: virtualColumns, virtualPaddingLeft: virtualPaddingLeft, virtualPaddingRight: virtualPaddingRight }, headerGroup.id)))) })));\n};\n\nconst MRT_TableFooterCell = ({ footer, table, }) => {\n    var _a, _b, _c;\n    const { options: { layoutMode, mantineTableFooterCellProps }, } = table;\n    const { column } = footer;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const mTableFooterCellProps = mantineTableFooterCellProps instanceof Function\n        ? mantineTableFooterCellProps({ column, table })\n        : mantineTableFooterCellProps;\n    const mcTableFooterCellProps = columnDef.mantineTableFooterCellProps instanceof Function\n        ? columnDef.mantineTableFooterCellProps({ column, table })\n        : columnDef.mantineTableFooterCellProps;\n    const tableCellProps = Object.assign(Object.assign({}, mTableFooterCellProps), mcTableFooterCellProps);\n    return (jsxRuntime.jsx(core.Box, Object.assign({ component: \"th\", align: columnDefType === 'group' ? 'center' : 'left', colSpan: footer.colSpan }, tableCellProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-cell', fontWeight: 'bold', justifyContent: columnDefType === 'group' ? 'center' : undefined, padding: '8px', verticalAlign: 'top', zIndex: column.getIsPinned() && columnDefType !== 'group' ? 2 : 1 }, getCommonCellStyles({\n            column,\n            table,\n            theme,\n            tableCellProps,\n        }))), children: jsxRuntime.jsx(jsxRuntime.Fragment, { children: footer.isPlaceholder\n                ? null\n                : (_c = (_b = (columnDef.Footer instanceof Function\n                    ? (_a = columnDef.Footer) === null || _a === void 0 ? void 0 : _a.call(columnDef, {\n                        column,\n                        footer,\n                        table,\n                    })\n                    : columnDef.Footer)) !== null && _b !== void 0 ? _b : columnDef.footer) !== null && _c !== void 0 ? _c : null }) })));\n};\n\nconst MRT_TableFooterRow = ({ footerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {\n    var _a;\n    const { options: { layoutMode, mantineTableFooterRowProps }, } = table;\n    // if no content in row, skip row\n    if (!((_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => (typeof header.column.columnDef.footer === 'string' &&\n        !!header.column.columnDef.footer) ||\n        header.column.columnDef.Footer)))\n        return null;\n    const tableRowProps = mantineTableFooterRowProps instanceof Function\n        ? mantineTableFooterRowProps({ footerGroup, table })\n        : mantineTableFooterRowProps;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: \"tr\" }, tableRowProps, { sx: (theme) => (Object.assign({ backgroundColor: theme.fn.lighten(theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white, 0.06), display: layoutMode === 'grid' ? 'flex' : 'table-row', width: '100%' }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function\n            ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme)\n            : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx))), children: [virtualPaddingLeft ? (jsxRuntime.jsx(\"th\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter) => {\n                const footer = virtualColumns\n                    ? footerGroup.headers[footerOrVirtualFooter.index]\n                    : footerOrVirtualFooter;\n                return (jsxRuntime.jsx(MRT_TableFooterCell, { footer: footer, table: table }, footer.id));\n            }), virtualPaddingRight ? (jsxRuntime.jsx(\"th\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));\n};\n\nconst MRT_TableFooter = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {\n    const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, mantineTableFooterProps }, } = table;\n    const { isFullScreen } = getState();\n    const tableFooterProps = mantineTableFooterProps instanceof Function\n        ? mantineTableFooterProps({ table })\n        : mantineTableFooterProps;\n    const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;\n    return (jsxRuntime.jsx(core.Box, Object.assign({ component: \"tfoot\" }, tableFooterProps, { sx: (theme) => (Object.assign({ bottom: stickFooter ? 0 : undefined, display: layoutMode === 'grid' ? 'grid' : 'table-row-group', opacity: stickFooter ? 0.97 : undefined, outline: stickFooter\n                ? theme.colorScheme === 'light'\n                    ? `1px solid ${theme.colors.gray[3]}`\n                    : `1px solid ${theme.colors.gray[7]}`\n                : undefined, position: stickFooter ? 'sticky' : undefined, zIndex: stickFooter ? 1 : undefined }, ((tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx) instanceof Function\n            ? tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx(theme)\n            : tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx))), children: getFooterGroups().map((footerGroup) => (jsxRuntime.jsx(MRT_TableFooterRow, { footerGroup: footerGroup, table: table, virtualColumns: virtualColumns, virtualPaddingLeft: virtualPaddingLeft, virtualPaddingRight: virtualPaddingRight }, footerGroup.id))) })));\n};\n\nconst MRT_Table = ({ table, }) => {\n    var _a, _b, _c, _d;\n    const { getFlatHeaders, getState, options: { columnVirtualizerInstanceRef, columnVirtualizerProps, columns, enableColumnResizing, enableColumnVirtualization, enablePinning, enableTableFooter, enableTableHead, layoutMode, mantineTableProps, memoMode, }, refs: { tableContainerRef }, } = table;\n    const { columnPinning, columnSizing, columnSizingInfo, columnVisibility, density, } = getState();\n    const tableProps = mantineTableProps instanceof Function\n        ? mantineTableProps({ table })\n        : mantineTableProps;\n    const vProps = columnVirtualizerProps instanceof Function\n        ? columnVirtualizerProps({ table })\n        : columnVirtualizerProps;\n    const columnSizeVars = react.useMemo(() => {\n        const headers = getFlatHeaders();\n        const colSizes = {};\n        for (let i = 0; i < headers.length; i++) {\n            const header = headers[i];\n            const colSize = header.getSize();\n            colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;\n            colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;\n        }\n        return colSizes;\n    }, [columns, columnSizing, columnSizingInfo, columnVisibility]);\n    //get first 16 column widths and average them\n    const averageColumnWidth = react.useMemo(() => {\n        var _a, _b, _c, _d;\n        if (!enableColumnVirtualization)\n            return 0;\n        const columnsWidths = (_d = (_c = (_b = (_a = table\n            .getRowModel()\n            .rows[0]) === null || _a === void 0 ? void 0 : _a.getCenterVisibleCells()) === null || _b === void 0 ? void 0 : _b.slice(0, 16)) === null || _c === void 0 ? void 0 : _c.map((cell) => cell.column.getSize() * 1.2)) !== null && _d !== void 0 ? _d : [];\n        return columnsWidths.reduce((a, b) => a + b, 0) / columnsWidths.length;\n    }, [table.getRowModel().rows, columnPinning, columnVisibility]);\n    const [leftPinnedIndexes, rightPinnedIndexes] = react.useMemo(() => enableColumnVirtualization && enablePinning\n        ? [\n            table.getLeftLeafColumns().map((c) => c.getPinnedIndex()),\n            table\n                .getRightLeafColumns()\n                .map((c) => table.getVisibleLeafColumns().length - c.getPinnedIndex() - 1),\n        ]\n        : [[], []], [columnPinning, enableColumnVirtualization, enablePinning]);\n    const columnVirtualizer = enableColumnVirtualization\n        ? reactVirtual.useVirtualizer(Object.assign({ count: table.getVisibleLeafColumns().length, estimateSize: () => averageColumnWidth, getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: react.useCallback((range) => [\n                ...new Set([\n                    ...leftPinnedIndexes,\n                    ...reactVirtual.defaultRangeExtractor(range),\n                    ...rightPinnedIndexes,\n                ]),\n            ], [leftPinnedIndexes, rightPinnedIndexes]) }, vProps))\n        : undefined;\n    if (columnVirtualizerInstanceRef && columnVirtualizer) {\n        columnVirtualizerInstanceRef.current = columnVirtualizer;\n    }\n    const virtualColumns = columnVirtualizer\n        ? columnVirtualizer.getVirtualItems()\n        : undefined;\n    let virtualPaddingLeft;\n    let virtualPaddingRight;\n    if (columnVirtualizer && (virtualColumns === null || virtualColumns === void 0 ? void 0 : virtualColumns.length)) {\n        virtualPaddingLeft = (_b = (_a = virtualColumns[leftPinnedIndexes.length]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0;\n        virtualPaddingRight =\n            columnVirtualizer.getTotalSize() -\n                ((_d = (_c = virtualColumns[virtualColumns.length - 1 - rightPinnedIndexes.length]) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : 0);\n    }\n    const props = {\n        columnVirtualizer,\n        enableHover: tableProps === null || tableProps === void 0 ? void 0 : tableProps.highlightOnHover,\n        isStriped: tableProps === null || tableProps === void 0 ? void 0 : tableProps.striped,\n        table,\n        virtualColumns,\n        virtualPaddingLeft,\n        virtualPaddingRight,\n    };\n    return (jsxRuntime.jsxs(core.Table, Object.assign({ highlightOnHover: true, horizontalSpacing: density, verticalSpacing: density }, tableProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table', tableLayout: layoutMode !== 'grid' && enableColumnResizing ? 'fixed' : undefined, '& tr:first-of-type td': {\n                borderTop: `1px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 8 : 3]}`,\n            }, '& tr:last-of-type td': {\n                borderBottom: `1px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 8 : 3]}`,\n            } }, ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx) instanceof Function\n            ? tableProps.sx(theme)\n            : tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx))), style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), children: [enableTableHead && jsxRuntime.jsx(MRT_TableHead, Object.assign({}, props)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? (jsxRuntime.jsx(Memo_MRT_TableBody, Object.assign({}, props))) : (jsxRuntime.jsx(MRT_TableBody, Object.assign({}, props))), enableTableFooter && jsxRuntime.jsx(MRT_TableFooter, Object.assign({}, props))] })));\n};\n\nconst MRT_EditRowModal = ({ open, table, }) => {\n    var _a;\n    const { getState, options: { onEditingRowCancel, onCreatingRowCancel, renderEditRowModalContent, renderCreateRowModalContent, mantineCreateRowModalProps, mantineEditRowModalProps, }, setEditingRow, setCreatingRow, } = table;\n    const { creatingRow, editingRow } = getState();\n    const row = (creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow);\n    const createModalProps = mantineCreateRowModalProps instanceof Function\n        ? mantineCreateRowModalProps({ row, table })\n        : mantineCreateRowModalProps;\n    const editModalProps = mantineEditRowModalProps instanceof Function\n        ? mantineEditRowModalProps({ row, table })\n        : mantineEditRowModalProps;\n    const modalProps = Object.assign(Object.assign({}, editModalProps), (creatingRow && createModalProps));\n    const internalEditComponents = row\n        .getAllCells()\n        .filter((cell) => cell.column.columnDef.columnDefType === 'data')\n        .map((cell) => (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table }, cell.id)));\n    const handleCancel = () => {\n        var _a;\n        if (creatingRow) {\n            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });\n            setCreatingRow(null);\n        }\n        else {\n            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });\n            setEditingRow(null);\n        }\n        row._valuesCache = {}; //reset values cache\n        (_a = modalProps.onClose) === null || _a === void 0 ? void 0 : _a.call(modalProps);\n    };\n    return (react.createElement(core.Modal, Object.assign({ opened: open, withCloseButton: false }, modalProps, { onClose: handleCancel, key: row.id }), (_a = ((creatingRow &&\n        (renderCreateRowModalContent === null || renderCreateRowModalContent === void 0 ? void 0 : renderCreateRowModalContent({\n            row,\n            table,\n            internalEditComponents,\n        }))) ||\n        (renderEditRowModalContent === null || renderEditRowModalContent === void 0 ? void 0 : renderEditRowModalContent({\n            row,\n            table,\n            internalEditComponents,\n        })))) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(\"form\", { onSubmit: (e) => e.preventDefault(), children: jsxRuntime.jsx(core.Stack, { sx: {\n                        gap: '24px',\n                        paddingTop: '16px',\n                        width: '100%',\n                    }, children: internalEditComponents }) }), jsxRuntime.jsx(core.Flex, { sx: { paddingTop: '24px', justifyContent: 'flex-end' }, children: jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table, variant: \"text\" }) })] }))));\n};\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;\nconst MRT_TableContainer = ({ table, }) => {\n    const { getState, options: { createDisplayMode, editDisplayMode, enableStickyHeader, mantineLoadingOverlayProps, mantineTableContainerProps, }, refs: { tableContainerRef, bottomToolbarRef, topToolbarRef }, } = table;\n    const { isFullScreen, isLoading, showLoadingOverlay, creatingRow, editingRow, } = getState();\n    const [totalToolbarHeight, setTotalToolbarHeight] = react.useState(0);\n    const tableContainerProps = mantineTableContainerProps instanceof Function\n        ? mantineTableContainerProps({ table })\n        : mantineTableContainerProps;\n    const loadingOverlayProps = mantineLoadingOverlayProps instanceof Function\n        ? mantineLoadingOverlayProps({ table })\n        : mantineLoadingOverlayProps;\n    useIsomorphicLayoutEffect(() => {\n        var _a, _b, _c, _d;\n        const topToolbarHeight = typeof document !== 'undefined'\n            ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0\n            : 0;\n        const bottomToolbarHeight = typeof document !== 'undefined'\n            ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0\n            : 0;\n        setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);\n    });\n    const createModalOpen = createDisplayMode === 'modal' && creatingRow;\n    const editModalOpen = editDisplayMode === 'modal' && editingRow;\n    return (jsxRuntime.jsxs(core.Box, Object.assign({}, tableContainerProps, { ref: (node) => {\n            if (node) {\n                tableContainerRef.current = node;\n                if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {\n                    //@ts-ignore\n                    tableContainerProps.ref.current = node;\n                }\n            }\n        }, sx: (theme) => (Object.assign({ maxWidth: '100%', maxHeight: enableStickyHeader\n                ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)`\n                : undefined, overflow: 'auto', position: 'relative' }, ((tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx) instanceof Function\n            ? tableContainerProps.sx(theme)\n            : tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx))), style: Object.assign({ maxHeight: isFullScreen\n                ? `calc(100vh - ${totalToolbarHeight}px)`\n                : undefined }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), children: [jsxRuntime.jsx(core.LoadingOverlay, Object.assign({ visible: isLoading || showLoadingOverlay }, loadingOverlayProps)), jsxRuntime.jsx(MRT_Table, { table: table }), (createModalOpen || editModalOpen) && (jsxRuntime.jsx(MRT_EditRowModal, { open: true, table: table }))] })));\n};\n\nconst MRT_TablePaper = ({ table, }) => {\n    const { getState, options: { enableBottomToolbar, enableTopToolbar, mantinePaperProps, renderBottomToolbar, renderTopToolbar, }, refs: { tablePaperRef }, } = table;\n    const { isFullScreen } = getState();\n    const tablePaperProps = mantinePaperProps instanceof Function\n        ? mantinePaperProps({ table })\n        : mantinePaperProps;\n    return (jsxRuntime.jsxs(core.Paper, Object.assign({ shadow: \"xs\", withBorder: true }, tablePaperProps, { ref: (ref) => {\n            tablePaperRef.current = ref;\n            if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {\n                tablePaperProps.ref.current = ref;\n            }\n        }, sx: (theme) => (Object.assign({ overflow: 'hidden', transition: 'all 100ms ease-in-out' }, ((tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx) instanceof Function\n            ? tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx(theme)\n            : tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx))), style: Object.assign(Object.assign({}, (isFullScreen\n            ? {\n                bottom: 0,\n                height: '100vh',\n                left: 0,\n                margin: 0,\n                maxHeight: '100vh',\n                maxWidth: '100vw',\n                padding: 0,\n                position: 'fixed',\n                right: 0,\n                top: 0,\n                width: '100vw',\n                zIndex: 100,\n            }\n            : {})), tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style), children: [enableTopToolbar &&\n                (renderTopToolbar instanceof Function\n                    ? renderTopToolbar({ table })\n                    : renderTopToolbar !== null && renderTopToolbar !== void 0 ? renderTopToolbar : jsxRuntime.jsx(MRT_TopToolbar, { table: table })), jsxRuntime.jsx(MRT_TableContainer, { table: table }), enableBottomToolbar &&\n                (renderBottomToolbar instanceof Function\n                    ? renderBottomToolbar({ table })\n                    : renderBottomToolbar !== null && renderBottomToolbar !== void 0 ? renderBottomToolbar : jsxRuntime.jsx(MRT_BottomToolbar, { table: table }))] })));\n};\n\nconst isTableInstanceProp = (props) => props.table !== undefined;\nconst MantineReactTable = (props) => {\n    let table;\n    if (isTableInstanceProp(props)) {\n        table = props.table;\n    }\n    else {\n        table = useMantineReactTable(props);\n    }\n    return jsxRuntime.jsx(MRT_TablePaper, { table: table });\n};\n\nexports.MRT_AggregationFns = MRT_AggregationFns;\nexports.MRT_BottomToolbar = MRT_BottomToolbar;\nexports.MRT_ColumnActionMenu = MRT_ColumnActionMenu;\nexports.MRT_ColumnPinningButtons = MRT_ColumnPinningButtons;\nexports.MRT_CopyButton = MRT_CopyButton;\nexports.MRT_DefaultColumn = MRT_DefaultColumn;\nexports.MRT_DefaultDisplayColumn = MRT_DefaultDisplayColumn;\nexports.MRT_EditActionButtons = MRT_EditActionButtons;\nexports.MRT_EditCellTextInput = MRT_EditCellTextInput;\nexports.MRT_EditRowModal = MRT_EditRowModal;\nexports.MRT_ExpandAllButton = MRT_ExpandAllButton;\nexports.MRT_ExpandButton = MRT_ExpandButton;\nexports.MRT_FilterCheckbox = MRT_FilterCheckbox;\nexports.MRT_FilterFns = MRT_FilterFns;\nexports.MRT_FilterOptionMenu = MRT_FilterOptionMenu;\nexports.MRT_FilterRangeFields = MRT_FilterRangeFields;\nexports.MRT_FilterTextInput = MRT_FilterTextInput;\nexports.MRT_GlobalFilterTextInput = MRT_GlobalFilterTextInput;\nexports.MRT_GrabHandleButton = MRT_GrabHandleButton;\nexports.MRT_ProgressBar = MRT_ProgressBar;\nexports.MRT_RowActionMenu = MRT_RowActionMenu;\nexports.MRT_SelectCheckbox = MRT_SelectCheckbox;\nexports.MRT_ShowHideColumnsButton = MRT_ShowHideColumnsButton;\nexports.MRT_ShowHideColumnsMenu = MRT_ShowHideColumnsMenu;\nexports.MRT_ShowHideColumnsMenuItems = MRT_ShowHideColumnsMenuItems;\nexports.MRT_SortingFns = MRT_SortingFns;\nexports.MRT_Table = MRT_Table;\nexports.MRT_TableBody = MRT_TableBody;\nexports.MRT_TableBodyCell = MRT_TableBodyCell;\nexports.MRT_TableBodyCellValue = MRT_TableBodyCellValue;\nexports.MRT_TableBodyRow = MRT_TableBodyRow;\nexports.MRT_TableBodyRowGrabHandle = MRT_TableBodyRowGrabHandle;\nexports.MRT_TableContainer = MRT_TableContainer;\nexports.MRT_TableDetailPanel = MRT_TableDetailPanel;\nexports.MRT_TableFooter = MRT_TableFooter;\nexports.MRT_TableFooterCell = MRT_TableFooterCell;\nexports.MRT_TableFooterRow = MRT_TableFooterRow;\nexports.MRT_TableHead = MRT_TableHead;\nexports.MRT_TableHeadCell = MRT_TableHeadCell;\nexports.MRT_TableHeadCellFilterContainer = MRT_TableHeadCellFilterContainer;\nexports.MRT_TableHeadCellFilterLabel = MRT_TableHeadCellFilterLabel;\nexports.MRT_TableHeadCellGrabHandle = MRT_TableHeadCellGrabHandle;\nexports.MRT_TableHeadCellResizeHandle = MRT_TableHeadCellResizeHandle;\nexports.MRT_TableHeadCellSortLabel = MRT_TableHeadCellSortLabel;\nexports.MRT_TableHeadRow = MRT_TableHeadRow;\nexports.MRT_TablePagination = MRT_TablePagination;\nexports.MRT_TablePaper = MRT_TablePaper;\nexports.MRT_ToggleDensePaddingButton = MRT_ToggleDensePaddingButton;\nexports.MRT_ToggleFiltersButton = MRT_ToggleFiltersButton;\nexports.MRT_ToggleFullScreenButton = MRT_ToggleFullScreenButton;\nexports.MRT_ToggleGlobalFilterButton = MRT_ToggleGlobalFilterButton;\nexports.MRT_ToggleRowActionMenuButton = MRT_ToggleRowActionMenuButton;\nexports.MRT_ToolbarAlertBanner = MRT_ToolbarAlertBanner;\nexports.MRT_ToolbarDropZone = MRT_ToolbarDropZone;\nexports.MRT_ToolbarInternalButtons = MRT_ToolbarInternalButtons;\nexports.MRT_TopToolbar = MRT_TopToolbar;\nexports.MantineReactTable = MantineReactTable;\nexports.Memo_MRT_TableBody = Memo_MRT_TableBody;\nexports.Memo_MRT_TableBodyCell = Memo_MRT_TableBodyCell;\nexports.Memo_MRT_TableBodyRow = Memo_MRT_TableBodyRow;\nexports.commonToolbarStyles = commonToolbarStyles;\nexports.createRow = createRow;\nexports.flexRender = flexRender;\nexports.getAllLeafColumnDefs = getAllLeafColumnDefs;\nexports.getCanRankRows = getCanRankRows;\nexports.getColumnId = getColumnId;\nexports.getCommonCellStyles = getCommonCellStyles;\nexports.getDefaultColumnFilterFn = getDefaultColumnFilterFn;\nexports.getDefaultColumnOrderIds = getDefaultColumnOrderIds;\nexports.getIsFirstColumn = getIsFirstColumn;\nexports.getIsFirstRightPinnedColumn = getIsFirstRightPinnedColumn;\nexports.getIsLastColumn = getIsLastColumn;\nexports.getIsLastLeftPinnedColumn = getIsLastLeftPinnedColumn;\nexports.getLeadingDisplayColumnIds = getLeadingDisplayColumnIds;\nexports.getPrimaryColor = getPrimaryColor;\nexports.getPrimaryShade = getPrimaryShade;\nexports.getTotalRight = getTotalRight;\nexports.getTrailingDisplayColumnIds = getTrailingDisplayColumnIds;\nexports.mrtFilterOptions = mrtFilterOptions;\nexports.parseCSSVarId = parseCSSVarId;\nexports.prepareColumns = prepareColumns;\nexports.rankGlobalFuzzy = rankGlobalFuzzy;\nexports.reorderColumn = reorderColumn;\nexports.showExpandColumn = showExpandColumn;\nexports.useMantineReactTable = useMantineReactTable;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFudGluZS1yZWFjdC10YWJsZS9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxtSUFBbUI7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQywwR0FBOEI7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsb0dBQXFCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNwRCxXQUFXLG1CQUFPLENBQUMsc0VBQWU7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLHdFQUFnQjtBQUNwQyxZQUFZLG1CQUFPLENBQUMsd0VBQWdCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGNBQWM7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FubG5jZzQvLi9ub2RlX21vZHVsZXMvbWFudGluZS1yZWFjdC10YWJsZS9kaXN0L2Nqcy9pbmRleC5qcz8xNDhiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGpzeFJ1bnRpbWUgPSByZXF1aXJlKCdyZWFjdC9qc3gtcnVudGltZScpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByZWFjdFRhYmxlID0gcmVxdWlyZSgnQHRhbnN0YWNrL3JlYWN0LXRhYmxlJyk7XG52YXIgbWF0Y2hTb3J0ZXJVdGlscyA9IHJlcXVpcmUoJ0B0YW5zdGFjay9tYXRjaC1zb3J0ZXItdXRpbHMnKTtcbnZhciBpY29uc1JlYWN0ID0gcmVxdWlyZSgnQHRhYmxlci9pY29ucy1yZWFjdCcpO1xudmFyIHJlYWN0VmlydHVhbCA9IHJlcXVpcmUoJ0B0YW5zdGFjay9yZWFjdC12aXJ0dWFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BtYW50aW5lL2NvcmUnKTtcbnZhciBob29rcyA9IHJlcXVpcmUoJ0BtYW50aW5lL2hvb2tzJyk7XG52YXIgZGF0ZXMgPSByZXF1aXJlKCdAbWFudGluZS9kYXRlcycpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xuXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5jb25zdCBNUlRfQWdncmVnYXRpb25GbnMgPSBPYmplY3QuYXNzaWduKHt9LCByZWFjdFRhYmxlLmFnZ3JlZ2F0aW9uRm5zKTtcblxuY29uc3QgZnV6enkkMSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSwgYWRkTWV0YSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1SYW5rID0gbWF0Y2hTb3J0ZXJVdGlscy5yYW5rSXRlbShyb3cuZ2V0VmFsdWUoY29sdW1uSWQpLCBmaWx0ZXJWYWx1ZSwge1xuICAgICAgICB0aHJlc2hvbGQ6IG1hdGNoU29ydGVyVXRpbHMucmFua2luZ3MuTUFUQ0hFUyxcbiAgICB9KTtcbiAgICBhZGRNZXRhKGl0ZW1SYW5rKTtcbiAgICByZXR1cm4gaXRlbVJhbmsucGFzc2VkO1xufTtcbmZ1enp5JDEuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBjb250YWlucyA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4gcm93XG4gICAgLmdldFZhbHVlKGlkKVxuICAgIC50b1N0cmluZygpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAudHJpbSgpXG4gICAgLmluY2x1ZGVzKGZpbHRlclZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkpO1xuY29udGFpbnMuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBzdGFydHNXaXRoID0gKHJvdywgaWQsIGZpbHRlclZhbHVlKSA9PiByb3dcbiAgICAuZ2V0VmFsdWUoaWQpXG4gICAgLnRvU3RyaW5nKClcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC50cmltKClcbiAgICAuc3RhcnRzV2l0aChmaWx0ZXJWYWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcbnN0YXJ0c1dpdGguYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBlbmRzV2l0aCA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4gcm93XG4gICAgLmdldFZhbHVlKGlkKVxuICAgIC50b1N0cmluZygpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAudHJpbSgpXG4gICAgLmVuZHNXaXRoKGZpbHRlclZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkpO1xuZW5kc1dpdGguYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBlcXVhbHMgPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IGZpbHRlclZhbHVlID09PSBudWxsXG4gICAgPyB0cnVlXG4gICAgOiByb3cuZ2V0VmFsdWUoaWQpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkgPT09XG4gICAgICAgIGZpbHRlclZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG5lcXVhbHMuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBub3RFcXVhbHMgPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IHJvdy5nZXRWYWx1ZShpZCkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSAhPT1cbiAgICBmaWx0ZXJWYWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xubm90RXF1YWxzLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgZ3JlYXRlclRoYW4gPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IGZpbHRlclZhbHVlID09PSBudWxsXG4gICAgPyB0cnVlXG4gICAgOiAhaXNOYU4oK2ZpbHRlclZhbHVlKSAmJiAhaXNOYU4oK3Jvdy5nZXRWYWx1ZShpZCkpXG4gICAgICAgID8gK3Jvdy5nZXRWYWx1ZShpZCkgPiArZmlsdGVyVmFsdWVcbiAgICAgICAgOiByb3cuZ2V0VmFsdWUoaWQpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkgPlxuICAgICAgICAgICAgZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbmdyZWF0ZXJUaGFuLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgZ3JlYXRlclRoYW5PckVxdWFsVG8gPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IGVxdWFscyhyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgfHwgZ3JlYXRlclRoYW4ocm93LCBpZCwgZmlsdGVyVmFsdWUpO1xuZ3JlYXRlclRoYW5PckVxdWFsVG8uYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBsZXNzVGhhbiA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4gZmlsdGVyVmFsdWUgPT09IG51bGxcbiAgICA/IHRydWVcbiAgICA6ICFpc05hTigrZmlsdGVyVmFsdWUpICYmICFpc05hTigrcm93LmdldFZhbHVlKGlkKSlcbiAgICAgICAgPyArcm93LmdldFZhbHVlKGlkKSA8ICtmaWx0ZXJWYWx1ZVxuICAgICAgICA6IHJvdy5nZXRWYWx1ZShpZCkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSA8XG4gICAgICAgICAgICBmaWx0ZXJWYWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xubGVzc1RoYW4uYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBsZXNzVGhhbk9yRXF1YWxUbyA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4gZXF1YWxzKHJvdywgaWQsIGZpbHRlclZhbHVlKSB8fCBsZXNzVGhhbihyb3csIGlkLCBmaWx0ZXJWYWx1ZSk7XG5sZXNzVGhhbk9yRXF1YWxUby5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGJldHdlZW4gPSAocm93LCBpZCwgZmlsdGVyVmFsdWVzKSA9PiAoWycnLCB1bmRlZmluZWRdLmluY2x1ZGVzKGZpbHRlclZhbHVlc1swXSkgfHxcbiAgICBncmVhdGVyVGhhbihyb3csIGlkLCBmaWx0ZXJWYWx1ZXNbMF0pKSAmJlxuICAgICgoIWlzTmFOKCtmaWx0ZXJWYWx1ZXNbMF0pICYmXG4gICAgICAgICFpc05hTigrZmlsdGVyVmFsdWVzWzFdKSAmJlxuICAgICAgICArZmlsdGVyVmFsdWVzWzBdID4gK2ZpbHRlclZhbHVlc1sxXSkgfHxcbiAgICAgICAgWycnLCB1bmRlZmluZWRdLmluY2x1ZGVzKGZpbHRlclZhbHVlc1sxXSkgfHxcbiAgICAgICAgbGVzc1RoYW4ocm93LCBpZCwgZmlsdGVyVmFsdWVzWzFdKSk7XG5iZXR3ZWVuLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgYmV0d2VlbkluY2x1c2l2ZSA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZXMpID0+IChbJycsIHVuZGVmaW5lZF0uaW5jbHVkZXMoZmlsdGVyVmFsdWVzWzBdKSB8fFxuICAgIGdyZWF0ZXJUaGFuT3JFcXVhbFRvKHJvdywgaWQsIGZpbHRlclZhbHVlc1swXSkpICYmXG4gICAgKCghaXNOYU4oK2ZpbHRlclZhbHVlc1swXSkgJiZcbiAgICAgICAgIWlzTmFOKCtmaWx0ZXJWYWx1ZXNbMV0pICYmXG4gICAgICAgICtmaWx0ZXJWYWx1ZXNbMF0gPiArZmlsdGVyVmFsdWVzWzFdKSB8fFxuICAgICAgICBbJycsIHVuZGVmaW5lZF0uaW5jbHVkZXMoZmlsdGVyVmFsdWVzWzFdKSB8fFxuICAgICAgICBsZXNzVGhhbk9yRXF1YWxUbyhyb3csIGlkLCBmaWx0ZXJWYWx1ZXNbMV0pKTtcbmJldHdlZW5JbmNsdXNpdmUuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBlbXB0eSA9IChyb3csIGlkLCBfZmlsdGVyVmFsdWUpID0+ICFyb3cuZ2V0VmFsdWUoaWQpLnRvU3RyaW5nKCkudHJpbSgpO1xuZW1wdHkuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBub3RFbXB0eSA9IChyb3csIGlkLCBfZmlsdGVyVmFsdWUpID0+ICEhcm93LmdldFZhbHVlKGlkKS50b1N0cmluZygpLnRyaW0oKTtcbm5vdEVtcHR5LmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgTVJUX0ZpbHRlckZucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVhY3RUYWJsZS5maWx0ZXJGbnMpLCB7IGJldHdlZW4sXG4gICAgYmV0d2VlbkluY2x1c2l2ZSxcbiAgICBjb250YWlucyxcbiAgICBlbXB0eSxcbiAgICBlbmRzV2l0aCxcbiAgICBlcXVhbHMsXG4gICAgZnV6enk6IGZ1enp5JDEsXG4gICAgZ3JlYXRlclRoYW4sXG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG8sXG4gICAgbGVzc1RoYW4sXG4gICAgbGVzc1RoYW5PckVxdWFsVG8sXG4gICAgbm90RW1wdHksXG4gICAgbm90RXF1YWxzLFxuICAgIHN0YXJ0c1dpdGggfSk7XG5cbmNvbnN0IGZ1enp5ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gICAgbGV0IGRpciA9IDA7XG4gICAgaWYgKHJvd0EuY29sdW1uRmlsdGVyc01ldGFbY29sdW1uSWRdKSB7XG4gICAgICAgIGRpciA9IG1hdGNoU29ydGVyVXRpbHMuY29tcGFyZUl0ZW1zKHJvd0EuY29sdW1uRmlsdGVyc01ldGFbY29sdW1uSWRdLCByb3dCLmNvbHVtbkZpbHRlcnNNZXRhW2NvbHVtbklkXSk7XG4gICAgfVxuICAgIC8vIFByb3ZpZGUgYSBmYWxsYmFjayBmb3Igd2hlbiB0aGUgaXRlbSByYW5rcyBhcmUgZXF1YWxcbiAgICByZXR1cm4gZGlyID09PSAwXG4gICAgICAgID8gcmVhY3RUYWJsZS5zb3J0aW5nRm5zLmFscGhhbnVtZXJpYyhyb3dBLCByb3dCLCBjb2x1bW5JZClcbiAgICAgICAgOiBkaXI7XG59O1xuY29uc3QgTVJUX1NvcnRpbmdGbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWN0VGFibGUuc29ydGluZ0ZucyksIHsgZnV6enkgfSk7XG5jb25zdCByYW5rR2xvYmFsRnV6enkgPSAocm93QSwgcm93QikgPT4gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhyb3dCLmNvbHVtbkZpbHRlcnNNZXRhKS5tYXAoKHYpID0+IHYucmFuaykpIC1cbiAgICBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHJvd0EuY29sdW1uRmlsdGVyc01ldGEpLm1hcCgodikgPT4gdi5yYW5rKSk7XG5cbmNvbnN0IGdldENvbHVtbklkID0gKGNvbHVtbkRlZikgPT4geyB2YXIgX2EsIF9iLCBfYywgX2Q7IHJldHVybiAoX2QgPSAoX2EgPSBjb2x1bW5EZWYuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGNvbHVtbkRlZi5hY2Nlc3NvcktleSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYikpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbHVtbkRlZi5oZWFkZXI7IH07XG5jb25zdCBnZXRBbGxMZWFmQ29sdW1uRGVmcyA9IChjb2x1bW5zKSA9PiB7XG4gICAgY29uc3QgYWxsTGVhZkNvbHVtbkRlZnMgPSBbXTtcbiAgICBjb25zdCBnZXRMZWFmQ29sdW1ucyA9IChjb2xzKSA9PiB7XG4gICAgICAgIGNvbHMuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBnZXRMZWFmQ29sdW1ucyhjb2wuY29sdW1ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGxMZWFmQ29sdW1uRGVmcy5wdXNoKGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZ2V0TGVhZkNvbHVtbnMoY29sdW1ucyk7XG4gICAgcmV0dXJuIGFsbExlYWZDb2x1bW5EZWZzO1xufTtcbmNvbnN0IHByZXBhcmVDb2x1bW5zID0gKHsgYWdncmVnYXRpb25GbnMsIGNvbHVtbkRlZnMsIGNvbHVtbkZpbHRlckZucywgZGVmYXVsdERpc3BsYXlDb2x1bW4sIGZpbHRlckZucywgc29ydGluZ0ZucywgfSkgPT4gY29sdW1uRGVmcy5tYXAoKGNvbHVtbkRlZikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy9hc3NpZ24gY29sdW1uSWRcbiAgICBpZiAoIWNvbHVtbkRlZi5pZClcbiAgICAgICAgY29sdW1uRGVmLmlkID0gZ2V0Q29sdW1uSWQoY29sdW1uRGVmKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29sdW1uRGVmLmlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbHVtbiBkZWZpbml0aW9ucyBtdXN0IGhhdmUgYSB2YWxpZCBgYWNjZXNzb3JLZXlgIG9yIGBpZGAgcHJvcGVydHknKTtcbiAgICB9XG4gICAgLy9hc3NpZ24gY29sdW1uRGVmVHlwZVxuICAgIGlmICghY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUpXG4gICAgICAgIGNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID0gJ2RhdGEnO1xuICAgIGlmICgoX2EgPSBjb2x1bW5EZWYuY29sdW1ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICBjb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9ICdncm91cCc7XG4gICAgICAgIC8vcmVjdXJzaXZlbHkgcHJlcGFyZSBjb2x1bW5zIGlmIHRoaXMgaXMgYSBncm91cCBjb2x1bW5cbiAgICAgICAgY29sdW1uRGVmLmNvbHVtbnMgPSBwcmVwYXJlQ29sdW1ucyh7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbkZucyxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IGNvbHVtbkRlZi5jb2x1bW5zLFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyRm5zLFxuICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlDb2x1bW4sXG4gICAgICAgICAgICBmaWx0ZXJGbnMsXG4gICAgICAgICAgICBzb3J0aW5nRm5zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAvL2Fzc2lnbiBhZ2dyZWdhdGlvbkZucyBpZiBtdWx0aXBsZSBhZ2dyZWdhdGlvbkZucyBhcmUgcHJvdmlkZWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4pKSB7XG4gICAgICAgICAgICBjb25zdCBhZ2dGbnMgPSBjb2x1bW5EZWYuYWdncmVnYXRpb25GbjtcbiAgICAgICAgICAgIGNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuID0gKGNvbHVtbklkLCBsZWFmUm93cywgY2hpbGRSb3dzKSA9PiBhZ2dGbnMubWFwKChmbikgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBhZ2dyZWdhdGlvbkZuc1tmbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFnZ3JlZ2F0aW9uRm5zLCBjb2x1bW5JZCwgbGVhZlJvd3MsIGNoaWxkUm93cyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vYXNzaWduIGZpbHRlckZuc1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyRm5zKS5pbmNsdWRlcyhjb2x1bW5GaWx0ZXJGbnNbY29sdW1uRGVmLmlkXSkpIHtcbiAgICAgICAgICAgIGNvbHVtbkRlZi5maWx0ZXJGbiA9XG4gICAgICAgICAgICAgICAgKF9iID0gZmlsdGVyRm5zW2NvbHVtbkZpbHRlckZuc1tjb2x1bW5EZWYuaWRdXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmlsdGVyRm5zLmZ1enp5O1xuICAgICAgICAgICAgY29sdW1uRGVmLl9maWx0ZXJGbiA9XG4gICAgICAgICAgICAgICAgY29sdW1uRmlsdGVyRm5zW2NvbHVtbkRlZi5pZF07XG4gICAgICAgIH1cbiAgICAgICAgLy9hc3NpZ24gc29ydGluZ0Zuc1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc29ydGluZ0ZucykuaW5jbHVkZXMoY29sdW1uRGVmLnNvcnRpbmdGbikpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbHVtbkRlZi5zb3J0aW5nRm4gPSBzb3J0aW5nRm5zW2NvbHVtbkRlZi5zb3J0aW5nRm5dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID09PSAnZGlzcGxheScpIHtcbiAgICAgICAgY29sdW1uRGVmID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGlzcGxheUNvbHVtbiksIGNvbHVtbkRlZik7XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW5EZWY7XG59KTtcbmNvbnN0IHJlb3JkZXJDb2x1bW4gPSAoZHJhZ2dlZENvbHVtbiwgdGFyZ2V0Q29sdW1uLCBjb2x1bW5PcmRlcikgPT4ge1xuICAgIGlmIChkcmFnZ2VkQ29sdW1uLmdldENhblBpbigpKSB7XG4gICAgICAgIGRyYWdnZWRDb2x1bW4ucGluKHRhcmdldENvbHVtbi5nZXRJc1Bpbm5lZCgpKTtcbiAgICB9XG4gICAgY29sdW1uT3JkZXIuc3BsaWNlKGNvbHVtbk9yZGVyLmluZGV4T2YodGFyZ2V0Q29sdW1uLmlkKSwgMCwgY29sdW1uT3JkZXIuc3BsaWNlKGNvbHVtbk9yZGVyLmluZGV4T2YoZHJhZ2dlZENvbHVtbi5pZCksIDEpWzBdKTtcbiAgICByZXR1cm4gWy4uLmNvbHVtbk9yZGVyXTtcbn07XG5jb25zdCBzaG93RXhwYW5kQ29sdW1uID0gKHByb3BzLCBncm91cGluZykgPT4gISEocHJvcHMuZW5hYmxlRXhwYW5kaW5nIHx8XG4gICAgKHByb3BzLmVuYWJsZUdyb3VwaW5nICYmIChncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IChncm91cGluZyA9PT0gbnVsbCB8fCBncm91cGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBpbmcubGVuZ3RoKSkpIHx8XG4gICAgcHJvcHMucmVuZGVyRGV0YWlsUGFuZWwpO1xuY29uc3QgZ2V0TGVhZGluZ0Rpc3BsYXlDb2x1bW5JZHMgPSAocHJvcHMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHByb3BzLmVuYWJsZVJvd0RyYWdnaW5nIHx8IHByb3BzLmVuYWJsZVJvd09yZGVyaW5nKSAmJiAnbXJ0LXJvdy1kcmFnJyxcbiAgICAgICAgcHJvcHMucG9zaXRpb25BY3Rpb25zQ29sdW1uID09PSAnZmlyc3QnICYmXG4gICAgICAgICAgICAocHJvcHMuZW5hYmxlUm93QWN0aW9ucyB8fFxuICAgICAgICAgICAgICAgIChwcm9wcy5lbmFibGVFZGl0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIFsncm93JywgJ21vZGFsJywgJ2N1c3RvbSddLmluY2x1ZGVzKChfYSA9IHByb3BzLmVkaXREaXNwbGF5TW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpKSkgJiZcbiAgICAgICAgICAgICdtcnQtcm93LWFjdGlvbnMnLFxuICAgICAgICBwcm9wcy5wb3NpdGlvbkV4cGFuZENvbHVtbiA9PT0gJ2ZpcnN0JyAmJlxuICAgICAgICAgICAgc2hvd0V4cGFuZENvbHVtbihwcm9wcykgJiZcbiAgICAgICAgICAgICdtcnQtcm93LWV4cGFuZCcsXG4gICAgICAgIHByb3BzLmVuYWJsZVJvd1NlbGVjdGlvbiAmJiAnbXJ0LXJvdy1zZWxlY3QnLFxuICAgICAgICBwcm9wcy5lbmFibGVSb3dOdW1iZXJzICYmICdtcnQtcm93LW51bWJlcnMnLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xufTtcbmNvbnN0IGdldFRyYWlsaW5nRGlzcGxheUNvbHVtbklkcyA9IChwcm9wcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwcm9wcy5wb3NpdGlvbkFjdGlvbnNDb2x1bW4gPT09ICdsYXN0JyAmJlxuICAgICAgICAgICAgKHByb3BzLmVuYWJsZVJvd0FjdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAocHJvcHMuZW5hYmxlRWRpdGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBbJ3JvdycsICdtb2RhbCddLmluY2x1ZGVzKChfYSA9IHByb3BzLmVkaXREaXNwbGF5TW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpKSkgJiZcbiAgICAgICAgICAgICdtcnQtcm93LWFjdGlvbnMnLFxuICAgICAgICBwcm9wcy5wb3NpdGlvbkV4cGFuZENvbHVtbiA9PT0gJ2xhc3QnICYmXG4gICAgICAgICAgICBzaG93RXhwYW5kQ29sdW1uKHByb3BzKSAmJlxuICAgICAgICAgICAgJ21ydC1yb3ctZXhwYW5kJyxcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbn07XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHMgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBsZWFkaW5nRGlzcGxheUNvbHMgPSBnZXRMZWFkaW5nRGlzcGxheUNvbHVtbklkcyhwcm9wcyk7XG4gICAgY29uc3QgdHJhaWxpbmdEaXNwbGF5Q29scyA9IGdldFRyYWlsaW5nRGlzcGxheUNvbHVtbklkcyhwcm9wcyk7XG4gICAgY29uc3QgYWxsTGVhZkNvbHVtbkRlZnMgPSBnZXRBbGxMZWFmQ29sdW1uRGVmcyhwcm9wcy5jb2x1bW5zKVxuICAgICAgICAubWFwKChjb2x1bW5EZWYpID0+IGdldENvbHVtbklkKGNvbHVtbkRlZikpXG4gICAgICAgIC5maWx0ZXIoKGNvbHVtbklkKSA9PiAhbGVhZGluZ0Rpc3BsYXlDb2xzLmluY2x1ZGVzKGNvbHVtbklkKSAmJlxuICAgICAgICAhdHJhaWxpbmdEaXNwbGF5Q29scy5pbmNsdWRlcyhjb2x1bW5JZCkpO1xuICAgIHJldHVybiBbLi4ubGVhZGluZ0Rpc3BsYXlDb2xzLCAuLi5hbGxMZWFmQ29sdW1uRGVmcywgLi4udHJhaWxpbmdEaXNwbGF5Q29sc107XG59O1xuY29uc3QgZ2V0RGVmYXVsdENvbHVtbkZpbHRlckZuID0gKGNvbHVtbkRlZikgPT4ge1xuICAgIGNvbnN0IHsgZmlsdGVyVmFyaWFudCB9ID0gY29sdW1uRGVmO1xuICAgIGlmIChmaWx0ZXJWYXJpYW50ID09PSAnbXVsdGktc2VsZWN0JylcbiAgICAgICAgcmV0dXJuICdhcnJJbmNsdWRlc1NvbWUnO1xuICAgIGlmIChbJ3JhbmdlJywgJ2RhdGUtcmFuZ2UnLCAncmFuZ2Utc2xpZGVyJ10uaW5jbHVkZXMoZmlsdGVyVmFyaWFudCB8fCAnJykpXG4gICAgICAgIHJldHVybiAnYmV0d2VlbkluY2x1c2l2ZSc7XG4gICAgaWYgKFsnc2VsZWN0JywgJ2NoZWNrYm94JywgJ2RhdGUnXS5pbmNsdWRlcyhmaWx0ZXJWYXJpYW50IHx8ICcnKSlcbiAgICAgICAgcmV0dXJuICdlcXVhbHMnO1xuICAgIHJldHVybiAnZnV6enknO1xufTtcbmNvbnN0IGdldElzRmlyc3RDb2x1bW4gPSAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIHJldHVybiB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKVswXS5pZCA9PT0gY29sdW1uLmlkO1xufTtcbmNvbnN0IGdldElzTGFzdENvbHVtbiA9IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29uc3QgY29sdW1ucyA9IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpO1xuICAgIHJldHVybiBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0uaWQgPT09IGNvbHVtbi5pZDtcbn07XG5jb25zdCBnZXRJc0xhc3RMZWZ0UGlubmVkQ29sdW1uID0gKHRhYmxlLCBjb2x1bW4pID0+IHtcbiAgICByZXR1cm4gKGNvbHVtbi5nZXRJc1Bpbm5lZCgpID09PSAnbGVmdCcgJiZcbiAgICAgICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzKCkubGVuZ3RoIC0gMSA9PT0gY29sdW1uLmdldFBpbm5lZEluZGV4KCkpO1xufTtcbmNvbnN0IGdldElzRmlyc3RSaWdodFBpbm5lZENvbHVtbiA9IChjb2x1bW4pID0+IHtcbiAgICByZXR1cm4gY29sdW1uLmdldElzUGlubmVkKCkgPT09ICdyaWdodCcgJiYgY29sdW1uLmdldFBpbm5lZEluZGV4KCkgPT09IDA7XG59O1xuY29uc3QgZ2V0VG90YWxSaWdodCA9ICh0YWJsZSwgY29sdW1uKSA9PiB7XG4gICAgcmV0dXJuIHRhYmxlXG4gICAgICAgIC5nZXRSaWdodExlYWZIZWFkZXJzKClcbiAgICAgICAgLnNsaWNlKGNvbHVtbi5nZXRQaW5uZWRJbmRleCgpICsgMSlcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBjb2wpID0+IGFjYyArIGNvbC5nZXRTaXplKCksIDApO1xufTtcbmNvbnN0IGdldENhblJhbmtSb3dzID0gKHRhYmxlKSA9PiB7XG4gICAgY29uc3QgeyBvcHRpb25zLCBnZXRTdGF0ZSB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBtYW51YWxFeHBhbmRpbmcsIG1hbnVhbEZpbHRlcmluZywgbWFudWFsR3JvdXBpbmcsIG1hbnVhbFNvcnRpbmcsIGVuYWJsZUdsb2JhbEZpbHRlclJhbmtlZFJlc3VsdHMsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyRm4sIGV4cGFuZGVkIH0gPSBnZXRTdGF0ZSgpO1xuICAgIHJldHVybiAoIW1hbnVhbEV4cGFuZGluZyAmJlxuICAgICAgICAhbWFudWFsRmlsdGVyaW5nICYmXG4gICAgICAgICFtYW51YWxHcm91cGluZyAmJlxuICAgICAgICAhbWFudWFsU29ydGluZyAmJlxuICAgICAgICBlbmFibGVHbG9iYWxGaWx0ZXJSYW5rZWRSZXN1bHRzICYmXG4gICAgICAgIGdsb2JhbEZpbHRlckZuID09PSAnZnV6enknICYmXG4gICAgICAgIGV4cGFuZGVkICE9PSB0cnVlICYmXG4gICAgICAgICFPYmplY3QudmFsdWVzKGV4cGFuZGVkKS5zb21lKEJvb2xlYW4pKTtcbn07XG5jb25zdCBnZXRDb21tb25DZWxsU3R5bGVzID0gKHsgY29sdW1uLCBoZWFkZXIsIGlzU3RyaXBlZCwgcm93LCB0YWJsZSwgdGFibGVDZWxsUHJvcHMsIHRoZW1lLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgIGNvbnN0IHdpZHRoU3R5bGVzID0ge1xuICAgICAgICBtaW5XaWR0aDogYG1heChjYWxjKHZhcigtLSR7aGVhZGVyID8gJ2hlYWRlcicgOiAnY29sJ30tJHtwYXJzZUNTU1ZhcklkKChfYSA9IGhlYWRlciA9PT0gbnVsbCB8fCBoZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhlYWRlci5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sdW1uLmlkKX0tc2l6ZSkgKiAxcHgpLCAkeyhfYiA9IGNvbHVtbi5jb2x1bW5EZWYubWluU2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMzB9cHgpYCxcbiAgICAgICAgd2lkdGg6IGBjYWxjKHZhcigtLSR7aGVhZGVyID8gJ2hlYWRlcicgOiAnY29sJ30tJHtwYXJzZUNTU1ZhcklkKChfYyA9IGhlYWRlciA9PT0gbnVsbCB8fCBoZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhlYWRlci5pZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29sdW1uLmlkKX0tc2l6ZSkgKiAxcHgpYCxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogcm93XG4gICAgICAgICAgICA/IChyb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuZ2V0SXNTZWxlY3RlZCgpKVxuICAgICAgICAgICAgICAgID8gdGhlbWUuZm4ucmdiYShnZXRQcmltYXJ5Q29sb3IodGhlbWUpLCAwLjEpXG4gICAgICAgICAgICAgICAgOiBjb2x1bW4uZ2V0SXNQaW5uZWQoKSAmJiBjb2x1bW4uY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgIT09ICdncm91cCdcbiAgICAgICAgICAgICAgICAgICAgPyB0aGVtZS5mbi5yZ2JhKHRoZW1lLmNvbG9yU2NoZW1lID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhlbWUuZm4uZGFya2VuKHRoZW1lLmNvbG9ycy5kYXJrWzddLCAwLjAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGVtZS53aGl0ZSwgMC45NylcbiAgICAgICAgICAgICAgICAgICAgOiBpc1N0cmlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ2luaGVyaXQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoZW1lLmNvbG9yU2NoZW1lID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoZW1lLmZuLmxpZ2h0ZW4odGhlbWUuY29sb3JzLmRhcmtbN10sIDAuMDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGVtZS53aGl0ZVxuICAgICAgICAgICAgOiAnaW5oZXJpdCcsIGJhY2tncm91bmRDbGlwOiAncGFkZGluZy1ib3gnLCBib3hTaGFkb3c6IGdldElzTGFzdExlZnRQaW5uZWRDb2x1bW4odGFibGUsIGNvbHVtbilcbiAgICAgICAgICAgID8gYC00cHggMCA4cHggLTZweCAke3RoZW1lLmZuLnJnYmEodGhlbWUuYmxhY2ssIDAuMil9IGluc2V0YFxuICAgICAgICAgICAgOiBnZXRJc0ZpcnN0UmlnaHRQaW5uZWRDb2x1bW4oY29sdW1uKVxuICAgICAgICAgICAgICAgID8gYDRweCAwIDhweCAtNnB4ICR7dGhlbWUuZm4ucmdiYSh0aGVtZS5ibGFjaywgMC4yKX0gaW5zZXRgXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIGRpc3BsYXk6IHRhYmxlLm9wdGlvbnMubGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2ZsZXgnIDogJ3RhYmxlLWNlbGwnLCBmbGV4OiB0YWJsZS5vcHRpb25zLmxheW91dE1vZGUgPT09ICdncmlkJ1xuICAgICAgICAgICAgPyBgdmFyKC0tJHtoZWFkZXIgPyAnaGVhZGVyJyA6ICdjb2wnfS0ke3BhcnNlQ1NTVmFySWQoKF9kID0gaGVhZGVyID09PSBudWxsIHx8IGhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVyLmlkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb2x1bW4uaWQpfS1zaXplKSAwIGF1dG9gXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgbGVmdDogY29sdW1uLmdldElzUGlubmVkKCkgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBgJHtjb2x1bW4uZ2V0U3RhcnQoJ2xlZnQnKX1weGBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBtbDogdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5WaXJ0dWFsaXphdGlvbiAmJlxuICAgICAgICAgICAgY29sdW1uLmdldElzUGlubmVkKCkgPT09ICdsZWZ0JyAmJlxuICAgICAgICAgICAgY29sdW1uLmdldFBpbm5lZEluZGV4KCkgPT09IDBcbiAgICAgICAgICAgID8gYC0ke2NvbHVtbi5nZXRTaXplKCkgKlxuICAgICAgICAgICAgICAgICgoX2YgPSAoX2UgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMSl9cHhgXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgbXI6IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24gJiZcbiAgICAgICAgICAgIGNvbHVtbi5nZXRJc1Bpbm5lZCgpID09PSAncmlnaHQnICYmXG4gICAgICAgICAgICBjb2x1bW4uZ2V0UGlubmVkSW5kZXgoKSA9PT0gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkubGVuZ3RoIC0gMVxuICAgICAgICAgICAgPyBgLSR7Y29sdW1uLmdldFNpemUoKSAqXG4gICAgICAgICAgICAgICAgKChfaCA9IChfZyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMSkgKlxuICAgICAgICAgICAgICAgIDEuMn1weGBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvcGFjaXR5OiAoKF9qID0gdGFibGUuZ2V0U3RhdGUoKS5kcmFnZ2luZ0NvbHVtbikgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmlkKSA9PT0gY29sdW1uLmlkIHx8XG4gICAgICAgICAgICAoKF9rID0gdGFibGUuZ2V0U3RhdGUoKS5ob3ZlcmVkQ29sdW1uKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suaWQpID09PSBjb2x1bW4uaWRcbiAgICAgICAgICAgID8gMC41XG4gICAgICAgICAgICA6IDEsIHBvc2l0aW9uOiBjb2x1bW4uZ2V0SXNQaW5uZWQoKSAmJiBjb2x1bW4uY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgIT09ICdncm91cCdcbiAgICAgICAgICAgID8gJ3N0aWNreSdcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCByaWdodDogY29sdW1uLmdldElzUGlubmVkKCkgPT09ICdyaWdodCdcbiAgICAgICAgICAgID8gYCR7Z2V0VG90YWxSaWdodCh0YWJsZSwgY29sdW1uKX1weGBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCB0cmFuc2l0aW9uOiB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uXG4gICAgICAgICAgICA/ICdub25lJ1xuICAgICAgICAgICAgOiBgcGFkZGluZyAxMDBtcyBlYXNlLWluLW91dGAgfSwgKCF0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nICYmIHdpZHRoU3R5bGVzKSksICgodGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gdGFibGVDZWxsUHJvcHMuc3godGhlbWUpXG4gICAgICAgIDogdGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLnN4KSksICh0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nICYmIHdpZHRoU3R5bGVzKSk7XG59O1xuY29uc3QgTVJUX0RlZmF1bHRDb2x1bW4gPSB7XG4gICAgZmlsdGVyVmFyaWFudDogJ3RleHQnLFxuICAgIG1pblNpemU6IDQwLFxuICAgIG1heFNpemU6IDEwMDAsXG4gICAgc2l6ZTogMTgwLFxufTtcbmNvbnN0IE1SVF9EZWZhdWx0RGlzcGxheUNvbHVtbiA9IHtcbiAgICBjb2x1bW5EZWZUeXBlOiAnZGlzcGxheScsXG4gICAgZW5hYmxlQ2xpY2tUb0NvcHk6IGZhbHNlLFxuICAgIGVuYWJsZUNvbHVtbkFjdGlvbnM6IGZhbHNlLFxuICAgIGVuYWJsZUNvbHVtbkRyYWdnaW5nOiBmYWxzZSxcbiAgICBlbmFibGVDb2x1bW5GaWx0ZXI6IGZhbHNlLFxuICAgIGVuYWJsZUNvbHVtbk9yZGVyaW5nOiBmYWxzZSxcbiAgICBlbmFibGVFZGl0aW5nOiBmYWxzZSxcbiAgICBlbmFibGVHbG9iYWxGaWx0ZXI6IGZhbHNlLFxuICAgIGVuYWJsZUdyb3VwaW5nOiBmYWxzZSxcbiAgICBlbmFibGVIaWRpbmc6IGZhbHNlLFxuICAgIGVuYWJsZVJlc2l6aW5nOiBmYWxzZSxcbiAgICBlbmFibGVTb3J0aW5nOiBmYWxzZSxcbn07XG5jb25zdCBnZXRQcmltYXJ5U2hhZGUgPSAodGhlbWUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIHJldHVybiAoX2UgPSAodGhlbWUuY29sb3JTY2hlbWUgPT09ICdkYXJrJ1xuICAgICAgICA/IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoZW1lLnByaW1hcnlTaGFkZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhcmspICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoZW1lLnByaW1hcnlTaGFkZVxuICAgICAgICA6IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoZW1lLnByaW1hcnlTaGFkZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxpZ2h0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGVtZS5wcmltYXJ5U2hhZGUpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiA3O1xufTtcbmNvbnN0IGdldFByaW1hcnlDb2xvciA9ICh0aGVtZSwgc2hhZGUpID0+IHRoZW1lLmNvbG9yc1t0aGVtZS5wcmltYXJ5Q29sb3JdW3NoYWRlICE9PSBudWxsICYmIHNoYWRlICE9PSB2b2lkIDAgPyBzaGFkZSA6IGdldFByaW1hcnlTaGFkZSh0aGVtZSldO1xuY29uc3QgcGFyc2VDU1NWYXJJZCA9IChpZCkgPT4gaWQucmVwbGFjZSgvW15hLXpBLVowLTldL2csICdfJyk7XG5jb25zdCBmbGV4UmVuZGVyID0gcmVhY3RUYWJsZS5mbGV4UmVuZGVyO1xuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBvcmlnaW5hbFJvdykgPT4gcmVhY3RUYWJsZS5jcmVhdGVSb3codGFibGUsICdtcnQtcm93LWNyZWF0ZScsIG9yaWdpbmFsUm93ICE9PSBudWxsICYmIG9yaWdpbmFsUm93ICE9PSB2b2lkIDAgPyBvcmlnaW5hbFJvdyA6IE9iamVjdC5hc3NpZ24oe30sIC4uLmdldEFsbExlYWZDb2x1bW5EZWZzKHRhYmxlLm9wdGlvbnMuY29sdW1ucylcbiAgICAuZmlsdGVyKChjKSA9PiBjLmNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJylcbiAgICAubWFwKChjb2wpID0+ICh7XG4gICAgW2dldENvbHVtbklkKGNvbCldOiAnJyxcbn0pKSksIC0xLCAwKTtcblxuY29uc3QgTVJUX0xvY2FsaXphdGlvbl9FTiA9IHtcbiAgICBhY3Rpb25zOiAnQWN0aW9ucycsXG4gICAgYW5kOiAnYW5kJyxcbiAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgIGNoYW5nZUZpbHRlck1vZGU6ICdDaGFuZ2UgZmlsdGVyIG1vZGUnLFxuICAgIGNoYW5nZVNlYXJjaE1vZGU6ICdDaGFuZ2Ugc2VhcmNoIG1vZGUnLFxuICAgIGNsZWFyRmlsdGVyOiAnQ2xlYXIgZmlsdGVyJyxcbiAgICBjbGVhclNlYXJjaDogJ0NsZWFyIHNlYXJjaCcsXG4gICAgY2xlYXJTb3J0OiAnQ2xlYXIgc29ydCcsXG4gICAgY2xpY2tUb0NvcHk6ICdDbGljayB0byBjb3B5JyxcbiAgICBjb2xsYXBzZTogJ0NvbGxhcHNlJyxcbiAgICBjb2xsYXBzZUFsbDogJ0NvbGxhcHNlIGFsbCcsXG4gICAgY29sdW1uQWN0aW9uczogJ0NvbHVtbiBBY3Rpb25zJyxcbiAgICBjb3BpZWRUb0NsaXBib2FyZDogJ0NvcGllZCB0byBjbGlwYm9hcmQnLFxuICAgIGRyb3BUb0dyb3VwQnk6ICdEcm9wIHRvIGdyb3VwIGJ5IHtjb2x1bW59JyxcbiAgICBlZGl0OiAnRWRpdCcsXG4gICAgZXhwYW5kOiAnRXhwYW5kJyxcbiAgICBleHBhbmRBbGw6ICdFeHBhbmQgYWxsJyxcbiAgICBmaWx0ZXJBcnJJbmNsdWRlczogJ0luY2x1ZGVzJyxcbiAgICBmaWx0ZXJBcnJJbmNsdWRlc0FsbDogJ0luY2x1ZGVzIGFsbCcsXG4gICAgZmlsdGVyQXJySW5jbHVkZXNTb21lOiAnSW5jbHVkZXMnLFxuICAgIGZpbHRlckJldHdlZW46ICdCZXR3ZWVuJyxcbiAgICBmaWx0ZXJCZXR3ZWVuSW5jbHVzaXZlOiAnQmV0d2VlbiBJbmNsdXNpdmUnLFxuICAgIGZpbHRlckJ5Q29sdW1uOiAnRmlsdGVyIGJ5IHtjb2x1bW59JyxcbiAgICBmaWx0ZXJDb250YWluczogJ0NvbnRhaW5zJyxcbiAgICBmaWx0ZXJFbXB0eTogJ0VtcHR5JyxcbiAgICBmaWx0ZXJFbmRzV2l0aDogJ0VuZHMgV2l0aCcsXG4gICAgZmlsdGVyRXF1YWxzOiAnRXF1YWxzJyxcbiAgICBmaWx0ZXJFcXVhbHNTdHJpbmc6ICdFcXVhbHMnLFxuICAgIGZpbHRlckZ1enp5OiAnRnV6enknLFxuICAgIGZpbHRlckdyZWF0ZXJUaGFuOiAnR3JlYXRlciBUaGFuJyxcbiAgICBmaWx0ZXJHcmVhdGVyVGhhbk9yRXF1YWxUbzogJ0dyZWF0ZXIgVGhhbiBPciBFcXVhbCBUbycsXG4gICAgZmlsdGVySW5OdW1iZXJSYW5nZTogJ0JldHdlZW4nLFxuICAgIGZpbHRlckluY2x1ZGVzU3RyaW5nOiAnQ29udGFpbnMnLFxuICAgIGZpbHRlckluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlOiAnQ29udGFpbnMnLFxuICAgIGZpbHRlckxlc3NUaGFuOiAnTGVzcyBUaGFuJyxcbiAgICBmaWx0ZXJMZXNzVGhhbk9yRXF1YWxUbzogJ0xlc3MgVGhhbiBPciBFcXVhbCBUbycsXG4gICAgZmlsdGVyTW9kZTogJ0ZpbHRlciBNb2RlOiB7ZmlsdGVyVHlwZX0nLFxuICAgIGZpbHRlck5vdEVtcHR5OiAnTm90IEVtcHR5JyxcbiAgICBmaWx0ZXJOb3RFcXVhbHM6ICdOb3QgRXF1YWxzJyxcbiAgICBmaWx0ZXJTdGFydHNXaXRoOiAnU3RhcnRzIFdpdGgnLFxuICAgIGZpbHRlcldlYWtFcXVhbHM6ICdFcXVhbHMnLFxuICAgIGZpbHRlcmluZ0J5Q29sdW1uOiAnRmlsdGVyaW5nIGJ5IHtjb2x1bW59IC0ge2ZpbHRlclR5cGV9IHtmaWx0ZXJWYWx1ZX0nLFxuICAgIGdvVG9GaXJzdFBhZ2U6ICdHbyB0byBmaXJzdCBwYWdlJyxcbiAgICBnb1RvTGFzdFBhZ2U6ICdHbyB0byBsYXN0IHBhZ2UnLFxuICAgIGdvVG9OZXh0UGFnZTogJ0dvIHRvIG5leHQgcGFnZScsXG4gICAgZ29Ub1ByZXZpb3VzUGFnZTogJ0dvIHRvIHByZXZpb3VzIHBhZ2UnLFxuICAgIGdyYWI6ICdHcmFiJyxcbiAgICBncm91cEJ5Q29sdW1uOiAnR3JvdXAgYnkge2NvbHVtbn0nLFxuICAgIGdyb3VwZWRCeTogJ0dyb3VwZWQgYnkgJyxcbiAgICBoaWRlQWxsOiAnSGlkZSBhbGwnLFxuICAgIGhpZGVDb2x1bW46ICdIaWRlIHtjb2x1bW59IGNvbHVtbicsXG4gICAgbWF4OiAnTWF4JyxcbiAgICBtaW46ICdNaW4nLFxuICAgIG1vdmU6ICdNb3ZlJyxcbiAgICBub1JlY29yZHNUb0Rpc3BsYXk6ICdObyByZWNvcmRzIHRvIGRpc3BsYXknLFxuICAgIG5vUmVzdWx0c0ZvdW5kOiAnTm8gcmVzdWx0cyBmb3VuZCcsXG4gICAgb2Y6ICdvZicsXG4gICAgb3I6ICdvcicsXG4gICAgcGluVG9MZWZ0OiAnUGluIHRvIGxlZnQnLFxuICAgIHBpblRvUmlnaHQ6ICdQaW4gdG8gcmlnaHQnLFxuICAgIHJlc2V0Q29sdW1uU2l6ZTogJ1Jlc2V0IGNvbHVtbiBzaXplJyxcbiAgICByZXNldE9yZGVyOiAnUmVzZXQgb3JkZXInLFxuICAgIHJvd0FjdGlvbnM6ICdSb3cgQWN0aW9ucycsXG4gICAgcm93TnVtYmVyOiAnIycsXG4gICAgcm93TnVtYmVyczogJ1JvdyBOdW1iZXJzJyxcbiAgICByb3dzUGVyUGFnZTogJ1Jvd3MgcGVyIHBhZ2UnLFxuICAgIHNhdmU6ICdTYXZlJyxcbiAgICBzZWFyY2g6ICdTZWFyY2gnLFxuICAgIHNlbGVjdGVkQ291bnRPZlJvd0NvdW50Um93c1NlbGVjdGVkOiAne3NlbGVjdGVkQ291bnR9IG9mIHtyb3dDb3VudH0gcm93KHMpIHNlbGVjdGVkJyxcbiAgICBzZWxlY3Q6ICdTZWxlY3QnLFxuICAgIHNob3dBbGw6ICdTaG93IGFsbCcsXG4gICAgc2hvd0FsbENvbHVtbnM6ICdTaG93IGFsbCBjb2x1bW5zJyxcbiAgICBzaG93SGlkZUNvbHVtbnM6ICdTaG93L0hpZGUgY29sdW1ucycsXG4gICAgc2hvd0hpZGVGaWx0ZXJzOiAnU2hvdy9IaWRlIGZpbHRlcnMnLFxuICAgIHNob3dIaWRlU2VhcmNoOiAnU2hvdy9IaWRlIHNlYXJjaCcsXG4gICAgc29ydEJ5Q29sdW1uQXNjOiAnU29ydCBieSB7Y29sdW1ufSBhc2NlbmRpbmcnLFxuICAgIHNvcnRCeUNvbHVtbkRlc2M6ICdTb3J0IGJ5IHtjb2x1bW59IGRlc2NlbmRpbmcnLFxuICAgIHNvcnRlZEJ5Q29sdW1uQXNjOiAnU29ydGVkIGJ5IHtjb2x1bW59IGFzY2VuZGluZycsXG4gICAgc29ydGVkQnlDb2x1bW5EZXNjOiAnU29ydGVkIGJ5IHtjb2x1bW59IGRlc2NlbmRpbmcnLFxuICAgIHRoZW5CeTogJywgdGhlbiBieSAnLFxuICAgIHRvZ2dsZURlbnNpdHk6ICdUb2dnbGUgZGVuc2l0eScsXG4gICAgdG9nZ2xlRnVsbFNjcmVlbjogJ1RvZ2dsZSBmdWxsIHNjcmVlbicsXG4gICAgdG9nZ2xlU2VsZWN0QWxsOiAnVG9nZ2xlIHNlbGVjdCBhbGwnLFxuICAgIHRvZ2dsZVNlbGVjdFJvdzogJ1RvZ2dsZSBzZWxlY3Qgcm93JyxcbiAgICB0b2dnbGVWaXNpYmlsaXR5OiAnVG9nZ2xlIHZpc2liaWxpdHknLFxuICAgIHVuZ3JvdXBCeUNvbHVtbjogJ1VuZ3JvdXAgYnkge2NvbHVtbn0nLFxuICAgIHVucGluOiAnVW5waW4nLFxuICAgIHVucGluQWxsOiAnVW5waW4gYWxsJyxcbn07XG5cbmNvbnN0IE1SVF9EZWZhdWx0X0ljb25zID0ge1xuICAgIEljb25BcnJvd0F1dG9maXRDb250ZW50OiBpY29uc1JlYWN0Lkljb25BcnJvd0F1dG9maXRDb250ZW50LFxuICAgIEljb25BcnJvd3NTb3J0OiBpY29uc1JlYWN0Lkljb25BcnJvd3NTb3J0LFxuICAgIEljb25CYXNlbGluZURlbnNpdHlMYXJnZTogaWNvbnNSZWFjdC5JY29uQmFzZWxpbmVEZW5zaXR5TGFyZ2UsXG4gICAgSWNvbkJhc2VsaW5lRGVuc2l0eU1lZGl1bTogaWNvbnNSZWFjdC5JY29uQmFzZWxpbmVEZW5zaXR5TWVkaXVtLFxuICAgIEljb25CYXNlbGluZURlbnNpdHlTbWFsbDogaWNvbnNSZWFjdC5JY29uQmFzZWxpbmVEZW5zaXR5U21hbGwsXG4gICAgSWNvbkJveE11bHRpcGxlOiBpY29uc1JlYWN0Lkljb25Cb3hNdWx0aXBsZSxcbiAgICBJY29uQ2hldnJvbkRvd246IGljb25zUmVhY3QuSWNvbkNoZXZyb25Eb3duLFxuICAgIEljb25DaGV2cm9uTGVmdDogaWNvbnNSZWFjdC5JY29uQ2hldnJvbkxlZnQsXG4gICAgSWNvbkNoZXZyb25MZWZ0UGlwZTogaWNvbnNSZWFjdC5JY29uQ2hldnJvbkxlZnRQaXBlLFxuICAgIEljb25DaGV2cm9uUmlnaHQ6IGljb25zUmVhY3QuSWNvbkNoZXZyb25SaWdodCxcbiAgICBJY29uQ2hldnJvblJpZ2h0UGlwZTogaWNvbnNSZWFjdC5JY29uQ2hldnJvblJpZ2h0UGlwZSxcbiAgICBJY29uQ2hldnJvbnNEb3duOiBpY29uc1JlYWN0Lkljb25DaGV2cm9uc0Rvd24sXG4gICAgSWNvbkNpcmNsZVg6IGljb25zUmVhY3QuSWNvbkNpcmNsZVgsXG4gICAgSWNvbkNsZWFyQWxsOiBpY29uc1JlYWN0Lkljb25DbGVhckFsbCxcbiAgICBJY29uQ29sdW1uczogaWNvbnNSZWFjdC5JY29uQ29sdW1ucyxcbiAgICBJY29uRGV2aWNlRmxvcHB5OiBpY29uc1JlYWN0Lkljb25EZXZpY2VGbG9wcHksXG4gICAgSWNvbkRvdHM6IGljb25zUmVhY3QuSWNvbkRvdHMsXG4gICAgSWNvbkRvdHNWZXJ0aWNhbDogaWNvbnNSZWFjdC5JY29uRG90c1ZlcnRpY2FsLFxuICAgIEljb25FZGl0OiBpY29uc1JlYWN0Lkljb25FZGl0LFxuICAgIEljb25FeWVPZmY6IGljb25zUmVhY3QuSWNvbkV5ZU9mZixcbiAgICBJY29uRmlsdGVyOiBpY29uc1JlYWN0Lkljb25GaWx0ZXIsXG4gICAgSWNvbkZpbHRlckNvZzogaWNvbnNSZWFjdC5JY29uRmlsdGVyQ29nLFxuICAgIEljb25GaWx0ZXJPZmY6IGljb25zUmVhY3QuSWNvbkZpbHRlck9mZixcbiAgICBJY29uR3JpcEhvcml6b250YWw6IGljb25zUmVhY3QuSWNvbkdyaXBIb3Jpem9udGFsLFxuICAgIEljb25NYXhpbWl6ZTogaWNvbnNSZWFjdC5JY29uTWF4aW1pemUsXG4gICAgSWNvbk1pbmltaXplOiBpY29uc1JlYWN0Lkljb25NaW5pbWl6ZSxcbiAgICBJY29uUGlubmVkOiBpY29uc1JlYWN0Lkljb25QaW5uZWQsXG4gICAgSWNvblBpbm5lZE9mZjogaWNvbnNSZWFjdC5JY29uUGlubmVkT2ZmLFxuICAgIEljb25TZWFyY2g6IGljb25zUmVhY3QuSWNvblNlYXJjaCxcbiAgICBJY29uU2VhcmNoT2ZmOiBpY29uc1JlYWN0Lkljb25TZWFyY2hPZmYsXG4gICAgSWNvblNvcnRBc2NlbmRpbmc6IGljb25zUmVhY3QuSWNvblNvcnRBc2NlbmRpbmcsXG4gICAgSWNvblNvcnREZXNjZW5kaW5nOiBpY29uc1JlYWN0Lkljb25Tb3J0RGVzY2VuZGluZyxcbiAgICBJY29uWDogaWNvbnNSZWFjdC5JY29uWCxcbn07XG5cbmNvbnN0IHVzZU1SVF9UYWJsZU9wdGlvbnMgPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgYWdncmVnYXRpb25GbnMsIGF1dG9SZXNldEV4cGFuZGVkID0gZmFsc2UsIGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID0gJ3N1YmhlYWRlcicsIGNvbHVtblJlc2l6ZU1vZGUgPSAnb25DaGFuZ2UnLCBjcmVhdGVEaXNwbGF5TW9kZSA9ICdtb2RhbCcsIGRlZmF1bHRDb2x1bW4sIGRlZmF1bHREaXNwbGF5Q29sdW1uLCBlZGl0RGlzcGxheU1vZGUgPSAnbW9kYWwnLCBlbmFibGVCb3R0b21Ub29sYmFyID0gdHJ1ZSwgZW5hYmxlQ29sdW1uQWN0aW9ucyA9IHRydWUsIGVuYWJsZUNvbHVtbkZpbHRlcnMgPSB0cnVlLCBlbmFibGVDb2x1bW5PcmRlcmluZyA9IGZhbHNlLCBlbmFibGVDb2x1bW5SZXNpemluZyA9IGZhbHNlLCBlbmFibGVEZW5zaXR5VG9nZ2xlID0gdHJ1ZSwgZW5hYmxlRXhwYW5kQWxsID0gdHJ1ZSwgZW5hYmxlRXhwYW5kaW5nLCBlbmFibGVGaWx0ZXJNYXRjaEhpZ2hsaWdodGluZyA9IHRydWUsIGVuYWJsZUZpbHRlcnMgPSB0cnVlLCBlbmFibGVGdWxsU2NyZWVuVG9nZ2xlID0gdHJ1ZSwgZW5hYmxlR2xvYmFsRmlsdGVyID0gdHJ1ZSwgZW5hYmxlR2xvYmFsRmlsdGVyUmFua2VkUmVzdWx0cyA9IHRydWUsIGVuYWJsZUdyb3VwaW5nID0gZmFsc2UsIGVuYWJsZUhpZGluZyA9IHRydWUsIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uID0gdHJ1ZSwgZW5hYmxlTXVsdGlTb3J0ID0gdHJ1ZSwgZW5hYmxlUGFnaW5hdGlvbiA9IHRydWUsIGVuYWJsZVBpbm5pbmcgPSBmYWxzZSwgZW5hYmxlUm93U2VsZWN0aW9uID0gZmFsc2UsIGVuYWJsZVNlbGVjdEFsbCA9IHRydWUsIGVuYWJsZVNvcnRpbmcgPSB0cnVlLCBlbmFibGVTdGlja3lIZWFkZXIgPSBmYWxzZSwgZW5hYmxlVGFibGVGb290ZXIgPSB0cnVlLCBlbmFibGVUYWJsZUhlYWQgPSB0cnVlLCBlbmFibGVUb29sYmFySW50ZXJuYWxBY3Rpb25zID0gdHJ1ZSwgZW5hYmxlVG9wVG9vbGJhciA9IHRydWUsIGZpbHRlckZucywgaWNvbnMsIGxheW91dE1vZGUgPSAnc2VtYW50aWMnLCBsb2NhbGl6YXRpb24sIG1hbnVhbEZpbHRlcmluZywgbWFudWFsR3JvdXBpbmcsIG1hbnVhbFBhZ2luYXRpb24sIG1hbnVhbFNvcnRpbmcsIHBhZ2luYXRpb25EaXNwbGF5TW9kZSA9ICdkZWZhdWx0JywgcG9zaXRpb25BY3Rpb25zQ29sdW1uID0gJ2ZpcnN0JywgcG9zaXRpb25FeHBhbmRDb2x1bW4gPSAnZmlyc3QnLCBwb3NpdGlvbkdsb2JhbEZpbHRlciA9ICdyaWdodCcsIHBvc2l0aW9uUGFnaW5hdGlvbiA9ICdib3R0b20nLCBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciA9ICd0b3AnLCBwb3NpdGlvblRvb2xiYXJEcm9wWm9uZSA9ICd0b3AnLCByb3dOdW1iZXJNb2RlID0gJ3N0YXRpYycsIHNlbGVjdEFsbE1vZGUgPSAncGFnZScsIHNvcnRpbmdGbnMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJhZ2dyZWdhdGlvbkZuc1wiLCBcImF1dG9SZXNldEV4cGFuZGVkXCIsIFwiY29sdW1uRmlsdGVyRGlzcGxheU1vZGVcIiwgXCJjb2x1bW5SZXNpemVNb2RlXCIsIFwiY3JlYXRlRGlzcGxheU1vZGVcIiwgXCJkZWZhdWx0Q29sdW1uXCIsIFwiZGVmYXVsdERpc3BsYXlDb2x1bW5cIiwgXCJlZGl0RGlzcGxheU1vZGVcIiwgXCJlbmFibGVCb3R0b21Ub29sYmFyXCIsIFwiZW5hYmxlQ29sdW1uQWN0aW9uc1wiLCBcImVuYWJsZUNvbHVtbkZpbHRlcnNcIiwgXCJlbmFibGVDb2x1bW5PcmRlcmluZ1wiLCBcImVuYWJsZUNvbHVtblJlc2l6aW5nXCIsIFwiZW5hYmxlRGVuc2l0eVRvZ2dsZVwiLCBcImVuYWJsZUV4cGFuZEFsbFwiLCBcImVuYWJsZUV4cGFuZGluZ1wiLCBcImVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nXCIsIFwiZW5hYmxlRmlsdGVyc1wiLCBcImVuYWJsZUZ1bGxTY3JlZW5Ub2dnbGVcIiwgXCJlbmFibGVHbG9iYWxGaWx0ZXJcIiwgXCJlbmFibGVHbG9iYWxGaWx0ZXJSYW5rZWRSZXN1bHRzXCIsIFwiZW5hYmxlR3JvdXBpbmdcIiwgXCJlbmFibGVIaWRpbmdcIiwgXCJlbmFibGVNdWx0aVJvd1NlbGVjdGlvblwiLCBcImVuYWJsZU11bHRpU29ydFwiLCBcImVuYWJsZVBhZ2luYXRpb25cIiwgXCJlbmFibGVQaW5uaW5nXCIsIFwiZW5hYmxlUm93U2VsZWN0aW9uXCIsIFwiZW5hYmxlU2VsZWN0QWxsXCIsIFwiZW5hYmxlU29ydGluZ1wiLCBcImVuYWJsZVN0aWNreUhlYWRlclwiLCBcImVuYWJsZVRhYmxlRm9vdGVyXCIsIFwiZW5hYmxlVGFibGVIZWFkXCIsIFwiZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9uc1wiLCBcImVuYWJsZVRvcFRvb2xiYXJcIiwgXCJmaWx0ZXJGbnNcIiwgXCJpY29uc1wiLCBcImxheW91dE1vZGVcIiwgXCJsb2NhbGl6YXRpb25cIiwgXCJtYW51YWxGaWx0ZXJpbmdcIiwgXCJtYW51YWxHcm91cGluZ1wiLCBcIm1hbnVhbFBhZ2luYXRpb25cIiwgXCJtYW51YWxTb3J0aW5nXCIsIFwicGFnaW5hdGlvbkRpc3BsYXlNb2RlXCIsIFwicG9zaXRpb25BY3Rpb25zQ29sdW1uXCIsIFwicG9zaXRpb25FeHBhbmRDb2x1bW5cIiwgXCJwb3NpdGlvbkdsb2JhbEZpbHRlclwiLCBcInBvc2l0aW9uUGFnaW5hdGlvblwiLCBcInBvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyXCIsIFwicG9zaXRpb25Ub29sYmFyRHJvcFpvbmVcIiwgXCJyb3dOdW1iZXJNb2RlXCIsIFwic2VsZWN0QWxsTW9kZVwiLCBcInNvcnRpbmdGbnNcIl0pO1xuICAgIGNvbnN0IF9pY29ucyA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTVJUX0RlZmF1bHRfSWNvbnMpLCBpY29ucykpLCBbaWNvbnNdKTtcbiAgICBjb25zdCBfbG9jYWxpemF0aW9uID0gcmVhY3QudXNlTWVtbygoKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNUlRfTG9jYWxpemF0aW9uX0VOKSwgbG9jYWxpemF0aW9uKSksIFtsb2NhbGl6YXRpb25dKTtcbiAgICBjb25zdCBfYWdncmVnYXRpb25GbnMgPSByZWFjdC51c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9BZ2dyZWdhdGlvbkZucyksIGFnZ3JlZ2F0aW9uRm5zKSksIFtdKTtcbiAgICBjb25zdCBfZmlsdGVyRm5zID0gcmVhY3QudXNlTWVtbygoKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNUlRfRmlsdGVyRm5zKSwgZmlsdGVyRm5zKSksIFtdKTtcbiAgICBjb25zdCBfc29ydGluZ0ZucyA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTVJUX1NvcnRpbmdGbnMpLCBzb3J0aW5nRm5zKSksIFtdKTtcbiAgICBjb25zdCBfZGVmYXVsdENvbHVtbiA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTVJUX0RlZmF1bHRDb2x1bW4pLCBkZWZhdWx0Q29sdW1uKSksIFtkZWZhdWx0Q29sdW1uXSk7XG4gICAgY29uc3QgX2RlZmF1bHREaXNwbGF5Q29sdW1uID0gcmVhY3QudXNlTWVtbygoKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNUlRfRGVmYXVsdERpc3BsYXlDb2x1bW4pLCBkZWZhdWx0RGlzcGxheUNvbHVtbikpLCBbZGVmYXVsdERpc3BsYXlDb2x1bW5dKTtcbiAgICBpZiAocmVzdC5lbmFibGVSb3dWaXJ0dWFsaXphdGlvbiB8fCByZXN0LmVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uKSB7XG4gICAgICAgIGxheW91dE1vZGUgPSAnZ3JpZCc7XG4gICAgfVxuICAgIGlmIChyZXN0LmVuYWJsZVJvd1ZpcnR1YWxpemF0aW9uKSB7XG4gICAgICAgIGVuYWJsZVN0aWNreUhlYWRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlbmFibGVQYWdpbmF0aW9uID09PSBmYWxzZSAmJiBtYW51YWxQYWdpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFudWFsUGFnaW5hdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICghKChfYiA9IHJlc3QuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkpIHtcbiAgICAgICAgbWFudWFsRmlsdGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgbWFudWFsR3JvdXBpbmcgPSB0cnVlO1xuICAgICAgICBtYW51YWxQYWdpbmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgbWFudWFsU29ydGluZyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgYWdncmVnYXRpb25GbnM6IF9hZ2dyZWdhdGlvbkZucywgYXV0b1Jlc2V0RXhwYW5kZWQsXG4gICAgICAgIGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlLFxuICAgICAgICBjb2x1bW5SZXNpemVNb2RlLFxuICAgICAgICBjcmVhdGVEaXNwbGF5TW9kZSwgZGVmYXVsdENvbHVtbjogX2RlZmF1bHRDb2x1bW4sIGRlZmF1bHREaXNwbGF5Q29sdW1uOiBfZGVmYXVsdERpc3BsYXlDb2x1bW4sIGVkaXREaXNwbGF5TW9kZSxcbiAgICAgICAgZW5hYmxlQm90dG9tVG9vbGJhcixcbiAgICAgICAgZW5hYmxlQ29sdW1uQWN0aW9ucyxcbiAgICAgICAgZW5hYmxlQ29sdW1uRmlsdGVycyxcbiAgICAgICAgZW5hYmxlQ29sdW1uT3JkZXJpbmcsXG4gICAgICAgIGVuYWJsZUNvbHVtblJlc2l6aW5nLFxuICAgICAgICBlbmFibGVEZW5zaXR5VG9nZ2xlLFxuICAgICAgICBlbmFibGVFeHBhbmRBbGwsXG4gICAgICAgIGVuYWJsZUV4cGFuZGluZyxcbiAgICAgICAgZW5hYmxlRmlsdGVyTWF0Y2hIaWdobGlnaHRpbmcsXG4gICAgICAgIGVuYWJsZUZpbHRlcnMsXG4gICAgICAgIGVuYWJsZUZ1bGxTY3JlZW5Ub2dnbGUsXG4gICAgICAgIGVuYWJsZUdsb2JhbEZpbHRlcixcbiAgICAgICAgZW5hYmxlR2xvYmFsRmlsdGVyUmFua2VkUmVzdWx0cyxcbiAgICAgICAgZW5hYmxlR3JvdXBpbmcsXG4gICAgICAgIGVuYWJsZUhpZGluZyxcbiAgICAgICAgZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24sXG4gICAgICAgIGVuYWJsZU11bHRpU29ydCxcbiAgICAgICAgZW5hYmxlUGFnaW5hdGlvbixcbiAgICAgICAgZW5hYmxlUGlubmluZyxcbiAgICAgICAgZW5hYmxlUm93U2VsZWN0aW9uLFxuICAgICAgICBlbmFibGVTZWxlY3RBbGwsXG4gICAgICAgIGVuYWJsZVNvcnRpbmcsXG4gICAgICAgIGVuYWJsZVN0aWNreUhlYWRlcixcbiAgICAgICAgZW5hYmxlVGFibGVGb290ZXIsXG4gICAgICAgIGVuYWJsZVRhYmxlSGVhZCxcbiAgICAgICAgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucyxcbiAgICAgICAgZW5hYmxlVG9wVG9vbGJhciwgZmlsdGVyRm5zOiBfZmlsdGVyRm5zLCBpY29uczogX2ljb25zLCBsYXlvdXRNb2RlLCBsb2NhbGl6YXRpb246IF9sb2NhbGl6YXRpb24sIG1hbnVhbEZpbHRlcmluZyxcbiAgICAgICAgbWFudWFsR3JvdXBpbmcsXG4gICAgICAgIG1hbnVhbFBhZ2luYXRpb24sXG4gICAgICAgIG1hbnVhbFNvcnRpbmcsXG4gICAgICAgIHBhZ2luYXRpb25EaXNwbGF5TW9kZSxcbiAgICAgICAgcG9zaXRpb25BY3Rpb25zQ29sdW1uLFxuICAgICAgICBwb3NpdGlvbkV4cGFuZENvbHVtbixcbiAgICAgICAgcG9zaXRpb25HbG9iYWxGaWx0ZXIsXG4gICAgICAgIHBvc2l0aW9uUGFnaW5hdGlvbixcbiAgICAgICAgcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIsXG4gICAgICAgIHBvc2l0aW9uVG9vbGJhckRyb3Bab25lLFxuICAgICAgICByb3dOdW1iZXJNb2RlLFxuICAgICAgICBzZWxlY3RBbGxNb2RlLCBzb3J0aW5nRm5zOiBfc29ydGluZ0ZucyB9LCByZXN0KTtcbn07XG5cbmNvbnN0IE1SVF9FZGl0Q2VsbFRleHRJbnB1dCA9ICh7IGNlbGwsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY3JlYXRlRGlzcGxheU1vZGUsIGVkaXREaXNwbGF5TW9kZSwgbWFudGluZUVkaXRUZXh0SW5wdXRQcm9wcywgbWFudGluZUVkaXRTZWxlY3RQcm9wcywgfSwgcmVmczogeyBlZGl0SW5wdXRSZWZzIH0sIHNldEVkaXRpbmdDZWxsLCBzZXRFZGl0aW5nUm93LCBzZXRDcmVhdGluZ1JvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uLCByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNyZWF0aW5nUm93LCBlZGl0aW5nUm93IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzQ3JlYXRpbmcgPSAoY3JlYXRpbmdSb3cgPT09IG51bGwgfHwgY3JlYXRpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0aW5nUm93LmlkKSA9PT0gcm93LmlkO1xuICAgIGNvbnN0IGlzRWRpdGluZyA9IChlZGl0aW5nUm93ID09PSBudWxsIHx8IGVkaXRpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaXNTZWxlY3RFZGl0ID0gY29sdW1uRGVmLmVkaXRWYXJpYW50ID09PSAnc2VsZWN0JztcbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHJlYWN0LnVzZVN0YXRlKCgpID0+IGNlbGwuZ2V0VmFsdWUoKSk7XG4gICAgY29uc3QgbVRhYmxlQm9keUNlbGxFZGl0VGV4dElucHV0UHJvcHMgPSBtYW50aW5lRWRpdFRleHRJbnB1dFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lRWRpdFRleHRJbnB1dFByb3BzKHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZUVkaXRUZXh0SW5wdXRQcm9wcztcbiAgICBjb25zdCBtY1RhYmxlQm9keUNlbGxFZGl0VGV4dElucHV0UHJvcHMgPSBjb2x1bW5EZWYubWFudGluZUVkaXRUZXh0SW5wdXRQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVFZGl0VGV4dElucHV0UHJvcHMoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lRWRpdFRleHRJbnB1dFByb3BzO1xuICAgIGNvbnN0IHRleHRJbnB1dFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtVGFibGVCb2R5Q2VsbEVkaXRUZXh0SW5wdXRQcm9wcyksIG1jVGFibGVCb2R5Q2VsbEVkaXRUZXh0SW5wdXRQcm9wcyk7XG4gICAgY29uc3QgbVRhYmxlQm9keUNlbGxFZGl0U2VsZWN0UHJvcHMgPSBtYW50aW5lRWRpdFNlbGVjdFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lRWRpdFNlbGVjdFByb3BzKHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZUVkaXRTZWxlY3RQcm9wcztcbiAgICBjb25zdCBtY1RhYmxlQm9keUNlbGxFZGl0U2VsZWN0UHJvcHMgPSBjb2x1bW5EZWYubWFudGluZUVkaXRTZWxlY3RQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVFZGl0U2VsZWN0UHJvcHMoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lRWRpdFNlbGVjdFByb3BzO1xuICAgIGNvbnN0IHNlbGVjdFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtVGFibGVCb2R5Q2VsbEVkaXRTZWxlY3RQcm9wcyksIG1jVGFibGVCb2R5Q2VsbEVkaXRTZWxlY3RQcm9wcyk7XG4gICAgY29uc3Qgc2F2ZUlucHV0VmFsdWVUb1Jvd0NhY2hlID0gKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbi5pZF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKGlzQ3JlYXRpbmcpIHtcbiAgICAgICAgICAgIHNldENyZWF0aW5nUm93KHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBzZXRFZGl0aW5nUm93KHJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUJsdXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0ZXh0SW5wdXRQcm9wcy5vbkJsdXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRleHRJbnB1dFByb3BzLCBldmVudCk7XG4gICAgICAgIHNhdmVJbnB1dFZhbHVlVG9Sb3dDYWNoZSh2YWx1ZSk7XG4gICAgICAgIHNldEVkaXRpbmdDZWxsKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRW50ZXJLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHRleHRJbnB1dFByb3BzLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGV4dElucHV0UHJvcHMsIGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgKF9iID0gZWRpdElucHV0UmVmcy5jdXJyZW50W2NlbGwuaWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmx1cigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoY29sdW1uRGVmLkVkaXQpIHtcbiAgICAgICAgcmV0dXJuIChfYSA9IGNvbHVtbkRlZi5FZGl0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb2x1bW5EZWYsIHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgZGlzYWJsZWQ6IChjb2x1bW5EZWYuZW5hYmxlRWRpdGluZyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IGNvbHVtbkRlZi5lbmFibGVFZGl0aW5nKHJvdylcbiAgICAgICAgICAgIDogY29sdW1uRGVmLmVuYWJsZUVkaXRpbmcpID09PSBmYWxzZSxcbiAgICAgICAgbGFiZWw6IFsnbW9kYWwnLCAnY3VzdG9tJ10uaW5jbHVkZXMoKGlzQ3JlYXRpbmcgPyBjcmVhdGVEaXNwbGF5TW9kZSA6IGVkaXREaXNwbGF5TW9kZSkpXG4gICAgICAgICAgICA/IGNvbHVtbi5jb2x1bW5EZWYuaGVhZGVyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmFtZTogY2VsbC5pZCxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICFbJ21vZGFsJywgJ2N1c3RvbSddLmluY2x1ZGVzKChpc0NyZWF0aW5nID8gY3JlYXRlRGlzcGxheU1vZGUgOiBlZGl0RGlzcGxheU1vZGUpKVxuICAgICAgICAgICAgPyBjb2x1bW5EZWYuaGVhZGVyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhcmlhbnQ6IGVkaXREaXNwbGF5TW9kZSA9PT0gJ3RhYmxlJyA/ICd1bnN0eWxlZCcgOiAnZGVmYXVsdCcsXG4gICAgICAgIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgKF9hID0gdGV4dElucHV0UHJvcHMgPT09IG51bGwgfHwgdGV4dElucHV0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRJbnB1dFByb3BzLm9uQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRleHRJbnB1dFByb3BzLCBlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChpc1NlbGVjdEVkaXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBqc3hSdW50aW1lLmpzeChjb3JlLlNlbGVjdCwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUHJvcHMsIHsgc2VhcmNoYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlLCB3aXRoaW5Qb3J0YWw6IHRydWUgfSwgc2VsZWN0UHJvcHMsIHsgb25CbHVyOiBoYW5kbGVCbHVyLCBvbkNoYW5nZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHNlbGVjdFByb3BzLm9uQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzZWxlY3RQcm9wcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgKF9hID0gc2VsZWN0UHJvcHMgPT09IG51bGwgfHwgc2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdFByb3BzLm9uQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNlbGVjdFByb3BzLCBlKTtcbiAgICAgICAgICAgIH0sIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0SW5wdXRSZWZzLmN1cnJlbnRbY2VsbC5pZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0UHJvcHMucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RQcm9wcy5yZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0pKSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5UZXh0SW5wdXQsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblByb3BzLCB7IG9uS2V5RG93bjogaGFuZGxlRW50ZXJLZXlEb3duLCB2YWx1ZTogdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogJycgfSwgdGV4dElucHV0UHJvcHMsIHsgb25CbHVyOiBoYW5kbGVCbHVyLCBvbkNoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0ZXh0SW5wdXRQcm9wcy5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGV4dElucHV0UHJvcHMsIGV2ZW50KTtcbiAgICAgICAgICAgIHNldFZhbHVlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgIH0sIG9uQ2xpY2s6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAoX2EgPSB0ZXh0SW5wdXRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0SW5wdXRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dElucHV0UHJvcHMub25DbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGV4dElucHV0UHJvcHMsIGV2ZW50KTtcbiAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBlZGl0SW5wdXRSZWZzLmN1cnJlbnRbY2VsbC5pZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0SW5wdXRQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dElucHV0UHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9KSkpO1xufTtcblxuY29uc3QgTVJUX0NvcHlCdXR0b24gPSAoeyBjZWxsLCBjaGlsZHJlbiwgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgbG9jYWxpemF0aW9uLCBtYW50aW5lQ29weUJ1dHRvblByb3BzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbiwgcm93IH0gPSBjZWxsO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgbVRhYmxlQm9keUNlbGxDb3B5QnV0dG9uUHJvcHMgPSBtYW50aW5lQ29weUJ1dHRvblByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lQ29weUJ1dHRvblByb3BzKHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZUNvcHlCdXR0b25Qcm9wcztcbiAgICBjb25zdCBtY1RhYmxlQm9keUNlbGxDb3B5QnV0dG9uUHJvcHMgPSBjb2x1bW5EZWYubWFudGluZUNvcHlCdXR0b25Qcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVDb3B5QnV0dG9uUHJvcHMoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lQ29weUJ1dHRvblByb3BzO1xuICAgIGNvbnN0IGJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtVGFibGVCb2R5Q2VsbENvcHlCdXR0b25Qcm9wcyksIG1jVGFibGVCb2R5Q2VsbENvcHlCdXR0b25Qcm9wcyk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkNvcHlCdXR0b24sIHsgdmFsdWU6IGNlbGwuZ2V0VmFsdWUoKSwgY2hpbGRyZW46ICh7IGNvcGllZCwgY29weSB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyBjb2xvcjogY29waWVkID8gJ2dyZWVuJyA6IHVuZGVmaW5lZCwgd2l0aGluUG9ydGFsOiB0cnVlLCBvcGVuRGVsYXk6IDEwMDAsIGxhYmVsOiAoX2EgPSBidXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBidXR0b25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnV0dG9uUHJvcHMudGl0bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjb3BpZWQgPyBsb2NhbGl6YXRpb24uY29waWVkVG9DbGlwYm9hcmQgOiBsb2NhbGl6YXRpb24uY2xpY2tUb0NvcHkpLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5VbnN0eWxlZEJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7fSwgYnV0dG9uUHJvcHMsIHsgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLCBib3JkZXI6ICdub25lJywgYm9yZGVyUmFkaXVzOiAnNHB4JywgY29sb3I6ICdpbmhlcml0JywgY3Vyc29yOiAnY29weScsIGZvbnRGYW1pbHk6ICdpbmhlcml0JywgZm9udFNpemU6ICdpbmhlcml0JywgZm9udFdlaWdodDogJ2luaGVyaXQnLCBqdXN0aWZ5Q29udGVudDogJ2luaGVyaXQnLCBsZXR0ZXJTcGFjaW5nOiAnaW5oZXJpdCcsIG1hcmdpbjogJy00cHgnLCBtaW5XaWR0aDogJ3Vuc2V0JywgcGFkZGluZzogJzRweCcsIHRleHRBbGlnbjogJ2luaGVyaXQnLCB0ZXh0VHJhbnNmb3JtOiAnaW5oZXJpdCcsICcmOmFjdGl2ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDFweCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5mbi5yZ2JhKGdldFByaW1hcnlDb2xvcih0aGVtZSksIDAuMSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sICgoYnV0dG9uUHJvcHMgPT09IG51bGwgfHwgYnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1dHRvblByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJ1dHRvblByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBidXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBidXR0b25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnV0dG9uUHJvcHMuc3gpKSksIHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkgfSkpO1xuICAgICAgICB9IH0pKTtcbn07XG5cbmNvbnN0IGFsbG93ZWRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlciddO1xuY29uc3QgYWxsb3dlZEZpbHRlclZhcmlhbnRzID0gWyd0ZXh0JywgJ2F1dG9jb21wbGV0ZSddO1xuY29uc3QgTVJUX1RhYmxlQm9keUNlbGxWYWx1ZSA9ICh7IGNlbGwsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nLCBtYW50aW5lSGlnaGxpZ2h0UHJvcHMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uLCByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlciwgZ2xvYmFsRmlsdGVyRm4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKTtcbiAgICBjb25zdCBoaWdobGlnaHRQcm9wcyA9IChtYW50aW5lSGlnaGxpZ2h0UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVIaWdobGlnaHRQcm9wcyh7IGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVIaWdobGlnaHRQcm9wcyk7XG4gICAgbGV0IHJlbmRlcmVkQ2VsbFZhbHVlID0gY2VsbC5nZXRJc0FnZ3JlZ2F0ZWQoKSAmJiBjb2x1bW5EZWYuQWdncmVnYXRlZENlbGxcbiAgICAgICAgPyBjb2x1bW5EZWYuQWdncmVnYXRlZENlbGwoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KVxuICAgICAgICA6IHJvdy5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc0dyb3VwZWQoKVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uRGVmLkdyb3VwZWRDZWxsXG4gICAgICAgICAgICAgICAgPyBjb2x1bW5EZWYuR3JvdXBlZENlbGwoe1xuICAgICAgICAgICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc0dyb3VwZWRWYWx1ZSA9IHJlbmRlcmVkQ2VsbFZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFpc0dyb3VwZWRWYWx1ZSkge1xuICAgICAgICByZW5kZXJlZENlbGxWYWx1ZSA9IGNlbGwucmVuZGVyVmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nICYmXG4gICAgICAgIGNvbHVtbkRlZi5lbmFibGVGaWx0ZXJNYXRjaEhpZ2hsaWdodGluZyAhPT0gZmFsc2UgJiZcbiAgICAgICAgcmVuZGVyZWRDZWxsVmFsdWUgJiZcbiAgICAgICAgYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGVvZiByZW5kZXJlZENlbGxWYWx1ZSkgJiZcbiAgICAgICAgKChmaWx0ZXJWYWx1ZSAmJlxuICAgICAgICAgICAgYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGVvZiBmaWx0ZXJWYWx1ZSkgJiZcbiAgICAgICAgICAgIGFsbG93ZWRGaWx0ZXJWYXJpYW50cy5pbmNsdWRlcyhjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCkpIHx8XG4gICAgICAgICAgICAoZ2xvYmFsRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGVvZiBnbG9iYWxGaWx0ZXIpICYmXG4gICAgICAgICAgICAgICAgY29sdW1uLmdldENhbkdsb2JhbEZpbHRlcigpKSkpIHtcbiAgICAgICAgbGV0IGhpZ2hsaWdodCA9ICgoX2IgPSAoX2EgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2xvYmFsRmlsdGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKChmaWx0ZXJWYWx1ZSA/IGNvbHVtbkRlZi5fZmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbikgPT09ICdmdXp6eScpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodCA9IGhpZ2hsaWdodC5zcGxpdCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVkQ2VsbFZhbHVlID0gKGpzeFJ1bnRpbWUuanN4KGNvcmUuSGlnaGxpZ2h0LCBPYmplY3QuYXNzaWduKHsgaGlnaGxpZ2h0Q29sb3I6IFwieWVsbG93LjNcIiwgaGlnaGxpZ2h0OiBoaWdobGlnaHQgfSwgaGlnaGxpZ2h0UHJvcHMsIHsgY2hpbGRyZW46IHJlbmRlcmVkQ2VsbFZhbHVlID09PSBudWxsIHx8IHJlbmRlcmVkQ2VsbFZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJlZENlbGxWYWx1ZS50b1N0cmluZygpIH0pKSk7XG4gICAgfVxuICAgIGlmIChjb2x1bW5EZWYuQ2VsbCAmJiAhaXNHcm91cGVkVmFsdWUpIHtcbiAgICAgICAgcmVuZGVyZWRDZWxsVmFsdWUgPSBjb2x1bW5EZWYuQ2VsbCh7XG4gICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgcmVuZGVyZWRDZWxsVmFsdWUsXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICByb3csXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlZENlbGxWYWx1ZTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUJvZHlDZWxsID0gKHsgY2VsbCwgaXNTdHJpcGVkLCBtZWFzdXJlRWxlbWVudCwgbnVtUm93cywgcm93SW5kZXgsIHJvd1JlZiwgdGFibGUsIHZpcnR1YWxDZWxsLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHRoZW1lID0gY29yZS51c2VNYW50aW5lVGhlbWUoKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZUNsaWNrVG9Db3B5LCBlbmFibGVDb2x1bW5PcmRlcmluZywgZW5hYmxlRWRpdGluZywgZW5hYmxlR3JvdXBpbmcsIGVuYWJsZVJvd051bWJlcnMsIGxheW91dE1vZGUsIG1hbnRpbmVUYWJsZUJvZHlDZWxsUHJvcHMsIG1hbnRpbmVTa2VsZXRvblByb3BzLCByb3dOdW1iZXJNb2RlLCB9LCByZWZzOiB7IGVkaXRJbnB1dFJlZnMgfSwgc2V0RWRpdGluZ0NlbGwsIHNldEhvdmVyZWRDb2x1bW4sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNyZWF0aW5nUm93LCBkZW5zaXR5LCBkcmFnZ2luZ0NvbHVtbiwgZHJhZ2dpbmdSb3csIGVkaXRpbmdDZWxsLCBlZGl0aW5nUm93LCBob3ZlcmVkQ29sdW1uLCBob3ZlcmVkUm93LCBpc0xvYWRpbmcsIHNob3dTa2VsZXRvbnMsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uLCByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZlR5cGUgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBtVGFibGVDZWxsQm9keVByb3BzID0gbWFudGluZVRhYmxlQm9keUNlbGxQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRhYmxlQm9keUNlbGxQcm9wcyh7IGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVUYWJsZUJvZHlDZWxsUHJvcHM7XG4gICAgY29uc3QgbWNUYWJsZUNlbGxCb2R5UHJvcHMgPSBjb2x1bW5EZWYubWFudGluZVRhYmxlQm9keUNlbGxQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVUYWJsZUJvZHlDZWxsUHJvcHMoeyBjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUgfSlcbiAgICAgICAgOiBjb2x1bW5EZWYubWFudGluZVRhYmxlQm9keUNlbGxQcm9wcztcbiAgICBjb25zdCB0YWJsZUNlbGxQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbVRhYmxlQ2VsbEJvZHlQcm9wcyksIG1jVGFibGVDZWxsQm9keVByb3BzKTtcbiAgICBjb25zdCBza2VsZXRvblByb3BzID0gbWFudGluZVNrZWxldG9uUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVTa2VsZXRvblByb3BzKHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVNrZWxldG9uUHJvcHM7XG4gICAgY29uc3QgW3NrZWxldG9uV2lkdGgsIHNldFNrZWxldG9uV2lkdGhdID0gcmVhY3QudXNlU3RhdGUoMTAwKTtcbiAgICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoKCFpc0xvYWRpbmcgJiYgIXNob3dTa2VsZXRvbnMpIHx8IHNrZWxldG9uV2lkdGggIT09IDEwMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbHVtbi5nZXRTaXplKCk7XG4gICAgICAgIHNldFNrZWxldG9uV2lkdGgoY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICA/IHNpemUgLyAyXG4gICAgICAgICAgICA6IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChzaXplIC0gc2l6ZSAvIDMpICsgc2l6ZSAvIDMpKTtcbiAgICB9LCBbaXNMb2FkaW5nLCBzaG93U2tlbGV0b25zXSk7XG4gICAgY29uc3QgZHJhZ2dpbmdCb3JkZXJzID0gcmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dpbmdDb2x1bW4gPSAoZHJhZ2dpbmdDb2x1bW4gPT09IG51bGwgfHwgZHJhZ2dpbmdDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgICAgICBjb25zdCBpc0hvdmVyZWRDb2x1bW4gPSAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgICAgICBjb25zdCBpc0RyYWdnaW5nUm93ID0gKGRyYWdnaW5nUm93ID09PSBudWxsIHx8IGRyYWdnaW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkUm93ID0gKGhvdmVyZWRSb3cgPT09IG51bGwgfHwgaG92ZXJlZFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZFJvdy5pZCkgPT09IHJvdy5pZDtcbiAgICAgICAgY29uc3QgaXNGaXJzdENvbHVtbiA9IGdldElzRmlyc3RDb2x1bW4oY29sdW1uLCB0YWJsZSk7XG4gICAgICAgIGNvbnN0IGlzTGFzdENvbHVtbiA9IGdldElzTGFzdENvbHVtbihjb2x1bW4sIHRhYmxlKTtcbiAgICAgICAgY29uc3QgaXNMYXN0Um93ID0gcm93SW5kZXggPT09IG51bVJvd3MgJiYgbnVtUm93cyAtIDE7XG4gICAgICAgIGNvbnN0IGJvcmRlclN0eWxlID0gaXNEcmFnZ2luZ0NvbHVtbiB8fCBpc0RyYWdnaW5nUm93XG4gICAgICAgICAgICA/IGAxcHggZGFzaGVkICR7dGhlbWUuY29sb3JzLmdyYXlbN119ICFpbXBvcnRhbnRgXG4gICAgICAgICAgICA6IGlzSG92ZXJlZENvbHVtbiB8fCBpc0hvdmVyZWRSb3dcbiAgICAgICAgICAgICAgICA/IGAycHggZGFzaGVkICR7Z2V0UHJpbWFyeUNvbG9yKHRoZW1lKX0gIWltcG9ydGFudGBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGJvcmRlclN0eWxlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBpc0RyYWdnaW5nQ29sdW1uIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzSG92ZXJlZENvbHVtbiB8fFxuICAgICAgICAgICAgICAgICAgICAoKGlzRHJhZ2dpbmdSb3cgfHwgaXNIb3ZlcmVkUm93KSAmJiBpc0ZpcnN0Q29sdW1uKVxuICAgICAgICAgICAgICAgICAgICA/IGJvcmRlclN0eWxlXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBpc0RyYWdnaW5nQ29sdW1uIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzSG92ZXJlZENvbHVtbiB8fFxuICAgICAgICAgICAgICAgICAgICAoKGlzRHJhZ2dpbmdSb3cgfHwgaXNIb3ZlcmVkUm93KSAmJiBpc0xhc3RDb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgID8gYm9yZGVyU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBpc0RyYWdnaW5nUm93IHx8IGlzSG92ZXJlZFJvdyB8fCBpc0xhc3RSb3dcbiAgICAgICAgICAgICAgICAgICAgPyBib3JkZXJTdHlsZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGlzRHJhZ2dpbmdSb3cgfHwgaXNIb3ZlcmVkUm93ID8gYm9yZGVyU3R5bGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9LCBbZHJhZ2dpbmdDb2x1bW4sIGRyYWdnaW5nUm93LCBob3ZlcmVkQ29sdW1uLCBob3ZlcmVkUm93LCByb3dJbmRleF0pO1xuICAgIGNvbnN0IGlzRWRpdGFibGUgPSAoZW5hYmxlRWRpdGluZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZW5hYmxlRWRpdGluZyhyb3cpIDogZW5hYmxlRWRpdGluZykgJiZcbiAgICAgICAgKGNvbHVtbkRlZi5lbmFibGVFZGl0aW5nIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gY29sdW1uRGVmLmVuYWJsZUVkaXRpbmcocm93KVxuICAgICAgICAgICAgOiBjb2x1bW5EZWYuZW5hYmxlRWRpdGluZykgIT09IGZhbHNlO1xuICAgIGNvbnN0IGlzRWRpdGluZyA9IGlzRWRpdGFibGUgJiZcbiAgICAgICAgIVsnbW9kYWwnLCAnY3VzdG9tJ10uaW5jbHVkZXMoZWRpdERpc3BsYXlNb2RlKSAmJlxuICAgICAgICAoZWRpdERpc3BsYXlNb2RlID09PSAndGFibGUnIHx8XG4gICAgICAgICAgICAoZWRpdGluZ1JvdyA9PT0gbnVsbCB8fCBlZGl0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0aW5nUm93LmlkKSA9PT0gcm93LmlkIHx8XG4gICAgICAgICAgICAoZWRpdGluZ0NlbGwgPT09IG51bGwgfHwgZWRpdGluZ0NlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRpbmdDZWxsLmlkKSA9PT0gY2VsbC5pZCkgJiZcbiAgICAgICAgIXJvdy5nZXRJc0dyb3VwZWQoKTtcbiAgICBjb25zdCBpc0NyZWF0aW5nID0gaXNFZGl0YWJsZSAmJiBjcmVhdGVEaXNwbGF5TW9kZSA9PT0gJ3JvdycgJiYgKGNyZWF0aW5nUm93ID09PSBudWxsIHx8IGNyZWF0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBoYW5kbGVEb3VibGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRhYmxlQ2VsbFByb3BzID09PSBudWxsIHx8IHRhYmxlQ2VsbFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUNlbGxQcm9wcy5vbkRvdWJsZUNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YWJsZUNlbGxQcm9wcywgZXZlbnQpO1xuICAgICAgICBpZiAoaXNFZGl0YWJsZSAmJiBlZGl0RGlzcGxheU1vZGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgc2V0RWRpdGluZ0NlbGwoY2VsbCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEZpZWxkID0gZWRpdElucHV0UmVmcy5jdXJyZW50W2NlbGwuaWRdO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRleHRGaWVsZC5zZWxlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRleHRGaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMub25EcmFnRW50ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRhYmxlQ2VsbFByb3BzLCBlKTtcbiAgICAgICAgaWYgKGVuYWJsZUdyb3VwaW5nICYmIChob3ZlcmVkQ29sdW1uID09PSBudWxsIHx8IGhvdmVyZWRDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvdmVyZWRDb2x1bW4uaWQpID09PSAnZHJvcC16b25lJykge1xuICAgICAgICAgICAgc2V0SG92ZXJlZENvbHVtbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlQ29sdW1uT3JkZXJpbmcgJiYgZHJhZ2dpbmdDb2x1bW4pIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRDb2x1bW4oY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSA/IGNvbHVtbiA6IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0ZFwiLCBcImRhdGEtaW5kZXhcIjogdmlydHVhbENlbGwgPT09IG51bGwgfHwgdmlydHVhbENlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpcnR1YWxDZWxsLmluZGV4LCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50ID09PSBudWxsIHx8IG1lYXN1cmVFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZWFzdXJlRWxlbWVudChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9LCB0YWJsZUNlbGxQcm9wcywgeyBvbkRyYWdFbnRlcjogaGFuZGxlRHJhZ0VudGVyLCBvbkRvdWJsZUNsaWNrOiBoYW5kbGVEb3VibGVDbGljaywgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGFsaWduSXRlbXM6IGxheW91dE1vZGUgPT09ICdncmlkJyA/ICdjZW50ZXInIDogdW5kZWZpbmVkLCBjdXJzb3I6IGlzRWRpdGFibGUgJiYgZWRpdERpc3BsYXlNb2RlID09PSAnY2VsbCcgPyAncG9pbnRlcicgOiAnaW5oZXJpdCcsIGp1c3RpZnlDb250ZW50OiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyB0YWJsZUNlbGxQcm9wcy5hbGlnbiA6IHVuZGVmaW5lZCwgb3ZlcmZsb3c6ICdoaWRkZW4nLCBwYWRkaW5nTGVmdDogY29sdW1uLmlkID09PSAnbXJ0LXJvdy1leHBhbmQnXG4gICAgICAgICAgICAgICAgPyBgJHtyb3cuZGVwdGggKyAxfXJlbSAhaW1wb3J0YW50YFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB0ZXh0T3ZlcmZsb3c6IGNvbHVtbkRlZlR5cGUgIT09ICdkaXNwbGF5JyA/ICdlbGxpcHNpcycgOiB1bmRlZmluZWQsIHdoaXRlU3BhY2U6IGRlbnNpdHkgPT09ICd4cycgPyAnbm93cmFwJyA6ICdub3JtYWwnLCB6SW5kZXg6IChkcmFnZ2luZ0NvbHVtbiA9PT0gbnVsbCB8fCBkcmFnZ2luZ0NvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdDb2x1bW4uaWQpID09PSBjb2x1bW4uaWQgPyAyIDogY29sdW1uLmdldElzUGlubmVkKCkgPyAxIDogMCwgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogaXNFZGl0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIFsndGFibGUnLCAnY2VsbCddLmluY2x1ZGVzKGVkaXREaXNwbGF5TW9kZSAhPT0gbnVsbCAmJiBlZGl0RGlzcGxheU1vZGUgIT09IHZvaWQgMCA/IGVkaXREaXNwbGF5TW9kZSA6ICcnKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5EZWZUeXBlICE9PSAnZGlzcGxheSdcbiAgICAgICAgICAgICAgICAgICAgPyBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlbN119YFxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvdXRsaW5lT2Zmc2V0OiAnLTFweCcsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnY2xpcCcsXG4gICAgICAgICAgICB9IH0sIGdldENvbW1vbkNlbGxTdHlsZXMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgaXNTdHJpcGVkLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRhYmxlQ2VsbFByb3BzLFxuICAgICAgICB9KSksIGRyYWdnaW5nQm9yZGVycykpLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNlbGwuZ2V0SXNQbGFjZWhvbGRlcigpID8gKChfYiA9IChfYSA9IGNvbHVtbkRlZi5QbGFjZWhvbGRlckNlbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbHVtbkRlZiwgeyBjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUgfSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwpIDogKGlzTG9hZGluZyB8fCBzaG93U2tlbGV0b25zKSAmJlxuICAgICAgICAgICAgICAgICAgICBbdW5kZWZpbmVkLCBudWxsXS5pbmNsdWRlcyhjZWxsLmdldFZhbHVlKCkpID8gKGpzeFJ1bnRpbWUuanN4KGNvcmUuU2tlbGV0b24sIE9iamVjdC5hc3NpZ24oeyBoZWlnaHQ6IDIwLCB3aWR0aDogc2tlbGV0b25XaWR0aCB9LCBza2VsZXRvblByb3BzKSkpIDogZW5hYmxlUm93TnVtYmVycyAmJlxuICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXJNb2RlID09PSAnc3RhdGljJyAmJlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uaWQgPT09ICdtcnQtcm93LW51bWJlcnMnID8gKHJvd0luZGV4ICsgMSkgOiBjb2x1bW5EZWZUeXBlID09PSAnZGlzcGxheScgJiZcbiAgICAgICAgICAgICAgICAgICAgKFsnbXJ0LXJvdy1kcmFnJywgJ21ydC1yb3ctZXhwYW5kJywgJ21ydC1yb3ctc2VsZWN0J10uaW5jbHVkZXMoY29sdW1uLmlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXJvdy5nZXRJc0dyb3VwZWQoKSkgPyAoKF9jID0gY29sdW1uRGVmLkNlbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbHVtbkRlZiwge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgcm93UmVmLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENlbGxWYWx1ZToganN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogY2VsbC5nZXRWYWx1ZSgpIH0pLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICB9KSkgOiBpc0NyZWF0aW5nIHx8IGlzRWRpdGluZyA/IChqc3hSdW50aW1lLmpzeChNUlRfRWRpdENlbGxUZXh0SW5wdXQsIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlIH0pKSA6IChlbmFibGVDbGlja1RvQ29weSB8fCBjb2x1bW5EZWYuZW5hYmxlQ2xpY2tUb0NvcHkpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkRlZi5lbmFibGVDbGlja1RvQ29weSAhPT0gZmFsc2UgPyAoanN4UnVudGltZS5qc3goTVJUX0NvcHlCdXR0b24sIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goTVJUX1RhYmxlQm9keUNlbGxWYWx1ZSwgeyBjZWxsOiBjZWxsLCB0YWJsZTogdGFibGUgfSkgfSkpIDogKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUJvZHlDZWxsVmFsdWUsIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlIH0pKSB9KSwgY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY29sdW1uRGVmLkdyb3VwZWRDZWxsICYmIChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1wiIChcIiwgKF9kID0gcm93LnN1YlJvd3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgsIFwiKVwiXSB9KSldIH0pKSk7XG59O1xuY29uc3QgTWVtb19NUlRfVGFibGVCb2R5Q2VsbCA9IHJlYWN0Lm1lbW8oTVJUX1RhYmxlQm9keUNlbGwsIChwcmV2LCBuZXh0KSA9PiBuZXh0LmNlbGwgPT09IHByZXYuY2VsbCk7XG5cbmNvbnN0IE1SVF9UYWJsZURldGFpbFBhbmVsID0gKHsgcGFyZW50Um93UmVmLCByb3csIHJvd0luZGV4LCB0YWJsZSwgdmlydHVhbFJvdywgfSkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0VmlzaWJsZUxlYWZDb2x1bW5zLCBnZXRTdGF0ZSwgb3B0aW9uczogeyBsYXlvdXRNb2RlLCBtYW50aW5lVGFibGVCb2R5Um93UHJvcHMsIG1hbnRpbmVEZXRhaWxQYW5lbFByb3BzLCByZW5kZXJEZXRhaWxQYW5lbCwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgaXNMb2FkaW5nIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRhYmxlUm93UHJvcHMgPSBtYW50aW5lVGFibGVCb2R5Um93UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUYWJsZUJvZHlSb3dQcm9wcyh7XG4gICAgICAgICAgICBpc0RldGFpbFBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgc3RhdGljUm93SW5kZXg6IHJvd0luZGV4LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pXG4gICAgICAgIDogbWFudGluZVRhYmxlQm9keVJvd1Byb3BzO1xuICAgIGNvbnN0IHRhYmxlQ2VsbFByb3BzID0gbWFudGluZURldGFpbFBhbmVsUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVEZXRhaWxQYW5lbFByb3BzKHsgcm93LCB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVEZXRhaWxQYW5lbFByb3BzO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5Cb3gsIE9iamVjdC5hc3NpZ24oeyBjb21wb25lbnQ6IFwidHJcIiwgY2xhc3NOYW1lOiBcIm1hbnRpbmUtVGFibGVCb2R5Q2VsbC1EZXRhaWxQYW5lbFwiIH0sIHRhYmxlUm93UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6IGxheW91dE1vZGUgPT09ICdncmlkJyA/ICdmbGV4JyA6ICd0YWJsZS1yb3cnLCBwb3NpdGlvbjogdmlydHVhbFJvdyA/ICdhYnNvbHV0ZScgOiB1bmRlZmluZWQsIHRvcDogdmlydHVhbFJvd1xuICAgICAgICAgICAgICAgICAgICA/IGAkeyhfYiA9IChfYSA9IHBhcmVudFJvd1JlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHR9cHhgXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB0cmFuc2Zvcm06IHZpcnR1YWxSb3dcbiAgICAgICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlWSgke3ZpcnR1YWxSb3cgPT09IG51bGwgfHwgdmlydHVhbFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlydHVhbFJvdy5zdGFydH1weClgXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB3aWR0aDogJzEwMCUnLCB6SW5kZXg6IHZpcnR1YWxSb3cgPyAyIDogdW5kZWZpbmVkIH0sICgodGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyB0YWJsZVJvd1Byb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgIDogdGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN4KSkpO1xuICAgICAgICB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5Cb3gsIE9iamVjdC5hc3NpZ24oeyBjb21wb25lbnQ6IFwidGRcIiwgY2xhc3NOYW1lOiBcIm1hbnRpbmUtVGFibGVCb2R5Q2VsbC1EZXRhaWxQYW5lbFwiLCBjb2xTcGFuOiBnZXRWaXNpYmxlTGVhZkNvbHVtbnMoKS5sZW5ndGggfSwgdGFibGVDZWxsUHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBiYWNrZ3JvdW5kQ29sb3I6IHZpcnR1YWxSb3dcbiAgICAgICAgICAgICAgICAgICAgPyB0aGVtZS5mbi5saWdodGVuKHRoZW1lLmNvbG9ycy5kYXJrWzddLCAwLjA2KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgYm9yZGVyQm90dG9tOiAhcm93LmdldElzRXhwYW5kZWQoKSA/ICdub25lJyA6IHVuZGVmaW5lZCwgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2ZsZXgnIDogJ3RhYmxlLWNlbGwnLCBwYWRkaW5nQm90dG9tOiByb3cuZ2V0SXNFeHBhbmRlZCgpXG4gICAgICAgICAgICAgICAgICAgID8gJzE2cHggIWltcG9ydGFudCdcbiAgICAgICAgICAgICAgICAgICAgOiAnMCAhaW1wb3J0YW50JywgcGFkZGluZ1RvcDogcm93LmdldElzRXhwYW5kZWQoKSA/ICcxNnB4ICFpbXBvcnRhbnQnIDogJzAgIWltcG9ydGFudCcsIHRyYW5zaXRpb246ICdhbGwgMTAwbXMgZWFzZS1pbi1vdXQnLCB3aWR0aDogYCR7dGFibGUuZ2V0VG90YWxTaXplKCl9cHhgIH0sICgodGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyB0YWJsZUNlbGxQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgICAgICA6IHRhYmxlQ2VsbFByb3BzID09PSBudWxsIHx8IHRhYmxlQ2VsbFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUNlbGxQcm9wcy5zeCkpKSwgY2hpbGRyZW46IHJlbmRlckRldGFpbFBhbmVsICYmIChqc3hSdW50aW1lLmpzeChjb3JlLkNvbGxhcHNlLCB7IGluOiByb3cuZ2V0SXNFeHBhbmRlZCgpLCBjaGlsZHJlbjogIWlzTG9hZGluZyAmJiByZW5kZXJEZXRhaWxQYW5lbCh7IHJvdywgdGFibGUgfSkgfSkpIH0pKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlQm9keVJvdyA9ICh7IGNvbHVtblZpcnR1YWxpemVyLCBlbmFibGVIb3ZlciwgaXNTdHJpcGVkLCBtZWFzdXJlRWxlbWVudCwgbnVtUm93cywgcm93LCByb3dJbmRleCwgdGFibGUsIHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQsIHZpcnR1YWxSb3csIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVJvd09yZGVyaW5nLCBsYXlvdXRNb2RlLCBtZW1vTW9kZSwgbWFudGluZVRhYmxlQm9keVJvd1Byb3BzLCByZW5kZXJEZXRhaWxQYW5lbCwgfSwgc2V0SG92ZXJlZFJvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZHJhZ2dpbmdDb2x1bW4sIGRyYWdnaW5nUm93LCBlZGl0aW5nQ2VsbCwgZWRpdGluZ1JvdywgaG92ZXJlZFJvdyB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZVJvd1Byb3BzID0gbWFudGluZVRhYmxlQm9keVJvd1Byb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lVGFibGVCb2R5Um93UHJvcHMoeyByb3csIHN0YXRpY1Jvd0luZGV4OiByb3dJbmRleCwgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lVGFibGVCb2R5Um93UHJvcHM7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKF9lKSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVSb3dPcmRlcmluZyAmJiBkcmFnZ2luZ1Jvdykge1xuICAgICAgICAgICAgc2V0SG92ZXJlZFJvdyhyb3cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByb3dSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0clwiLCBcImRhdGEtaW5kZXhcIjogdmlydHVhbFJvdyA9PT0gbnVsbCB8fCB2aXJ0dWFsUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXJ0dWFsUm93LmluZGV4LCBvbkRyYWdFbnRlcjogaGFuZGxlRHJhZ0VudGVyLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudCA9PT0gbnVsbCB8fCBtZWFzdXJlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVhc3VyZUVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IH0sIHRhYmxlUm93UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBib3hTaXppbmc6ICdib3JkZXItYm94JywgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2ZsZXgnIDogJ3RhYmxlLXJvdycsIG9wYWNpdHk6IChkcmFnZ2luZ1JvdyA9PT0gbnVsbCB8fCBkcmFnZ2luZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdSb3cuaWQpID09PSByb3cuaWQgfHwgKGhvdmVyZWRSb3cgPT09IG51bGwgfHwgaG92ZXJlZFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZFJvdy5pZCkgPT09IHJvdy5pZCA/IDAuNSA6IDEsIHBvc2l0aW9uOiB2aXJ0dWFsUm93ID8gJ2Fic29sdXRlJyA6IHVuZGVmaW5lZCwgdG9wOiB2aXJ0dWFsUm93ID8gMCA6IHVuZGVmaW5lZCwgdHJhbnNpdGlvbjogdmlydHVhbFJvdyA/ICdub25lJyA6ICdhbGwgMTAwbXMgZWFzZS1pbi1vdXQnLCB3aWR0aDogJzEwMCUnLCAnJjpob3ZlciB0ZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZW5hYmxlSG92ZXIgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByb3cuZ2V0SXNTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhlbWUuZm4ucmdiYShnZXRQcmltYXJ5Q29sb3IodGhlbWUpLCAwLjIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhlbWUuY29sb3JTY2hlbWUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHt0aGVtZS5mbi5saWdodGVuKHRoZW1lLmNvbG9ycy5kYXJrWzddLCAwLjEyKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAke3RoZW1lLmZuLmRhcmtlbih0aGVtZS53aGl0ZSwgMC4wNSl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9IH0sICgodGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gdGFibGVSb3dQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3gpKSksIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgdHJhbnNmb3JtOiB2aXJ0dWFsUm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGB0cmFuc2xhdGVZKCR7dmlydHVhbFJvdyA9PT0gbnVsbCB8fCB2aXJ0dWFsUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXJ0dWFsUm93LnN0YXJ0fXB4KWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHRhYmxlUm93UHJvcHMgPT09IG51bGwgfHwgdGFibGVSb3dQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dQcm9wcy5zdHlsZSksIGNoaWxkcmVuOiBbdmlydHVhbFBhZGRpbmdMZWZ0ID8gKGpzeFJ1bnRpbWUuanN4KFwidGRcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiAnZmxleCcsIHdpZHRoOiB2aXJ0dWFsUGFkZGluZ0xlZnQgfSB9KSkgOiBudWxsLCAodmlydHVhbENvbHVtbnMgIT09IG51bGwgJiYgdmlydHVhbENvbHVtbnMgIT09IHZvaWQgMCA/IHZpcnR1YWxDb2x1bW5zIDogcm93LmdldFZpc2libGVDZWxscygpKS5tYXAoKGNlbGxPclZpcnR1YWxDZWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNvbHVtblZpcnR1YWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByb3cuZ2V0VmlzaWJsZUNlbGxzKClbY2VsbE9yVmlydHVhbENlbGwuaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjZWxsT3JWaXJ0dWFsQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTdHJpcGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50OiBjb2x1bW5WaXJ0dWFsaXplciA9PT0gbnVsbCB8fCBjb2x1bW5WaXJ0dWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uVmlydHVhbGl6ZXIubWVhc3VyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUm93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlydHVhbENlbGw6IGNvbHVtblZpcnR1YWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbE9yVmlydHVhbENlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9Nb2RlID09PSAnY2VsbHMnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2x1bW4uY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFkcmFnZ2luZ0NvbHVtbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFkcmFnZ2luZ1JvdyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlZGl0aW5nQ2VsbCA9PT0gbnVsbCB8fCBlZGl0aW5nQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ0NlbGwuaWQpICE9PSBjZWxsLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkaXRpbmdSb3cgPT09IG51bGwgfHwgZWRpdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ1Jvdy5pZCkgIT09IHJvdy5pZCA/IChqc3hSdW50aW1lLmpzeChNZW1vX01SVF9UYWJsZUJvZHlDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIGNlbGwuaWQgKyAoKF9hID0gY2VsbC5nZXRWYWx1ZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkpKSA6IChqc3hSdW50aW1lLmpzeChNUlRfVGFibGVCb2R5Q2VsbCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCBjZWxsLmlkICsgKChfYiA9IGNlbGwuZ2V0VmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdmlydHVhbFBhZGRpbmdSaWdodCA/IChqc3hSdW50aW1lLmpzeChcInRkXCIsIHsgc3R5bGU6IHsgZGlzcGxheTogJ2ZsZXgnLCB3aWR0aDogdmlydHVhbFBhZGRpbmdSaWdodCB9IH0pKSA6IG51bGxdIH0pKSwgcmVuZGVyRGV0YWlsUGFuZWwgJiYgIXJvdy5nZXRJc0dyb3VwZWQoKSAmJiAoanN4UnVudGltZS5qc3goTVJUX1RhYmxlRGV0YWlsUGFuZWwsIHsgcGFyZW50Um93UmVmOiByb3dSZWYsIHJvdzogcm93LCByb3dJbmRleDogcm93SW5kZXgsIHRhYmxlOiB0YWJsZSwgdmlydHVhbFJvdzogdmlydHVhbFJvdyB9KSldIH0pKTtcbn07XG5jb25zdCBNZW1vX01SVF9UYWJsZUJvZHlSb3cgPSByZWFjdC5tZW1vKE1SVF9UYWJsZUJvZHlSb3csIChwcmV2LCBuZXh0KSA9PiBwcmV2LnJvdyA9PT0gbmV4dC5yb3cgJiYgcHJldi5yb3dJbmRleCA9PT0gbmV4dC5yb3dJbmRleCk7XG5cbmNvbnN0IE1SVF9UYWJsZUJvZHkgPSAoeyBjb2x1bW5WaXJ0dWFsaXplciwgZW5hYmxlSG92ZXIsIGlzU3RyaXBlZCwgdGFibGUsIHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGdldFJvd01vZGVsLCBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwsIGdldFN0YXRlLCBvcHRpb25zOiB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlbmFibGVHbG9iYWxGaWx0ZXJSYW5rZWRSZXN1bHRzLCBlbmFibGVQYWdpbmF0aW9uLCBlbmFibGVSb3dWaXJ0dWFsaXphdGlvbiwgbGF5b3V0TW9kZSwgbG9jYWxpemF0aW9uLCBtYW50aW5lVGFibGVCb2R5UHJvcHMsIG1hbnVhbEV4cGFuZGluZywgbWFudWFsRmlsdGVyaW5nLCBtYW51YWxHcm91cGluZywgbWFudWFsUGFnaW5hdGlvbiwgbWFudWFsU29ydGluZywgbWVtb01vZGUsIHJlbmRlckVtcHR5Um93c0ZhbGxiYWNrLCByb3dWaXJ0dWFsaXplckluc3RhbmNlUmVmLCByb3dWaXJ0dWFsaXplclByb3BzLCB9LCByZWZzOiB7IHRhYmxlQ29udGFpbmVyUmVmLCB0YWJsZVBhcGVyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNyZWF0aW5nUm93LCBjb2x1bW5GaWx0ZXJzLCBkZW5zaXR5LCBleHBhbmRlZCwgZ2xvYmFsRmlsdGVyLCBwYWdpbmF0aW9uLCBzb3J0aW5nLCB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZUJvZHlQcm9wcyA9IG1hbnRpbmVUYWJsZUJvZHlQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRhYmxlQm9keVByb3BzKHsgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lVGFibGVCb2R5UHJvcHM7XG4gICAgY29uc3QgdlByb3BzID0gcm93VmlydHVhbGl6ZXJQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gcm93VmlydHVhbGl6ZXJQcm9wcyh7IHRhYmxlIH0pXG4gICAgICAgIDogcm93VmlydHVhbGl6ZXJQcm9wcztcbiAgICBjb25zdCBzaG91bGRSYW5rUm93cyA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0Q2FuUmFua1Jvd3ModGFibGUpICYmXG4gICAgICAgICFPYmplY3QudmFsdWVzKHNvcnRpbmcpLnNvbWUoQm9vbGVhbikgJiZcbiAgICAgICAgZ2xvYmFsRmlsdGVyLCBbXG4gICAgICAgIGVuYWJsZUdsb2JhbEZpbHRlclJhbmtlZFJlc3VsdHMsXG4gICAgICAgIGV4cGFuZGVkLFxuICAgICAgICBnbG9iYWxGaWx0ZXIsXG4gICAgICAgIG1hbnVhbEV4cGFuZGluZyxcbiAgICAgICAgbWFudWFsRmlsdGVyaW5nLFxuICAgICAgICBtYW51YWxHcm91cGluZyxcbiAgICAgICAgbWFudWFsU29ydGluZyxcbiAgICAgICAgc29ydGluZyxcbiAgICBdKTtcbiAgICBjb25zdCByb3dzID0gcmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkUmFua1Jvd3MpXG4gICAgICAgICAgICByZXR1cm4gZ2V0Um93TW9kZWwoKS5yb3dzO1xuICAgICAgICBjb25zdCByYW5rZWRSb3dzID0gZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5zb3J0KChhLCBiKSA9PiByYW5rR2xvYmFsRnV6enkoYSwgYikpO1xuICAgICAgICBpZiAoZW5hYmxlUGFnaW5hdGlvbiAmJiAhbWFudWFsUGFnaW5hdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwYWdpbmF0aW9uLnBhZ2VJbmRleCAqIHBhZ2luYXRpb24ucGFnZVNpemU7XG4gICAgICAgICAgICByZXR1cm4gcmFua2VkUm93cy5zbGljZShzdGFydCwgc3RhcnQgKyBwYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFua2VkUm93cztcbiAgICB9LCBbXG4gICAgICAgIHNob3VsZFJhbmtSb3dzLFxuICAgICAgICBzaG91bGRSYW5rUm93cyA/IGdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MgOiBnZXRSb3dNb2RlbCgpLnJvd3MsXG4gICAgICAgIHBhZ2luYXRpb24ucGFnZUluZGV4LFxuICAgICAgICBwYWdpbmF0aW9uLnBhZ2VTaXplLFxuICAgIF0pO1xuICAgIGNvbnN0IHJvd1ZpcnR1YWxpemVyID0gZW5hYmxlUm93VmlydHVhbGl6YXRpb25cbiAgICAgICAgPyByZWFjdFZpcnR1YWwudXNlVmlydHVhbGl6ZXIoT2JqZWN0LmFzc2lnbih7IGNvdW50OiByb3dzLmxlbmd0aCwgZXN0aW1hdGVTaXplOiAoKSA9PiBkZW5zaXR5ID09PSAneHMnID8gNDIuNyA6IGRlbnNpdHkgPT09ICdtZCcgPyA1NC43IDogNzAuNywgZ2V0U2Nyb2xsRWxlbWVudDogKCkgPT4gdGFibGVDb250YWluZXJSZWYuY3VycmVudCwgbWVhc3VyZUVsZW1lbnQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xXG4gICAgICAgICAgICAgICAgPyAoZWxlbWVudCkgPT4gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvdmVyc2NhbjogNCB9LCB2UHJvcHMpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAocm93VmlydHVhbGl6ZXJJbnN0YW5jZVJlZiAmJiByb3dWaXJ0dWFsaXplcikge1xuICAgICAgICByb3dWaXJ0dWFsaXplckluc3RhbmNlUmVmLmN1cnJlbnQgPSByb3dWaXJ0dWFsaXplcjtcbiAgICB9XG4gICAgY29uc3QgdmlydHVhbFJvd3MgPSByb3dWaXJ0dWFsaXplclxuICAgICAgICA/IHJvd1ZpcnR1YWxpemVyLmdldFZpcnR1YWxJdGVtcygpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuQm94LCBPYmplY3QuYXNzaWduKHsgY29tcG9uZW50OiBcInRib2R5XCIgfSwgdGFibGVCb2R5UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5OiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnZ3JpZCcgOiAndGFibGUtcm93LWdyb3VwJywgaGVpZ2h0OiByb3dWaXJ0dWFsaXplclxuICAgICAgICAgICAgICAgID8gYCR7cm93VmlydHVhbGl6ZXIuZ2V0VG90YWxTaXplKCl9cHhgXG4gICAgICAgICAgICAgICAgOiAnaW5oZXJpdCcsIG1pbkhlaWdodDogIXJvd3MubGVuZ3RoID8gJzEwMHB4JyA6IHVuZGVmaW5lZCwgcG9zaXRpb246ICdyZWxhdGl2ZScgfSwgKCh0YWJsZUJvZHlQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUJvZHlQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVCb2R5UHJvcHMuc3gpIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gdGFibGVCb2R5UHJvcHMgPT09IG51bGwgfHwgdGFibGVCb2R5UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQm9keVByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgOiB0YWJsZUJvZHlQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUJvZHlQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVCb2R5UHJvcHMuc3gpKSksIGNoaWxkcmVuOiBbY3JlYXRpbmdSb3cgJiYgY3JlYXRlRGlzcGxheU1vZGUgPT09ICdyb3cnICYmIChqc3hSdW50aW1lLmpzeChNUlRfVGFibGVCb2R5Um93LCB7IHRhYmxlOiB0YWJsZSwgcm93OiBjcmVhdGluZ1Jvdywgcm93SW5kZXg6IC0xIH0pKSwgIXJvd3MubGVuZ3RoID8gKGpzeFJ1bnRpbWUuanN4KFwidHJcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnZ3JpZCcgOiAndGFibGUtcm93JyB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goXCJ0ZFwiLCB7IGNvbFNwYW46IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLmxlbmd0aCwgc3R5bGU6IHsgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2dyaWQnIDogJ3RhYmxlLWNlbGwnIH0sIGNoaWxkcmVuOiAoX2EgPSByZW5kZXJFbXB0eVJvd3NGYWxsYmFjayA9PT0gbnVsbCB8fCByZW5kZXJFbXB0eVJvd3NGYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyRW1wdHlSb3dzRmFsbGJhY2soeyB0YWJsZSB9KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGpzeFJ1bnRpbWUuanN4KGNvcmUuVGV4dCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ3JheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogYG1pbigxMDB2dywgJHsoX2MgPSAoX2IgPSB0YWJsZVBhcGVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGllbnRXaWR0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMzYwfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzJyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcycmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogZ2xvYmFsRmlsdGVyIHx8IGNvbHVtbkZpbHRlcnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhbGl6YXRpb24ubm9SZXN1bHRzRm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsaXphdGlvbi5ub1JlY29yZHNUb0Rpc3BsYXkgfSkpIH0pIH0pKSA6IChqc3hSdW50aW1lLmpzeChqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiAodmlydHVhbFJvd3MgIT09IG51bGwgJiYgdmlydHVhbFJvd3MgIT09IHZvaWQgMCA/IHZpcnR1YWxSb3dzIDogcm93cykubWFwKChyb3dPclZpcnR1YWxSb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJvd1ZpcnR1YWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJvd3Nbcm93T3JWaXJ0dWFsUm93LmluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByb3dPclZpcnR1YWxSb3c7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uVmlydHVhbGl6ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RyaXBlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50OiByb3dWaXJ0dWFsaXplciA9PT0gbnVsbCB8fCByb3dWaXJ0dWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93VmlydHVhbGl6ZXIubWVhc3VyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Sb3dzOiByb3dzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiByb3dWaXJ0dWFsaXplciA/IHJvd09yVmlydHVhbFJvdy5pbmRleCA6IHJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsQ29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxQYWRkaW5nTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxQYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsUm93OiByb3dWaXJ0dWFsaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcm93T3JWaXJ0dWFsUm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vTW9kZSA9PT0gJ3Jvd3MnID8gKGpzeFJ1bnRpbWUuanN4KE1lbW9fTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQgfHwgYG1ydC0ke3Jvdy5pbmRleH1gKSkgOiAoanN4UnVudGltZS5qc3goTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQgfHwgYG1ydC0ke3Jvdy5pbmRleH1gKSk7XG4gICAgICAgICAgICAgICAgfSkgfSkpXSB9KSkpO1xufTtcbmNvbnN0IE1lbW9fTVJUX1RhYmxlQm9keSA9IHJlYWN0Lm1lbW8oTVJUX1RhYmxlQm9keSwgKHByZXYsIG5leHQpID0+IHByZXYudGFibGUub3B0aW9ucy5kYXRhID09PSBuZXh0LnRhYmxlLm9wdGlvbnMuZGF0YSk7XG5cbmNvbnN0IE1SVF9HcmFiSGFuZGxlQnV0dG9uID0gKHsgYWN0aW9uSWNvblByb3BzLCBvbkRyYWdFbmQsIG9uRHJhZ1N0YXJ0LCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgSWNvbkdyaXBIb3Jpem9udGFsIH0sIGxvY2FsaXphdGlvbiwgfSwgfSA9IHRhYmxlO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgb3BlbkRlbGF5OiAxMDAwLCBsYWJlbDogKF9hID0gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnRpdGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsb2NhbGl6YXRpb24ubW92ZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgT2JqZWN0LmFzc2lnbih7IGRyYWdnYWJsZTogXCJ0cnVlXCIsIHNpemU6IFwic21cIiB9LCBhY3Rpb25JY29uUHJvcHMsIHsgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBhY3Rpb25JY29uUHJvcHMgPT09IG51bGwgfHwgYWN0aW9uSWNvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25JY29uUHJvcHMub25DbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9uSWNvblByb3BzLCBlKTtcbiAgICAgICAgICAgIH0sIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydCwgb25EcmFnRW5kOiBvbkRyYWdFbmQsIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgY3Vyc29yOiAnZ3JhYicsIG1hcmdpbjogJzAgLTAuMTZweCcsIG9wYWNpdHk6IDAuNSwgcGFkZGluZzogJzJweCcsIHRyYW5zaXRpb246ICdvcGFjaXR5IDEwMG1zIGVhc2UtaW4tb3V0JywgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB9LCAnJjphY3RpdmUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2dyYWJiaW5nJyxcbiAgICAgICAgICAgICAgICB9IH0sICgoYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyBhY3Rpb25JY29uUHJvcHMgPT09IG51bGwgfHwgYWN0aW9uSWNvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25JY29uUHJvcHMuc3godGhlbWUpXG4gICAgICAgICAgICAgICAgOiBhY3Rpb25JY29uUHJvcHMgPT09IG51bGwgfHwgYWN0aW9uSWNvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25JY29uUHJvcHMuc3gpKSksIHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uR3JpcEhvcml6b250YWwsIHt9KSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlQm9keVJvd0dyYWJIYW5kbGUgPSAoeyByb3csIHJvd1JlZiwgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgbWFudGluZVJvd0RyYWdIYW5kbGVQcm9wcyB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgYWN0aW9uSWNvblByb3BzID0gbWFudGluZVJvd0RyYWdIYW5kbGVQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVJvd0RyYWdIYW5kbGVQcm9wcyh7IHJvdywgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lUm93RHJhZ0hhbmRsZVByb3BzO1xuICAgIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy5vbkRyYWdTdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9uSWNvblByb3BzLCBldmVudCk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2Uocm93UmVmLmN1cnJlbnQsIDAsIDApO1xuICAgICAgICB0YWJsZS5zZXREcmFnZ2luZ1Jvdyhyb3cpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy5vbkRyYWdFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbkljb25Qcm9wcywgZXZlbnQpO1xuICAgICAgICB0YWJsZS5zZXREcmFnZ2luZ1JvdyhudWxsKTtcbiAgICAgICAgdGFibGUuc2V0SG92ZXJlZFJvdyhudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goTVJUX0dyYWJIYW5kbGVCdXR0b24sIHsgYWN0aW9uSWNvblByb3BzOiBhY3Rpb25JY29uUHJvcHMsIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsIG9uRHJhZ0VuZDogaGFuZGxlRHJhZ0VuZCwgdGFibGU6IHRhYmxlIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9FeHBhbmRBbGxCdXR0b24gPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBnZXRJc0FsbFJvd3NFeHBhbmRlZCwgZ2V0SXNTb21lUm93c0V4cGFuZGVkLCBnZXRDYW5Tb21lUm93c0V4cGFuZCwgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgSWNvbkNoZXZyb25zRG93biB9LCBsb2NhbGl6YXRpb24sIG1hbnRpbmVFeHBhbmRBbGxCdXR0b25Qcm9wcywgcmVuZGVyRGV0YWlsUGFuZWwsIH0sIHRvZ2dsZUFsbFJvd3NFeHBhbmRlZCwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZGVuc2l0eSwgaXNMb2FkaW5nIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGFjdGlvbkljb25Qcm9wcyA9IG1hbnRpbmVFeHBhbmRBbGxCdXR0b25Qcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUV4cGFuZEFsbEJ1dHRvblByb3BzKHsgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lRXhwYW5kQWxsQnV0dG9uUHJvcHM7XG4gICAgY29uc3QgaXNBbGxSb3dzRXhwYW5kZWQgPSBnZXRJc0FsbFJvd3NFeHBhbmRlZCgpO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgb3BlbkRlbGF5OiAxMDAwLCBsYWJlbDogKChfYSA9IGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaXNBbGxSb3dzRXhwYW5kZWQpXG4gICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5jb2xsYXBzZUFsbFxuICAgICAgICAgICAgOiBsb2NhbGl6YXRpb24uZXhwYW5kQWxsLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5leHBhbmRBbGwsIGRpc2FibGVkOiBpc0xvYWRpbmcgfHwgKCFyZW5kZXJEZXRhaWxQYW5lbCAmJiAhZ2V0Q2FuU29tZVJvd3NFeHBhbmQoKSksIG9uQ2xpY2s6ICgpID0+IHRvZ2dsZUFsbFJvd3NFeHBhbmRlZCghaXNBbGxSb3dzRXhwYW5kZWQpIH0sIGFjdGlvbkljb25Qcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IG1hcmdpbkxlZnQ6IGRlbnNpdHkgPT09ICd4bCcgPyAnLTZweCcgOiBkZW5zaXR5ID09PSAnbWQnID8gJzAnIDogJzZweCcsIG9wYWNpdHk6IDAuOCwgJyY6ZGlzYWJsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgfSwgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgfSB9LCAoKGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgID8gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgIDogYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnN4KSkpLCB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogKF9iID0gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoanN4UnVudGltZS5qc3goSWNvbkNoZXZyb25zRG93biwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoJHtpc0FsbFJvd3NFeHBhbmRlZCA/IC0xODAgOiBnZXRJc1NvbWVSb3dzRXhwYW5kZWQoKSA/IC05MCA6IDB9ZGVnKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTAwbXMnLFxuICAgICAgICAgICAgICAgIH0gfSkpIH0pKSB9KSk7XG59O1xuXG5jb25zdCBNUlRfRXhwYW5kQnV0dG9uID0gKHsgcm93LCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGljb25zOiB7IEljb25DaGV2cm9uRG93biB9LCBsb2NhbGl6YXRpb24sIG1hbnRpbmVFeHBhbmRCdXR0b25Qcm9wcywgcmVuZGVyRGV0YWlsUGFuZWwsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCBhY3Rpb25JY29uUHJvcHMgPSBtYW50aW5lRXhwYW5kQnV0dG9uUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVFeHBhbmRCdXR0b25Qcm9wcyh7IHRhYmxlLCByb3cgfSlcbiAgICAgICAgOiBtYW50aW5lRXhwYW5kQnV0dG9uUHJvcHM7XG4gICAgY29uc3QgY2FuRXhwYW5kID0gcm93LmdldENhbkV4cGFuZCgpO1xuICAgIGNvbnN0IGlzRXhwYW5kZWQgPSByb3cuZ2V0SXNFeHBhbmRlZCgpO1xuICAgIGNvbnN0IGhhbmRsZVRvZ2dsZUV4cGFuZCA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByb3cudG9nZ2xlRXhwYW5kZWQoKTtcbiAgICAgICAgKF9hID0gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLm9uQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbkljb25Qcm9wcywgZXZlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBkaXNhYmxlZDogIWNhbkV4cGFuZCAmJiAhcmVuZGVyRGV0YWlsUGFuZWwsIG9wZW5EZWxheTogMTAwMCwgbGFiZWw6ICgoX2EgPSBhY3Rpb25JY29uUHJvcHMgPT09IG51bGwgfHwgYWN0aW9uSWNvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25JY29uUHJvcHMudGl0bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGlzRXhwYW5kZWQpXG4gICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5jb2xsYXBzZVxuICAgICAgICAgICAgOiBsb2NhbGl6YXRpb24uZXhwYW5kLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5leHBhbmQsIGRpc2FibGVkOiAhY2FuRXhwYW5kICYmICFyZW5kZXJEZXRhaWxQYW5lbCB9LCBhY3Rpb25JY29uUHJvcHMsIHsgb25DbGljazogaGFuZGxlVG9nZ2xlRXhwYW5kLCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IG9wYWNpdHk6IDAuOCwgJyY6ZGlzYWJsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgfSwgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgfSB9LCAoKGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgID8gYWN0aW9uSWNvblByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgIDogYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnN4KSkpLCB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogKF9iID0gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoanN4UnVudGltZS5qc3goSWNvbkNoZXZyb25Eb3duLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgkeyFjYW5FeHBhbmQgJiYgIXJlbmRlckRldGFpbFBhbmVsID8gLTkwIDogaXNFeHBhbmRlZCA/IC0xODAgOiAwfWRlZylgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDEwMG1zJyxcbiAgICAgICAgICAgICAgICB9IH0pKSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1Jvd0FjdGlvbk1lbnUgPSAoeyBoYW5kbGVFZGl0LCByb3csIHRhYmxlLCB9KSA9PiB7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGVkaXREaXNwbGF5TW9kZSwgZW5hYmxlRWRpdGluZywgaWNvbnM6IHsgSWNvbkVkaXQsIEljb25Eb3RzIH0sIGxvY2FsaXphdGlvbiwgcG9zaXRpb25BY3Rpb25zQ29sdW1uLCByZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMsIH0sIH0gPSB0YWJsZTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLk1lbnUsIHsgcG9zaXRpb246IHBvc2l0aW9uQWN0aW9uc0NvbHVtbiA9PT0gJ2ZpcnN0J1xuICAgICAgICAgICAgPyAnYm90dG9tLXN0YXJ0J1xuICAgICAgICAgICAgOiBwb3NpdGlvbkFjdGlvbnNDb2x1bW4gPT09ICdsYXN0J1xuICAgICAgICAgICAgICAgID8gJ2JvdHRvbS1lbmQnXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIGNsb3NlT25JdGVtQ2xpY2s6IHRydWUsIHdpdGhpblBvcnRhbDogdHJ1ZSwgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBvcGVuRGVsYXk6IDEwMDAsIGxhYmVsOiBsb2NhbGl6YXRpb24ucm93QWN0aW9ucywgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5UYXJnZXQsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnJvd0FjdGlvbnMsIG9uQ2xpY2s6IChldmVudCkgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHNpemU6IFwic21cIiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25Eb3RzLCB7fSkgfSkgfSkgfSksIGpzeFJ1bnRpbWUuanN4cyhjb3JlLk1lbnUuRHJvcGRvd24sIHsgb25DbGljazogKGV2ZW50KSA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgY2hpbGRyZW46IFtlbmFibGVFZGl0aW5nICYmIGVkaXREaXNwbGF5TW9kZSAhPT0gJ3RhYmxlJyAmJiAoanN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgaWNvbjoganN4UnVudGltZS5qc3goSWNvbkVkaXQsIHt9KSwgb25DbGljazogaGFuZGxlRWRpdCwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5lZGl0IH0pKSwgcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlclJvd0FjdGlvbk1lbnVJdGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICB9KV0gfSldIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9FZGl0QWN0aW9uQnV0dG9ucyA9ICh7IHJvdywgdGFibGUsIHZhcmlhbnQgPSAnaWNvbicsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGljb25zOiB7IEljb25DaXJjbGVYLCBJY29uRGV2aWNlRmxvcHB5IH0sIGxvY2FsaXphdGlvbiwgb25DcmVhdGluZ1Jvd0NhbmNlbCwgb25DcmVhdGluZ1Jvd1NhdmUsIG9uRWRpdGluZ1Jvd1NhdmUsIG9uRWRpdGluZ1Jvd0NhbmNlbCwgfSwgcmVmczogeyBlZGl0SW5wdXRSZWZzIH0sIHNldENyZWF0aW5nUm93LCBzZXRFZGl0aW5nUm93LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjcmVhdGluZ1JvdywgZWRpdGluZ1JvdywgaXNTYXZpbmcgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNDcmVhdGluZyA9IChjcmVhdGluZ1JvdyA9PT0gbnVsbCB8fCBjcmVhdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaXNFZGl0aW5nID0gKGVkaXRpbmdSb3cgPT09IG51bGwgfHwgZWRpdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc0NyZWF0aW5nKSB7XG4gICAgICAgICAgICBvbkNyZWF0aW5nUm93Q2FuY2VsID09PSBudWxsIHx8IG9uQ3JlYXRpbmdSb3dDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ3JlYXRpbmdSb3dDYW5jZWwoeyByb3csIHRhYmxlIH0pO1xuICAgICAgICAgICAgc2V0Q3JlYXRpbmdSb3cobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvbkVkaXRpbmdSb3dDYW5jZWwgPT09IG51bGwgfHwgb25FZGl0aW5nUm93Q2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkVkaXRpbmdSb3dDYW5jZWwoeyByb3csIHRhYmxlIH0pO1xuICAgICAgICAgICAgc2V0RWRpdGluZ1JvdyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByb3cuX3ZhbHVlc0NhY2hlID0ge307IC8vcmVzZXQgdmFsdWVzIGNhY2hlXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTdWJtaXRSb3cgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy9sb29rIGZvciBhdXRvLWZpbGxlZCBpbnB1dCB2YWx1ZXNcbiAgICAgICAgKF9hID0gT2JqZWN0LnZhbHVlcyhlZGl0SW5wdXRSZWZzID09PSBudWxsIHx8IGVkaXRJbnB1dFJlZnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRJbnB1dFJlZnMuY3VycmVudClcbiAgICAgICAgICAgIC5maWx0ZXIoKGlucHV0UmVmKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiByb3cuaWQgPT09ICgoX2IgPSAoX2EgPSBpbnB1dFJlZiA9PT0gbnVsbCB8fCBpbnB1dFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRSZWYubmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCdfJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSk7IH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0Lmhhc093bihyb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuX3ZhbHVlc0NhY2hlLCBpbnB1dC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2lucHV0Lm5hbWVdID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNDcmVhdGluZylcbiAgICAgICAgICAgIG9uQ3JlYXRpbmdSb3dTYXZlID09PSBudWxsIHx8IG9uQ3JlYXRpbmdSb3dTYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNyZWF0aW5nUm93U2F2ZSh7XG4gICAgICAgICAgICAgICAgZXhpdENyZWF0aW5nTW9kZTogKCkgPT4gc2V0Q3JlYXRpbmdSb3cobnVsbCksXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgIHZhbHVlczogcm93Ll92YWx1ZXNDYWNoZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9uRWRpdGluZ1Jvd1NhdmUgPT09IG51bGwgfHwgb25FZGl0aW5nUm93U2F2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FZGl0aW5nUm93U2F2ZSh7XG4gICAgICAgICAgICAgICAgZXhpdEVkaXRpbmdNb2RlOiAoKSA9PiBzZXRFZGl0aW5nUm93KG51bGwpLFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvdy5fdmFsdWVzQ2FjaGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgeyBvbkNsaWNrOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSwgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBnYXA6ICcxMnB4JyB9LCBjaGlsZHJlbjogdmFyaWFudCA9PT0gJ2ljb24nID8gKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgbGFiZWw6IGxvY2FsaXphdGlvbi5jYW5jZWwsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5jYW5jZWwsIG9uQ2xpY2s6IGhhbmRsZUNhbmNlbCwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25DaXJjbGVYLCB7fSkgfSkgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIGxhYmVsOiBsb2NhbGl6YXRpb24uc2F2ZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnNhdmUsIGNvbG9yOiBcImJsdWVcIiwgb25DbGljazogaGFuZGxlU3VibWl0Um93LCBsb2FkaW5nOiBpc1NhdmluZywgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25EZXZpY2VGbG9wcHksIHt9KSB9KSB9KV0gfSkpIDogKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlQ2FuY2VsLCB2YXJpYW50OiBcInN1YnRsZVwiLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLmNhbmNlbCB9KSwganN4UnVudGltZS5qc3goY29yZS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlU3VibWl0Um93LCB2YXJpYW50OiBcImZpbGxlZFwiLCBsb2FkaW5nOiBpc1NhdmluZywgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5zYXZlIH0pXSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1RvZ2dsZVJvd0FjdGlvbk1lbnVCdXR0b24gPSAoeyBjZWxsLCByb3csIHRhYmxlLCB9KSA9PiB7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBjcmVhdGVEaXNwbGF5TW9kZSwgZWRpdERpc3BsYXlNb2RlLCBlbmFibGVFZGl0aW5nLCBpY29uczogeyBJY29uRWRpdCB9LCBsb2NhbGl6YXRpb24sIHJlbmRlclJvd0FjdGlvbk1lbnVJdGVtcywgcmVuZGVyUm93QWN0aW9ucywgfSwgc2V0RWRpdGluZ1JvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3cgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNDcmVhdGluZyA9IChjcmVhdGluZ1JvdyA9PT0gbnVsbCB8fCBjcmVhdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaXNFZGl0aW5nID0gKGVkaXRpbmdSb3cgPT09IG51bGwgfHwgZWRpdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBoYW5kbGVTdGFydEVkaXRNb2RlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzZXRFZGl0aW5nUm93KE9iamVjdC5hc3NpZ24oe30sIHJvdykpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvd0VkaXRBY3Rpb25CdXR0b25zID0gKGlzQ3JlYXRpbmcgJiYgY3JlYXRlRGlzcGxheU1vZGUgPT09ICdyb3cnKSB8fFxuICAgICAgICAoaXNFZGl0aW5nICYmIGVkaXREaXNwbGF5TW9kZSA9PT0gJ3JvdycpO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogcmVuZGVyUm93QWN0aW9ucyAmJiAhc2hvd0VkaXRBY3Rpb25CdXR0b25zID8gKHJlbmRlclJvd0FjdGlvbnMoeyBjZWxsLCByb3csIHRhYmxlIH0pKSA6IHNob3dFZGl0QWN0aW9uQnV0dG9ucyA/IChqc3hSdW50aW1lLmpzeChNUlRfRWRpdEFjdGlvbkJ1dHRvbnMsIHsgcm93OiByb3csIHRhYmxlOiB0YWJsZSB9KSkgOiAhcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zICYmXG4gICAgICAgICAgICAoZW5hYmxlRWRpdGluZyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyBlbmFibGVFZGl0aW5nKHJvdylcbiAgICAgICAgICAgICAgICA6IGVuYWJsZUVkaXRpbmcpID8gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIHBvc2l0aW9uOiBcInJpZ2h0XCIsIGxhYmVsOiBsb2NhbGl6YXRpb24uZWRpdCwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmVkaXQsIGRpc2FibGVkOiAhIWVkaXRpbmdSb3cgJiYgZWRpdGluZ1Jvdy5pZCAhPT0gcm93LmlkLCBvbkNsaWNrOiBoYW5kbGVTdGFydEVkaXRNb2RlLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvbkVkaXQsIHt9KSB9KSB9KSkgOiByZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMgPyAoanN4UnVudGltZS5qc3goTVJUX1Jvd0FjdGlvbk1lbnUsIHsgaGFuZGxlRWRpdDogaGFuZGxlU3RhcnRFZGl0TW9kZSwgcm93OiByb3csIHRhYmxlOiB0YWJsZSB9KSkgOiBudWxsIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9TZWxlY3RDaGVja2JveCA9ICh7IHJvdywgc2VsZWN0QWxsLCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZU11bHRpUm93U2VsZWN0aW9uLCBsb2NhbGl6YXRpb24sIG1hbnRpbmVTZWxlY3RBbGxDaGVja2JveFByb3BzLCBtYW50aW5lU2VsZWN0Q2hlY2tib3hQcm9wcywgc2VsZWN0QWxsTW9kZSwgc2VsZWN0RGlzcGxheU1vZGUsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHksIGlzTG9hZGluZyB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBjaGVja2JveFByb3BzID0gIXJvd1xuICAgICAgICA/IG1hbnRpbmVTZWxlY3RBbGxDaGVja2JveFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gbWFudGluZVNlbGVjdEFsbENoZWNrYm94UHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICAgICAgOiBtYW50aW5lU2VsZWN0QWxsQ2hlY2tib3hQcm9wc1xuICAgICAgICA6IG1hbnRpbmVTZWxlY3RDaGVja2JveFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gbWFudGluZVNlbGVjdENoZWNrYm94UHJvcHMoeyByb3csIHRhYmxlIH0pXG4gICAgICAgICAgICA6IG1hbnRpbmVTZWxlY3RDaGVja2JveFByb3BzO1xuICAgIGNvbnN0IGFsbFJvd3NTZWxlY3RlZCA9IHNlbGVjdEFsbFxuICAgICAgICA/IHNlbGVjdEFsbE1vZGUgPT09ICdwYWdlJ1xuICAgICAgICAgICAgPyB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKVxuICAgICAgICAgICAgOiB0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNvbW1vblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgJ2FyaWEtbGFiZWwnOiBzZWxlY3RBbGxcbiAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLnRvZ2dsZVNlbGVjdEFsbFxuICAgICAgICAgICAgOiBsb2NhbGl6YXRpb24udG9nZ2xlU2VsZWN0Um93LCBjaGVja2VkOiBzZWxlY3RBbGwgPyBhbGxSb3dzU2VsZWN0ZWQgOiByb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuZ2V0SXNTZWxlY3RlZCgpLCBkaXNhYmxlZDogaXNMb2FkaW5nIHx8IChyb3cgJiYgIXJvdy5nZXRDYW5TZWxlY3QoKSksIG9uQ2hhbmdlOiByb3dcbiAgICAgICAgICAgID8gcm93LmdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlcigpXG4gICAgICAgICAgICA6IHNlbGVjdEFsbE1vZGUgPT09ICdhbGwnXG4gICAgICAgICAgICAgICAgPyB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyKClcbiAgICAgICAgICAgICAgICA6IHRhYmxlLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyKCksIHNpemU6IGRlbnNpdHkgPT09ICd4cycgPyAnc20nIDogJ21kJyB9LCBjaGVja2JveFByb3BzKSwgeyBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIChfYSA9IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjaGVja2JveFByb3BzLCBlKTtcbiAgICAgICAgfSwgdGl0bGU6IHVuZGVmaW5lZCB9KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIG9wZW5EZWxheTogMTAwMCwgbGFiZWw6IChfYSA9IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHNlbGVjdEFsbFxuICAgICAgICAgICAgPyBsb2NhbGl6YXRpb24udG9nZ2xlU2VsZWN0QWxsXG4gICAgICAgICAgICA6IGxvY2FsaXphdGlvbi50b2dnbGVTZWxlY3RSb3cpLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IHNlbGVjdERpc3BsYXlNb2RlID09PSAnc3dpdGNoJyA/IChqc3hSdW50aW1lLmpzeChjb3JlLlN3aXRjaCwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUHJvcHMpKSkgOiBzZWxlY3REaXNwbGF5TW9kZSA9PT0gJ3JhZGlvJyB8fFxuICAgICAgICAgICAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uID09PSBmYWxzZSA/IChqc3hSdW50aW1lLmpzeChjb3JlLlJhZGlvLCBPYmplY3QuYXNzaWduKHt9LCBjb21tb25Qcm9wcykpKSA6IChqc3hSdW50aW1lLmpzeChjb3JlLkNoZWNrYm94LCBPYmplY3QuYXNzaWduKHsgaW5kZXRlcm1pbmF0ZTogc2VsZWN0QWxsXG4gICAgICAgICAgICAgICAgICAgID8gdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkKCkgJiYgIWFsbFJvd3NTZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICA6IHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvdy5nZXRJc1NvbWVTZWxlY3RlZCgpIH0sIGNvbW1vblByb3BzKSkpIH0pIH0pKTtcbn07XG5cbmNvbnN0IHVzZU1SVF9EaXNwbGF5Q29sdW1ucyA9ICh7IGNyZWF0aW5nUm93LCBjb2x1bW5PcmRlciwgZ3JvdXBpbmcsIHRhYmxlT3B0aW9ucywgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIHJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKChfYiA9IChfYSA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbHVtbk9yZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb2x1bW5PcmRlcikuaW5jbHVkZXMoJ21ydC1yb3ctZHJhZycpICYmIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgQ2VsbDogKHsgcm93LCByb3dSZWYsIHRhYmxlIH0pID0+IChqc3hSdW50aW1lLmpzeChNUlRfVGFibGVCb2R5Um93R3JhYkhhbmRsZSwgeyByb3c6IHJvdywgcm93UmVmOiByb3dSZWYsIHRhYmxlOiB0YWJsZSB9KSksIGhlYWRlcjogdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbi5tb3ZlLCBzaXplOiA2MCB9LCB0YWJsZU9wdGlvbnMuZGVmYXVsdERpc3BsYXlDb2x1bW4pLCAoX2MgPSB0YWJsZU9wdGlvbnMuZGlzcGxheUNvbHVtbkRlZk9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1snbXJ0LXJvdy1kcmFnJ10pLCB7IGlkOiAnbXJ0LXJvdy1kcmFnJyB9KSxcbiAgICAgICAgICAgICgoKF9lID0gKF9kID0gdGFibGVPcHRpb25zLnN0YXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY29sdW1uT3JkZXIpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGNvbHVtbk9yZGVyKS5pbmNsdWRlcygnbXJ0LXJvdy1hY3Rpb25zJykgfHxcbiAgICAgICAgICAgICAgICAoY3JlYXRpbmdSb3cgJiYgdGFibGVPcHRpb25zLmNyZWF0ZURpc3BsYXlNb2RlID09PSAncm93JykpICYmIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgQ2VsbDogKHsgY2VsbCwgcm93LCB0YWJsZSB9KSA9PiAoanN4UnVudGltZS5qc3goTVJUX1RvZ2dsZVJvd0FjdGlvbk1lbnVCdXR0b24sIHsgY2VsbDogY2VsbCwgcm93OiByb3csIHRhYmxlOiB0YWJsZSB9KSksIGhlYWRlcjogdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbi5hY3Rpb25zLCBzaXplOiA3MCB9LCB0YWJsZU9wdGlvbnMuZGVmYXVsdERpc3BsYXlDb2x1bW4pLCAoX2YgPSB0YWJsZU9wdGlvbnMuZGlzcGxheUNvbHVtbkRlZk9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlsnbXJ0LXJvdy1hY3Rpb25zJ10pLCB7IGlkOiAnbXJ0LXJvdy1hY3Rpb25zJyB9KSxcbiAgICAgICAgICAgICgoX2ggPSAoX2cgPSB0YWJsZU9wdGlvbnMuc3RhdGUpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jb2x1bW5PcmRlcikgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogY29sdW1uT3JkZXIpLmluY2x1ZGVzKCdtcnQtcm93LWV4cGFuZCcpICYmXG4gICAgICAgICAgICAgICAgc2hvd0V4cGFuZENvbHVtbih0YWJsZU9wdGlvbnMsIChfayA9IChfaiA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmdyb3VwaW5nKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBncm91cGluZykgJiYgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBDZWxsOiAoeyByb3csIHRhYmxlIH0pID0+IChqc3hSdW50aW1lLmpzeChNUlRfRXhwYW5kQnV0dG9uLCB7IHJvdzogcm93LCB0YWJsZTogdGFibGUgfSkpLCBIZWFkZXI6IHRhYmxlT3B0aW9ucy5lbmFibGVFeHBhbmRBbGxcbiAgICAgICAgICAgICAgICAgICAgPyAoeyB0YWJsZSB9KSA9PiBqc3hSdW50aW1lLmpzeChNUlRfRXhwYW5kQWxsQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsIGhlYWRlcjogdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbi5leHBhbmQsIHNpemU6IDYwIH0sIHRhYmxlT3B0aW9ucy5kZWZhdWx0RGlzcGxheUNvbHVtbiksIChfbCA9IHRhYmxlT3B0aW9ucy5kaXNwbGF5Q29sdW1uRGVmT3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sWydtcnQtcm93LWV4cGFuZCddKSwgeyBpZDogJ21ydC1yb3ctZXhwYW5kJyB9KSxcbiAgICAgICAgICAgICgoX28gPSAoX20gPSB0YWJsZU9wdGlvbnMuc3RhdGUpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5jb2x1bW5PcmRlcikgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogY29sdW1uT3JkZXIpLmluY2x1ZGVzKCdtcnQtcm93LXNlbGVjdCcpICYmIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgQ2VsbDogKHsgcm93LCB0YWJsZSB9KSA9PiAoanN4UnVudGltZS5qc3goTVJUX1NlbGVjdENoZWNrYm94LCB7IHJvdzogcm93LCB0YWJsZTogdGFibGUgfSkpLCBIZWFkZXI6IHRhYmxlT3B0aW9ucy5lbmFibGVTZWxlY3RBbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gKHsgdGFibGUgfSkgPT4ganN4UnVudGltZS5qc3goTVJUX1NlbGVjdENoZWNrYm94LCB7IHNlbGVjdEFsbDogdHJ1ZSwgdGFibGU6IHRhYmxlIH0pXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCwgaGVhZGVyOiB0YWJsZU9wdGlvbnMubG9jYWxpemF0aW9uLnNlbGVjdCwgc2l6ZTogNjAgfSwgdGFibGVPcHRpb25zLmRlZmF1bHREaXNwbGF5Q29sdW1uKSwgKF9wID0gdGFibGVPcHRpb25zLmRpc3BsYXlDb2x1bW5EZWZPcHRpb25zKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BbJ21ydC1yb3ctc2VsZWN0J10pLCB7IGlkOiAnbXJ0LXJvdy1zZWxlY3QnIH0pLFxuICAgICAgICAgICAgKChfciA9IChfcSA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLmNvbHVtbk9yZGVyKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBjb2x1bW5PcmRlcikuaW5jbHVkZXMoJ21ydC1yb3ctbnVtYmVycycpICYmIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgQ2VsbDogKHsgcm93IH0pID0+IHJvdy5pbmRleCArIDEsIEhlYWRlcjogKCkgPT4gdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbi5yb3dOdW1iZXIsIGhlYWRlcjogdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbi5yb3dOdW1iZXJzLCBzaXplOiA2MCB9LCB0YWJsZU9wdGlvbnMuZGVmYXVsdERpc3BsYXlDb2x1bW4pLCAoX3MgPSB0YWJsZU9wdGlvbnMuZGlzcGxheUNvbHVtbkRlZk9wdGlvbnMpID09PSBudWxsIHx8IF9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc1snbXJ0LXJvdy1udW1iZXJzJ10pLCB7IGlkOiAnbXJ0LXJvdy1udW1iZXJzJyB9KSxcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwgW1xuICAgICAgICBjb2x1bW5PcmRlcixcbiAgICAgICAgZ3JvdXBpbmcsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5kaXNwbGF5Q29sdW1uRGVmT3B0aW9ucyxcbiAgICAgICAgdGFibGVPcHRpb25zLmVkaXREaXNwbGF5TW9kZSxcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZUNvbHVtbkRyYWdnaW5nLFxuICAgICAgICB0YWJsZU9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVDb2x1bW5PcmRlcmluZyxcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZUVkaXRpbmcsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVFeHBhbmRBbGwsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVFeHBhbmRpbmcsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVHcm91cGluZyxcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZVJvd0FjdGlvbnMsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVSb3dEcmFnZ2luZyxcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZVJvd051bWJlcnMsXG4gICAgICAgIHRhYmxlT3B0aW9ucy5lbmFibGVSb3dPcmRlcmluZyxcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbixcbiAgICAgICAgdGFibGVPcHRpb25zLmVuYWJsZVNlbGVjdEFsbCxcbiAgICAgICAgdGFibGVPcHRpb25zLmxvY2FsaXphdGlvbixcbiAgICAgICAgdGFibGVPcHRpb25zLnBvc2l0aW9uQWN0aW9uc0NvbHVtbixcbiAgICAgICAgdGFibGVPcHRpb25zLnJlbmRlckRldGFpbFBhbmVsLFxuICAgICAgICB0YWJsZU9wdGlvbnMucmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zLFxuICAgICAgICB0YWJsZU9wdGlvbnMucmVuZGVyUm93QWN0aW9ucyxcbiAgICAgICAgKF9hID0gdGFibGVPcHRpb25zLnN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sdW1uT3JkZXIsXG4gICAgICAgIChfYiA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdyb3VwaW5nLFxuICAgIF0pO1xufTtcblxuY29uc3QgdXNlTVJUX0VmZmVjdHMgPSAodGFibGUpID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVBhZ2luYXRpb24sIHJvd0NvdW50IH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlciwgaXNGdWxsU2NyZWVuLCBwYWdpbmF0aW9uLCBzb3J0aW5nLCBpc0xvYWRpbmcsIHNob3dTa2VsZXRvbnMsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgaW5pdGlhbEJvZHlIZWlnaHQgPSByZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBwcmV2aW91c1RvcCA9IHJlYWN0LnVzZVJlZigpO1xuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW5pdGlhbEJvZHlIZWlnaHQuY3VycmVudCA9IGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdW50ZWQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1RvcC5jdXJyZW50ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vc2F2ZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7IC8vaGlkZSBwYWdlIHNjcm9sbGJhcnMgd2hlbiB0YWJsZSBpcyBpbiBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9IGluaXRpYWxCb2R5SGVpZ2h0LmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1RvcC5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy9yZXN0b3JlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogLTEgKiBwcmV2aW91c1RvcC5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ2luc3RhbnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbaXNGdWxsU2NyZWVuXSk7XG4gICAgLy9pZiBwYWdlIGluZGV4IGlzIG91dCBvZiBib3VuZHMsIHNldCBpdCB0byB0aGUgbGFzdCBwYWdlXG4gICAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlbmFibGVQYWdpbmF0aW9uIHx8IGlzTG9hZGluZyB8fCBzaG93U2tlbGV0b25zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHBhZ2VJbmRleCwgcGFnZVNpemUgfSA9IHBhZ2luYXRpb247XG4gICAgICAgIGNvbnN0IHRvdGFsUm93Q291bnQgPSByb3dDb3VudCAhPT0gbnVsbCAmJiByb3dDb3VudCAhPT0gdm9pZCAwID8gcm93Q291bnQgOiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5yb3dzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZmlyc3RWaXNpYmxlUm93SW5kZXggPSBwYWdlSW5kZXggKiBwYWdlU2l6ZTtcbiAgICAgICAgaWYgKGZpcnN0VmlzaWJsZVJvd0luZGV4ID4gdG90YWxSb3dDb3VudCkge1xuICAgICAgICAgICAgdGFibGUuc2V0UGFnZUluZGV4KE1hdGguZmxvb3IodG90YWxSb3dDb3VudCAvIHBhZ2VTaXplKSk7XG4gICAgICAgIH1cbiAgICB9LCBbcm93Q291bnQsIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoXSk7XG4gICAgLy90dXJuIG9mZiBzb3J0IHdoZW4gZ2xvYmFsIGZpbHRlciBpcyBsb29raW5nIGZvciByYW5rZWQgcmVzdWx0c1xuICAgIGNvbnN0IGFwcGxpZWRTb3J0ID0gcmVhY3QudXNlUmVmKHNvcnRpbmcpO1xuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzb3J0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwbGllZFNvcnQuY3VycmVudCA9IHNvcnRpbmc7XG4gICAgICAgIH1cbiAgICB9LCBbc29ydGluZ10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZ2V0Q2FuUmFua1Jvd3ModGFibGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ2xvYmFsRmlsdGVyKSB7XG4gICAgICAgICAgICB0YWJsZS5zZXRTb3J0aW5nKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhYmxlLnNldFNvcnRpbmcoKCkgPT4gYXBwbGllZFNvcnQuY3VycmVudCB8fCBbXSk7XG4gICAgICAgIH1cbiAgICB9LCBbZ2xvYmFsRmlsdGVyXSk7XG59O1xuXG5jb25zdCB1c2VNUlRfVGFibGVJbnN0YW5jZSA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzAsIF8xLCBfMiwgXzMsIF80LCBfNSwgXzYsIF83LCBfOCwgXzksIF8xMDtcbiAgICBjb25zdCBib3R0b21Ub29sYmFyUmVmID0gcmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGVkaXRJbnB1dFJlZnMgPSByZWFjdC51c2VSZWYoe30pO1xuICAgIGNvbnN0IGZpbHRlcklucHV0UmVmcyA9IHJlYWN0LnVzZVJlZih7fSk7XG4gICAgY29uc3Qgc2VhcmNoSW5wdXRSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdGFibGVDb250YWluZXJSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdGFibGVIZWFkQ2VsbFJlZnMgPSByZWFjdC51c2VSZWYoe30pO1xuICAgIGNvbnN0IHRhYmxlUGFwZXJSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdG9wVG9vbGJhclJlZiA9IHJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGluaXRTdGF0ZSA9IChfYSA9IHRhYmxlT3B0aW9ucy5pbml0aWFsU3RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICBpbml0U3RhdGUuY29sdW1uT3JkZXIgPVxuICAgICAgICAgICAgKF9iID0gaW5pdFN0YXRlLmNvbHVtbk9yZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHModGFibGVPcHRpb25zKTtcbiAgICAgICAgaW5pdFN0YXRlLmdsb2JhbEZpbHRlckZuID0gKF9jID0gdGFibGVPcHRpb25zLmdsb2JhbEZpbHRlckZuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnZnV6enknO1xuICAgICAgICByZXR1cm4gaW5pdFN0YXRlO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBbY3JlYXRpbmdSb3csIF9zZXRDcmVhdGluZ1Jvd10gPSByZWFjdC51c2VTdGF0ZSgoX2EgPSBpbml0aWFsU3RhdGUuY3JlYXRpbmdSb3cpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpO1xuICAgIGNvbnN0IFtjb2x1bW5GaWx0ZXJGbnMsIHNldENvbHVtbkZpbHRlckZuc10gPSByZWFjdC51c2VTdGF0ZSgoKSA9PiBPYmplY3QuYXNzaWduKHt9LCAuLi5nZXRBbGxMZWFmQ29sdW1uRGVmcyh0YWJsZU9wdGlvbnMuY29sdW1ucykubWFwKChjb2wpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIFtnZXRDb2x1bW5JZChjb2wpXTogY29sLmZpbHRlckZuIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICA/IChfYSA9IGNvbC5maWx0ZXJGbi5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnY3VzdG9tJ1xuICAgICAgICAgICAgICAgIDogKF9kID0gKF9iID0gY29sLmZpbHRlckZuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoX2MgPSBpbml0aWFsU3RhdGUgPT09IG51bGwgfHwgaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsU3RhdGUuY29sdW1uRmlsdGVyRm5zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbZ2V0Q29sdW1uSWQoY29sKV0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGdldERlZmF1bHRDb2x1bW5GaWx0ZXJGbihjb2wpLFxuICAgICAgICB9KTtcbiAgICB9KSkpO1xuICAgIGNvbnN0IFtjb2x1bW5PcmRlciwgc2V0Q29sdW1uT3JkZXJdID0gcmVhY3QudXNlU3RhdGUoKF9iID0gaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgY29uc3QgW2RlbnNpdHksIHNldERlbnNpdHldID0gcmVhY3QudXNlU3RhdGUoKF9jID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLmRlbnNpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdtZCcpO1xuICAgIGNvbnN0IFtkcmFnZ2luZ0NvbHVtbiwgc2V0RHJhZ2dpbmdDb2x1bW5dID0gcmVhY3QudXNlU3RhdGUoKF9kID0gaW5pdGlhbFN0YXRlLmRyYWdnaW5nQ29sdW1uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsKTtcbiAgICBjb25zdCBbZHJhZ2dpbmdSb3csIHNldERyYWdnaW5nUm93XSA9IHJlYWN0LnVzZVN0YXRlKChfZSA9IGluaXRpYWxTdGF0ZS5kcmFnZ2luZ1JvdykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbCk7XG4gICAgY29uc3QgW2VkaXRpbmdDZWxsLCBzZXRFZGl0aW5nQ2VsbF0gPSByZWFjdC51c2VTdGF0ZSgoX2YgPSBpbml0aWFsU3RhdGUuZWRpdGluZ0NlbGwpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG51bGwpO1xuICAgIGNvbnN0IFtlZGl0aW5nUm93LCBzZXRFZGl0aW5nUm93XSA9IHJlYWN0LnVzZVN0YXRlKChfZyA9IGluaXRpYWxTdGF0ZS5lZGl0aW5nUm93KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBudWxsKTtcbiAgICBjb25zdCBbZ2xvYmFsRmlsdGVyRm4sIHNldEdsb2JhbEZpbHRlckZuXSA9IHJlYWN0LnVzZVN0YXRlKChfaCA9IGluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXJGbikgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogJ2Z1enp5Jyk7XG4gICAgY29uc3QgW2dyb3VwaW5nLCBzZXRHcm91cGluZ10gPSByZWFjdC51c2VTdGF0ZSgoX2ogPSBpbml0aWFsU3RhdGUuZ3JvdXBpbmcpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IFtdKTtcbiAgICBjb25zdCBbaG92ZXJlZENvbHVtbiwgc2V0SG92ZXJlZENvbHVtbl0gPSByZWFjdC51c2VTdGF0ZSgoX2sgPSBpbml0aWFsU3RhdGUuaG92ZXJlZENvbHVtbikgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogbnVsbCk7XG4gICAgY29uc3QgW2hvdmVyZWRSb3csIHNldEhvdmVyZWRSb3ddID0gcmVhY3QudXNlU3RhdGUoKF9sID0gaW5pdGlhbFN0YXRlLmhvdmVyZWRSb3cpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IG51bGwpO1xuICAgIGNvbnN0IFtpc0Z1bGxTY3JlZW4sIHNldElzRnVsbFNjcmVlbl0gPSByZWFjdC51c2VTdGF0ZSgoX20gPSBpbml0aWFsU3RhdGUgPT09IG51bGwgfHwgaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsU3RhdGUuaXNGdWxsU2NyZWVuKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dBbGVydEJhbm5lciwgc2V0U2hvd0FsZXJ0QmFubmVyXSA9IHJlYWN0LnVzZVN0YXRlKChfcCA9IChfbyA9IHRhYmxlT3B0aW9ucy5pbml0aWFsU3RhdGUpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5zaG93QWxlcnRCYW5uZXIpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IGZhbHNlKTtcbiAgICBjb25zdCBbc2hvd0NvbHVtbkZpbHRlcnMsIHNldFNob3dDb2x1bW5GaWx0ZXJzXSA9IHJlYWN0LnVzZVN0YXRlKChfcSA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5zaG93Q29sdW1uRmlsdGVycykgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93R2xvYmFsRmlsdGVyLCBzZXRTaG93R2xvYmFsRmlsdGVyXSA9IHJlYWN0LnVzZVN0YXRlKChfciA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5zaG93R2xvYmFsRmlsdGVyKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dUb29sYmFyRHJvcFpvbmUsIHNldFNob3dUb29sYmFyRHJvcFpvbmVdID0gcmVhY3QudXNlU3RhdGUoKF9zID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLnNob3dUb29sYmFyRHJvcFpvbmUpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IGZhbHNlKTtcbiAgICBjb25zdCBkaXNwbGF5Q29sdW1ucyA9IHVzZU1SVF9EaXNwbGF5Q29sdW1ucyh7XG4gICAgICAgIGNvbHVtbk9yZGVyLFxuICAgICAgICBjcmVhdGluZ1JvdyxcbiAgICAgICAgZ3JvdXBpbmcsXG4gICAgICAgIHRhYmxlT3B0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5EZWZzID0gcmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gcHJlcGFyZUNvbHVtbnMoe1xuICAgICAgICAgICAgYWdncmVnYXRpb25GbnM6IHRhYmxlT3B0aW9ucy5hZ2dyZWdhdGlvbkZucyxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFsuLi5kaXNwbGF5Q29sdW1ucywgLi4udGFibGVPcHRpb25zLmNvbHVtbnNdLFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyRm5zOiAoX2IgPSAoX2EgPSB0YWJsZU9wdGlvbnMuc3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2x1bW5GaWx0ZXJGbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbHVtbkZpbHRlckZucyxcbiAgICAgICAgICAgIGRlZmF1bHREaXNwbGF5Q29sdW1uOiAoX2MgPSB0YWJsZU9wdGlvbnMuZGVmYXVsdERpc3BsYXlDb2x1bW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICAgICAgZmlsdGVyRm5zOiB0YWJsZU9wdGlvbnMuZmlsdGVyRm5zLFxuICAgICAgICAgICAgc29ydGluZ0ZuczogdGFibGVPcHRpb25zLnNvcnRpbmdGbnMsXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgY29sdW1uRmlsdGVyRm5zLFxuICAgICAgICBkaXNwbGF5Q29sdW1ucyxcbiAgICAgICAgdGFibGVPcHRpb25zLmNvbHVtbnMsXG4gICAgICAgIChfdCA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90LmNvbHVtbkZpbHRlckZucyxcbiAgICBdKTtcbiAgICBjb25zdCBkYXRhID0gcmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHJldHVybiAoKChfYSA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzTG9hZGluZykgfHwgKChfYiA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNob3dTa2VsZXRvbnMpKSAmJlxuICAgICAgICAgICAgIXRhYmxlT3B0aW9ucy5kYXRhLmxlbmd0aFxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkoKChfZCA9IChfYyA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhZ2luYXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wYWdlU2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKChfZSA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucGFnZVNpemUpIHx8XG4gICAgICAgICAgICAgICAgICAgIDEwKS5maWxsKG51bGwpLFxuICAgICAgICAgICAgXS5tYXAoKCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgLi4uZ2V0QWxsTGVhZkNvbHVtbkRlZnModGFibGVPcHRpb25zLmNvbHVtbnMpLm1hcCgoY29sKSA9PiAoe1xuICAgICAgICAgICAgICAgIFtnZXRDb2x1bW5JZChjb2wpXTogbnVsbCxcbiAgICAgICAgICAgIH0pKSkpXG4gICAgICAgICAgICA6IHRhYmxlT3B0aW9ucy5kYXRhO1xuICAgIH0sIFtcbiAgICAgICAgdGFibGVPcHRpb25zLmRhdGEsXG4gICAgICAgIChfdSA9IHRhYmxlT3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF91LmlzTG9hZGluZyxcbiAgICAgICAgKF92ID0gdGFibGVPcHRpb25zLnN0YXRlKSA9PT0gbnVsbCB8fCBfdiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Yuc2hvd1NrZWxldG9ucyxcbiAgICBdKTtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBjb25zdCB0YWJsZSA9IHJlYWN0VGFibGUudXNlUmVhY3RUYWJsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBnZXRDb3JlUm93TW9kZWw6IHJlYWN0VGFibGUuZ2V0Q29yZVJvd01vZGVsKCksIGdldEV4cGFuZGVkUm93TW9kZWw6IHRhYmxlT3B0aW9ucy5lbmFibGVFeHBhbmRpbmcgfHwgdGFibGVPcHRpb25zLmVuYWJsZUdyb3VwaW5nXG4gICAgICAgICAgICA/IHJlYWN0VGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCgpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgZ2V0RmFjZXRlZE1pbk1heFZhbHVlczogdGFibGVPcHRpb25zLmVuYWJsZUZhY2V0ZWRWYWx1ZXNcbiAgICAgICAgICAgID8gcmVhY3RUYWJsZS5nZXRGYWNldGVkTWluTWF4VmFsdWVzKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBnZXRGYWNldGVkUm93TW9kZWw6IHRhYmxlT3B0aW9ucy5lbmFibGVGYWNldGVkVmFsdWVzXG4gICAgICAgICAgICA/IHJlYWN0VGFibGUuZ2V0RmFjZXRlZFJvd01vZGVsKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBnZXRGYWNldGVkVW5pcXVlVmFsdWVzOiB0YWJsZU9wdGlvbnMuZW5hYmxlRmFjZXRlZFZhbHVlc1xuICAgICAgICAgICAgPyByZWFjdFRhYmxlLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIGdldEZpbHRlcmVkUm93TW9kZWw6IHRhYmxlT3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzIHx8XG4gICAgICAgICAgICB0YWJsZU9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyIHx8XG4gICAgICAgICAgICB0YWJsZU9wdGlvbnMuZW5hYmxlRmlsdGVyc1xuICAgICAgICAgICAgPyByZWFjdFRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIGdldEdyb3VwZWRSb3dNb2RlbDogdGFibGVPcHRpb25zLmVuYWJsZUdyb3VwaW5nXG4gICAgICAgICAgICA/IHJlYWN0VGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBnZXRQYWdpbmF0aW9uUm93TW9kZWw6IHRhYmxlT3B0aW9ucy5lbmFibGVQYWdpbmF0aW9uXG4gICAgICAgICAgICA/IHJlYWN0VGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBnZXRTb3J0ZWRSb3dNb2RlbDogdGFibGVPcHRpb25zLmVuYWJsZVNvcnRpbmdcbiAgICAgICAgICAgID8gcmVhY3RUYWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Db2x1bW5PcmRlckNoYW5nZTogc2V0Q29sdW1uT3JkZXIsIG9uR3JvdXBpbmdDaGFuZ2U6IHNldEdyb3VwaW5nLCBnZXRTdWJSb3dzOiAocm93KSA9PiByb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuc3ViUm93cyB9LCB0YWJsZU9wdGlvbnMpLCB7IFxuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgY29sdW1uczogY29sdW1uRGVmcywgZGF0YSwgZ2xvYmFsRmlsdGVyRm46IChfdyA9IHRhYmxlT3B0aW9ucy5maWx0ZXJGbnMpID09PSBudWxsIHx8IF93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd1tnbG9iYWxGaWx0ZXJGbiAhPT0gbnVsbCAmJiBnbG9iYWxGaWx0ZXJGbiAhPT0gdm9pZCAwID8gZ2xvYmFsRmlsdGVyRm4gOiAnZnV6enknXSwgaW5pdGlhbFN0YXRlLCBzdGF0ZTogT2JqZWN0LmFzc2lnbih7IGNyZWF0aW5nUm93LFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyRm5zLFxuICAgICAgICAgICAgY29sdW1uT3JkZXIsXG4gICAgICAgICAgICBkZW5zaXR5LFxuICAgICAgICAgICAgZHJhZ2dpbmdDb2x1bW4sXG4gICAgICAgICAgICBkcmFnZ2luZ1JvdyxcbiAgICAgICAgICAgIGVkaXRpbmdDZWxsLFxuICAgICAgICAgICAgZWRpdGluZ1JvdyxcbiAgICAgICAgICAgIGdsb2JhbEZpbHRlckZuLFxuICAgICAgICAgICAgZ3JvdXBpbmcsXG4gICAgICAgICAgICBob3ZlcmVkQ29sdW1uLFxuICAgICAgICAgICAgaG92ZXJlZFJvdyxcbiAgICAgICAgICAgIGlzRnVsbFNjcmVlbixcbiAgICAgICAgICAgIHNob3dBbGVydEJhbm5lcixcbiAgICAgICAgICAgIHNob3dDb2x1bW5GaWx0ZXJzLFxuICAgICAgICAgICAgc2hvd0dsb2JhbEZpbHRlcixcbiAgICAgICAgICAgIHNob3dUb29sYmFyRHJvcFpvbmUgfSwgdGFibGVPcHRpb25zLnN0YXRlKSB9KSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRhYmxlLnJlZnMgPSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYm90dG9tVG9vbGJhclJlZixcbiAgICAgICAgZWRpdElucHV0UmVmcyxcbiAgICAgICAgZmlsdGVySW5wdXRSZWZzLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNlYXJjaElucHV0UmVmLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRhYmxlQ29udGFpbmVyUmVmLFxuICAgICAgICB0YWJsZUhlYWRDZWxsUmVmcyxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0YWJsZVBhcGVyUmVmLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRvcFRvb2xiYXJSZWYsXG4gICAgfTtcbiAgICBjb25zdCBzZXRDcmVhdGluZ1JvdyA9IChyb3cpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IF9yb3cgPSByb3c7XG4gICAgICAgIGlmIChyb3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF9yb3cgPSBjcmVhdGVSb3codGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHRhYmxlT3B0aW9ucyA9PT0gbnVsbCB8fCB0YWJsZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlT3B0aW9ucy5vbkNyZWF0aW5nUm93Q2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YWJsZU9wdGlvbnMsIF9yb3cpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfc2V0Q3JlYXRpbmdSb3coX3Jvdyk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRDcmVhdGluZ1JvdyA9IHNldENyZWF0aW5nUm93O1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlckZucyA9XG4gICAgICAgIChfeCA9IHRhYmxlT3B0aW9ucy5vbkNvbHVtbkZpbHRlckZuc0NoYW5nZSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogc2V0Q29sdW1uRmlsdGVyRm5zO1xuICAgIHRhYmxlLnNldERlbnNpdHkgPSAoX3kgPSB0YWJsZU9wdGlvbnMub25EZW5zaXR5Q2hhbmdlKSAhPT0gbnVsbCAmJiBfeSAhPT0gdm9pZCAwID8gX3kgOiBzZXREZW5zaXR5O1xuICAgIHRhYmxlLnNldERyYWdnaW5nQ29sdW1uID1cbiAgICAgICAgKF96ID0gdGFibGVPcHRpb25zLm9uRHJhZ2dpbmdDb2x1bW5DaGFuZ2UpICE9PSBudWxsICYmIF96ICE9PSB2b2lkIDAgPyBfeiA6IHNldERyYWdnaW5nQ29sdW1uO1xuICAgIHRhYmxlLnNldERyYWdnaW5nUm93ID0gKF8wID0gdGFibGVPcHRpb25zLm9uRHJhZ2dpbmdSb3dDaGFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHNldERyYWdnaW5nUm93O1xuICAgIHRhYmxlLnNldEVkaXRpbmdDZWxsID0gKF8xID0gdGFibGVPcHRpb25zLm9uRWRpdGluZ0NlbGxDaGFuZ2UpICE9PSBudWxsICYmIF8xICE9PSB2b2lkIDAgPyBfMSA6IHNldEVkaXRpbmdDZWxsO1xuICAgIHRhYmxlLnNldEVkaXRpbmdSb3cgPSAoXzIgPSB0YWJsZU9wdGlvbnMub25FZGl0aW5nUm93Q2hhbmdlKSAhPT0gbnVsbCAmJiBfMiAhPT0gdm9pZCAwID8gXzIgOiBzZXRFZGl0aW5nUm93O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlckZuID1cbiAgICAgICAgKF8zID0gdGFibGVPcHRpb25zLm9uR2xvYmFsRmlsdGVyRm5DaGFuZ2UpICE9PSBudWxsICYmIF8zICE9PSB2b2lkIDAgPyBfMyA6IHNldEdsb2JhbEZpbHRlckZuO1xuICAgIHRhYmxlLnNldEhvdmVyZWRDb2x1bW4gPVxuICAgICAgICAoXzQgPSB0YWJsZU9wdGlvbnMub25Ib3ZlcmVkQ29sdW1uQ2hhbmdlKSAhPT0gbnVsbCAmJiBfNCAhPT0gdm9pZCAwID8gXzQgOiBzZXRIb3ZlcmVkQ29sdW1uO1xuICAgIHRhYmxlLnNldEhvdmVyZWRSb3cgPSAoXzUgPSB0YWJsZU9wdGlvbnMub25Ib3ZlcmVkUm93Q2hhbmdlKSAhPT0gbnVsbCAmJiBfNSAhPT0gdm9pZCAwID8gXzUgOiBzZXRIb3ZlcmVkUm93O1xuICAgIHRhYmxlLnNldElzRnVsbFNjcmVlbiA9IChfNiA9IHRhYmxlT3B0aW9ucy5vbklzRnVsbFNjcmVlbkNoYW5nZSkgIT09IG51bGwgJiYgXzYgIT09IHZvaWQgMCA/IF82IDogc2V0SXNGdWxsU2NyZWVuO1xuICAgIHRhYmxlLnNldFNob3dBbGVydEJhbm5lciA9XG4gICAgICAgIChfNyA9IHRhYmxlT3B0aW9ucy5vblNob3dBbGVydEJhbm5lckNoYW5nZSkgIT09IG51bGwgJiYgXzcgIT09IHZvaWQgMCA/IF83IDogc2V0U2hvd0FsZXJ0QmFubmVyO1xuICAgIHRhYmxlLnNldFNob3dDb2x1bW5GaWx0ZXJzID1cbiAgICAgICAgKF84ID0gdGFibGVPcHRpb25zLm9uU2hvd0NvbHVtbkZpbHRlcnNDaGFuZ2UpICE9PSBudWxsICYmIF84ICE9PSB2b2lkIDAgPyBfOCA6IHNldFNob3dDb2x1bW5GaWx0ZXJzO1xuICAgIHRhYmxlLnNldFNob3dHbG9iYWxGaWx0ZXIgPVxuICAgICAgICAoXzkgPSB0YWJsZU9wdGlvbnMub25TaG93R2xvYmFsRmlsdGVyQ2hhbmdlKSAhPT0gbnVsbCAmJiBfOSAhPT0gdm9pZCAwID8gXzkgOiBzZXRTaG93R2xvYmFsRmlsdGVyO1xuICAgIHRhYmxlLnNldFNob3dUb29sYmFyRHJvcFpvbmUgPVxuICAgICAgICAoXzEwID0gdGFibGVPcHRpb25zLm9uU2hvd1Rvb2xiYXJEcm9wWm9uZUNoYW5nZSkgIT09IG51bGwgJiYgXzEwICE9PSB2b2lkIDAgPyBfMTAgOiBzZXRTaG93VG9vbGJhckRyb3Bab25lO1xuICAgIHVzZU1SVF9FZmZlY3RzKHRhYmxlKTtcbiAgICByZXR1cm4gdGFibGU7XG59O1xuXG5jb25zdCB1c2VNYW50aW5lUmVhY3RUYWJsZSA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBwYXJzZWRUYWJsZU9wdGlvbnMgPSB1c2VNUlRfVGFibGVPcHRpb25zKHRhYmxlT3B0aW9ucyk7XG4gICAgY29uc3QgdGFibGVJbnN0YW5jZSA9IHVzZU1SVF9UYWJsZUluc3RhbmNlKHBhcnNlZFRhYmxlT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRhYmxlSW5zdGFuY2U7XG59O1xuXG5jb25zdCBtcnRGaWx0ZXJPcHRpb25zID0gKGxvY2FsaXphdGlvbikgPT4gW1xuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnZnV6enknLFxuICAgICAgICBzeW1ib2w6ICfiiYgnLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckZ1enp5LFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnY29udGFpbnMnLFxuICAgICAgICBzeW1ib2w6ICcqJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJDb250YWlucyxcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG9wdGlvbjogJ3N0YXJ0c1dpdGgnLFxuICAgICAgICBzeW1ib2w6ICdhJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJTdGFydHNXaXRoLFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnZW5kc1dpdGgnLFxuICAgICAgICBzeW1ib2w6ICd6JyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJFbmRzV2l0aCxcbiAgICAgICAgZGl2aWRlcjogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnZXF1YWxzJyxcbiAgICAgICAgc3ltYm9sOiAnPScsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyRXF1YWxzLFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnbm90RXF1YWxzJyxcbiAgICAgICAgc3ltYm9sOiAn4omgJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJOb3RFcXVhbHMsXG4gICAgICAgIGRpdmlkZXI6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG9wdGlvbjogJ2JldHdlZW4nLFxuICAgICAgICBzeW1ib2w6ICfih78nLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckJldHdlZW4sXG4gICAgICAgIGRpdmlkZXI6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBvcHRpb246ICdiZXR3ZWVuSW5jbHVzaXZlJyxcbiAgICAgICAgc3ltYm9sOiAn4qyMJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJCZXR3ZWVuSW5jbHVzaXZlLFxuICAgICAgICBkaXZpZGVyOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBvcHRpb246ICdncmVhdGVyVGhhbicsXG4gICAgICAgIHN5bWJvbDogJz4nLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckdyZWF0ZXJUaGFuLFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnZ3JlYXRlclRoYW5PckVxdWFsVG8nLFxuICAgICAgICBzeW1ib2w6ICfiiaUnLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckdyZWF0ZXJUaGFuT3JFcXVhbFRvLFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnbGVzc1RoYW4nLFxuICAgICAgICBzeW1ib2w6ICc8JyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJMZXNzVGhhbixcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG9wdGlvbjogJ2xlc3NUaGFuT3JFcXVhbFRvJyxcbiAgICAgICAgc3ltYm9sOiAn4omkJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJMZXNzVGhhbk9yRXF1YWxUbyxcbiAgICAgICAgZGl2aWRlcjogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnZW1wdHknLFxuICAgICAgICBzeW1ib2w6ICfiiIUnLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckVtcHR5LFxuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgb3B0aW9uOiAnbm90RW1wdHknLFxuICAgICAgICBzeW1ib2w6ICch4oiFJyxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJOb3RFbXB0eSxcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgfSxcbl07XG5jb25zdCByYW5nZU1vZGVzID0gWydiZXR3ZWVuJywgJ2JldHdlZW5JbmNsdXNpdmUnLCAnaW5OdW1iZXJSYW5nZSddO1xuY29uc3QgZW1wdHlNb2RlcyA9IFsnZW1wdHknLCAnbm90RW1wdHknXTtcbmNvbnN0IGFyck1vZGVzID0gWydhcnJJbmNsdWRlc1NvbWUnLCAnYXJySW5jbHVkZXNBbGwnLCAnYXJySW5jbHVkZXMnXTtcbmNvbnN0IHJhbmdlVmFyaWFudHMgPSBbJ3JhbmdlLXNsaWRlcicsICdkYXRlLXJhbmdlJywgJ3JhbmdlJ107XG5jb25zdCBNUlRfRmlsdGVyT3B0aW9uTWVudSA9ICh7IGhlYWRlciwgb25TZWxlY3QsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyTW9kZU9wdGlvbnMsIGdsb2JhbEZpbHRlck1vZGVPcHRpb25zLCBsb2NhbGl6YXRpb24sIHJlbmRlckNvbHVtbkZpbHRlck1vZGVNZW51SXRlbXMsIHJlbmRlckdsb2JhbEZpbHRlck1vZGVNZW51SXRlbXMsIH0sIHNldENvbHVtbkZpbHRlckZucywgc2V0R2xvYmFsRmlsdGVyRm4sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlckZuIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXIgIT09IG51bGwgJiYgaGVhZGVyICE9PSB2b2lkIDAgPyBoZWFkZXIgOiB7fTtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uICE9PSBudWxsICYmIGNvbHVtbiAhPT0gdm9pZCAwID8gY29sdW1uIDoge307XG4gICAgY29uc3QgY3VycmVudEZpbHRlclZhbHVlID0gY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLmdldEZpbHRlclZhbHVlKCk7XG4gICAgbGV0IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmNvbHVtbkZpbHRlck1vZGVPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2x1bW5GaWx0ZXJNb2RlT3B0aW9ucztcbiAgICBpZiAocmFuZ2VWYXJpYW50cy5pbmNsdWRlcyhjb2x1bW5EZWYgPT09IG51bGwgfHwgY29sdW1uRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCkpIHtcbiAgICAgICAgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi5yYW5nZU1vZGVzLFxuICAgICAgICAgICAgLi4uKGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zICE9PSBudWxsICYmIGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zICE9PSB2b2lkIDAgPyBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA6IFtdKSxcbiAgICAgICAgXS5maWx0ZXIoKG9wdGlvbikgPT4gcmFuZ2VNb2Rlcy5pbmNsdWRlcyhvcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxGaWx0ZXJPcHRpb25zID0gcmVhY3QudXNlTWVtbygoKSA9PiBtcnRGaWx0ZXJPcHRpb25zKGxvY2FsaXphdGlvbikuZmlsdGVyKChmaWx0ZXJPcHRpb24pID0+IGNvbHVtbkRlZlxuICAgICAgICA/IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gbnVsbCB8fCBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMuaW5jbHVkZXMoZmlsdGVyT3B0aW9uLm9wdGlvbikpXG4gICAgICAgIDogKCFnbG9iYWxGaWx0ZXJNb2RlT3B0aW9ucyB8fFxuICAgICAgICAgICAgZ2xvYmFsRmlsdGVyTW9kZU9wdGlvbnMuaW5jbHVkZXMoZmlsdGVyT3B0aW9uLm9wdGlvbikpICYmXG4gICAgICAgICAgICBbJ2Z1enp5JywgJ2NvbnRhaW5zJywgJ3N0YXJ0c1dpdGgnXS5pbmNsdWRlcyhmaWx0ZXJPcHRpb24ub3B0aW9uKSksIFtdKTtcbiAgICBjb25zdCBoYW5kbGVTZWxlY3RGaWx0ZXJNb2RlID0gKG9wdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHByZXZGaWx0ZXJNb2RlID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLl9maWx0ZXJGbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGlmICghaGVhZGVyIHx8ICFjb2x1bW4pIHtcbiAgICAgICAgICAgIC8vIGdsb2JhbCBmaWx0ZXIgbW9kZVxuICAgICAgICAgICAgc2V0R2xvYmFsRmlsdGVyRm4ob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb24gIT09IHByZXZGaWx0ZXJNb2RlKSB7XG4gICAgICAgICAgICAvLyBjb2x1bW4gZmlsdGVyIG1vZGVcbiAgICAgICAgICAgIHNldENvbHVtbkZpbHRlckZucygocHJldikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIHsgW2hlYWRlci5pZF06IG9wdGlvbiB9KSkpO1xuICAgICAgICAgICAgLy8gcmVzZXQgZmlsdGVyIHZhbHVlIGFuZC9vciBwZXJmb3JtIG5ldyBmaWx0ZXIgcmVuZGVyXG4gICAgICAgICAgICBpZiAoZW1wdHlNb2Rlcy5pbmNsdWRlcyhvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBub3cgYmUgZW1wdHkvbm90RW1wdHkgZmlsdGVyIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpbHRlclZhbHVlICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICAgICAgIWVtcHR5TW9kZXMuaW5jbHVkZXMocHJldkZpbHRlck1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSgnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RmlsdGVyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKGN1cnJlbnRGaWx0ZXJWYWx1ZSk7IC8vIHBlcmZvcm0gbmV3IGZpbHRlciByZW5kZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmZpbHRlclZhcmlhbnQpID09PSAnbXVsdGktc2VsZWN0JyB8fFxuICAgICAgICAgICAgICAgIGFyck1vZGVzLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdyBiZSBhcnJheSBmaWx0ZXIgbW9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmlsdGVyVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRGaWx0ZXJWYWx1ZSA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRGaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoY3VycmVudEZpbHRlclZhbHVlKTsgLy8gcGVyZm9ybSBuZXcgZmlsdGVyIHJlbmRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlVmFyaWFudHMuaW5jbHVkZXMoY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmZpbHRlclZhcmlhbnQpIHx8XG4gICAgICAgICAgICAgICAgcmFuZ2VNb2Rlcy5pbmNsdWRlcyhvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBub3cgYmUgcmFuZ2UgZmlsdGVyIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudEZpbHRlclZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIShjdXJyZW50RmlsdGVyVmFsdWUgPT09IG51bGwgfHwgY3VycmVudEZpbHRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyVmFsdWUuZXZlcnkoKHYpID0+IHYgPT09ICcnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFyYW5nZU1vZGVzLmluY2x1ZGVzKHByZXZGaWx0ZXJNb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKFsnJywgJyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShjdXJyZW50RmlsdGVyVmFsdWUpOyAvLyBwZXJmb3JtIG5ldyBmaWx0ZXIgcmVuZGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBub3cgYmUgc2luZ2xlIHZhbHVlIGZpbHRlciBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudEZpbHRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKGN1cnJlbnRGaWx0ZXJWYWx1ZSk7IC8vIHBlcmZvcm0gbmV3IGZpbHRlciByZW5kZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25TZWxlY3QgPT09IG51bGwgfHwgb25TZWxlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU2VsZWN0KCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJPcHRpb24gPSAhIWhlYWRlciAmJiBjb2x1bW5EZWYgPyBjb2x1bW5EZWYuX2ZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm47XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuRHJvcGRvd24sIHsgY2hpbGRyZW46IChfZCA9IChoZWFkZXIgJiYgY29sdW1uICYmIGNvbHVtbkRlZlxuICAgICAgICAgICAgPyAoX2MgPSAoX2IgPSBjb2x1bW5EZWYucmVuZGVyQ29sdW1uRmlsdGVyTW9kZU1lbnVJdGVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoY29sdW1uRGVmLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGaWx0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0RmlsdGVyTW9kZTogaGFuZGxlU2VsZWN0RmlsdGVyTW9kZSxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiByZW5kZXJDb2x1bW5GaWx0ZXJNb2RlTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlckNvbHVtbkZpbHRlck1vZGVNZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckNvbHVtbkZpbHRlck1vZGVNZW51SXRlbXMoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGludGVybmFsRmlsdGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdEZpbHRlck1vZGU6IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUsXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiByZW5kZXJHbG9iYWxGaWx0ZXJNb2RlTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlckdsb2JhbEZpbHRlck1vZGVNZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckdsb2JhbEZpbHRlck1vZGVNZW51SXRlbXMoe1xuICAgICAgICAgICAgICAgIGludGVybmFsRmlsdGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdEZpbHRlck1vZGU6IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUsXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB9KSkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGludGVybmFsRmlsdGVyT3B0aW9ucy5tYXAoKHsgb3B0aW9uLCBsYWJlbCwgZGl2aWRlciwgc3ltYm9sIH0sIGluZGV4KSA9PiAoanN4UnVudGltZS5qc3hzKHJlYWN0LkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3hzKGNvcmUuTWVudS5JdGVtLCB7IG9uQ2xpY2s6ICgpID0+IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUob3B0aW9uKSwgY29sb3I6IG9wdGlvbiA9PT0gZmlsdGVyT3B0aW9uID8gJ2JsdWUnIDogdW5kZWZpbmVkLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyYgPiAubWFudGluZS1NZW51LWl0ZW1MYWJlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleFdyYXA6ICdub3dyYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogJzFjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB2YWx1ZTogb3B0aW9uLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuRmxleCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycHgpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcyY2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBzeW1ib2wgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuRmxleCwgeyBhbGlnbjogXCJjZW50ZXJcIiwgY2hpbGRyZW46IGxhYmVsIH0pXSB9KSwgZGl2aWRlciAmJiBqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuRGl2aWRlciwge30pXSB9LCBpbmRleCkpKSB9KSk7XG59O1xuXG5jb25zdCBNUlRfR2xvYmFsRmlsdGVyVGV4dElucHV0ID0gKHsgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBzZXRHbG9iYWxGaWx0ZXIsIG9wdGlvbnM6IHsgZW5hYmxlR2xvYmFsRmlsdGVyTW9kZXMsIGljb25zOiB7IEljb25TZWFyY2gsIEljb25YIH0sIGxvY2FsaXphdGlvbiwgbWFudWFsRmlsdGVyaW5nLCBtYW50aW5lU2VhcmNoVGV4dElucHV0UHJvcHMsIH0sIHJlZnM6IHsgc2VhcmNoSW5wdXRSZWYgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyLCBzaG93R2xvYmFsRmlsdGVyIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRleHRGaWVsZFByb3BzID0gbWFudGluZVNlYXJjaFRleHRJbnB1dFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lU2VhcmNoVGV4dElucHV0UHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVTZWFyY2hUZXh0SW5wdXRQcm9wcztcbiAgICBjb25zdCBpc01vdW50ZWQgPSByZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWFyY2hWYWx1ZSwgc2V0U2VhcmNoVmFsdWVdID0gcmVhY3QudXNlU3RhdGUoZ2xvYmFsRmlsdGVyICE9PSBudWxsICYmIGdsb2JhbEZpbHRlciAhPT0gdm9pZCAwID8gZ2xvYmFsRmlsdGVyIDogJycpO1xuICAgIGNvbnN0IFtkZWJvdW5jZWRTZWFyY2hWYWx1ZV0gPSBob29rcy51c2VEZWJvdW5jZWRWYWx1ZShzZWFyY2hWYWx1ZSwgbWFudWFsRmlsdGVyaW5nID8gNTAwIDogMjUwKTtcbiAgICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRHbG9iYWxGaWx0ZXIoZGVib3VuY2VkU2VhcmNoVmFsdWUgfHwgdW5kZWZpbmVkKTtcbiAgICB9LCBbZGVib3VuY2VkU2VhcmNoVmFsdWVdKTtcbiAgICBjb25zdCBoYW5kbGVDbGVhciA9ICgpID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVmFsdWUoJycpO1xuICAgICAgICBzZXRHbG9iYWxGaWx0ZXIodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbEZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFNlYXJjaFZhbHVlKGdsb2JhbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtnbG9iYWxGaWx0ZXJdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkNvbGxhcHNlLCB7IGluOiBzaG93R2xvYmFsRmlsdGVyLCBzeDoge1xuICAgICAgICAgICAgJyYgPiBkaXYnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGdhcDogJzE2cHgnLFxuICAgICAgICAgICAgICAgIGZsZXhXcmFwOiAnbm93cmFwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbZW5hYmxlR2xvYmFsRmlsdGVyTW9kZXMgJiYgKGpzeFJ1bnRpbWUuanN4cyhjb3JlLk1lbnUsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5UYXJnZXQsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmNoYW5nZVNlYXJjaE1vZGUsIHNpemU6IFwic21cIiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25TZWFyY2gsIHt9KSB9KSB9KSwganN4UnVudGltZS5qc3goTVJUX0ZpbHRlck9wdGlvbk1lbnUsIHsgdGFibGU6IHRhYmxlLCBvblNlbGVjdDogaGFuZGxlQ2xlYXIgfSldIH0pKSwganN4UnVudGltZS5qc3goY29yZS5UZXh0SW5wdXQsIE9iamVjdC5hc3NpZ24oeyBwbGFjZWhvbGRlcjogbG9jYWxpemF0aW9uLnNlYXJjaCwgb25DaGFuZ2U6IChldmVudCkgPT4gc2V0U2VhcmNoVmFsdWUoZXZlbnQudGFyZ2V0LnZhbHVlKSwgdmFsdWU6IHNlYXJjaFZhbHVlICE9PSBudWxsICYmIHNlYXJjaFZhbHVlICE9PSB2b2lkIDAgPyBzZWFyY2hWYWx1ZSA6ICcnLCB2YXJpYW50OiBcImZpbGxlZFwiLCBpY29uOiAhZW5hYmxlR2xvYmFsRmlsdGVyTW9kZXMgJiYganN4UnVudGltZS5qc3goSWNvblNlYXJjaCwge30pLCByaWdodFNlY3Rpb246IHNlYXJjaFZhbHVlID8gKGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmNsZWFyU2VhcmNoLCBkaXNhYmxlZDogIShzZWFyY2hWYWx1ZSA9PT0gbnVsbCB8fCBzZWFyY2hWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoVmFsdWUubGVuZ3RoKSwgb25DbGljazogaGFuZGxlQ2xlYXIsIHNpemU6IFwic21cIiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIGxhYmVsOiBsb2NhbGl6YXRpb24uY2xlYXJTZWFyY2gsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uWCwge30pIH0pIH0pKSA6IG51bGwgfSwgdGV4dEZpZWxkUHJvcHMsIHsgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoSW5wdXRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dEZpZWxkUHJvcHMgPT09IG51bGwgfHwgdGV4dEZpZWxkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRGaWVsZFByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RmllbGRQcm9wcy5yZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBtaW5XaWR0aDogJzI1MHB4JyB9LCAoKHRleHRGaWVsZFByb3BzID09PSBudWxsIHx8IHRleHRGaWVsZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RmllbGRQcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICA/IHRleHRGaWVsZFByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHRGaWVsZFByb3BzID09PSBudWxsIHx8IHRleHRGaWVsZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RmllbGRQcm9wcy5zeCkpKSB9KSldIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Qcm9ncmVzc0JhciA9ICh7IGlzVG9wVG9vbGJhciwgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgbWFudGluZVByb2dyZXNzUHJvcHMgfSwgZ2V0U3RhdGUsIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzU2F2aW5nLCBzaG93UHJvZ3Jlc3NCYXJzIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGxpbmVhclByb2dyZXNzUHJvcHMgPSBtYW50aW5lUHJvZ3Jlc3NQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVByb2dyZXNzUHJvcHMoeyBpc1RvcFRvb2xiYXIsIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVByb2dyZXNzUHJvcHM7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkNvbGxhcHNlLCB7IGluOiBpc1NhdmluZyB8fCBzaG93UHJvZ3Jlc3NCYXJzLCBzeDoge1xuICAgICAgICAgICAgYm90dG9tOiBpc1RvcFRvb2xiYXIgPyAwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6ICFpc1RvcFRvb2xiYXIgPyAwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgfSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuUHJvZ3Jlc3MsIE9iamVjdC5hc3NpZ24oeyBhbmltYXRlOiB0cnVlLCBcImFyaWEtYnVzeVwiOiBcInRydWVcIiwgXCJhcmlhLWxhYmVsXCI6IFwiTG9hZGluZ1wiLCByYWRpdXM6IDAsIHZhbHVlOiAxMDAgfSwgbGluZWFyUHJvZ3Jlc3NQcm9wcykpIH0pKTtcbn07XG5cbmNvbnN0IGNvbW1vbkFjdGlvbkJ1dHRvblN0eWxlcyA9IHtcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgfSxcbn07XG5jb25zdCBNUlRfVGFibGVQYWdpbmF0aW9uID0gKHsgdGFibGUsIHBvc2l0aW9uID0gJ2JvdHRvbScsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwsIGdldFN0YXRlLCBzZXRQYWdlSW5kZXgsIHNldFBhZ2VTaXplLCBvcHRpb25zOiB7IGVuYWJsZVRvb2xiYXJJbnRlcm5hbEFjdGlvbnMsIGljb25zOiB7IEljb25DaGV2cm9uTGVmdFBpcGUsIEljb25DaGV2cm9uUmlnaHRQaXBlLCBJY29uQ2hldnJvbkxlZnQsIEljb25DaGV2cm9uUmlnaHQsIH0sIGxvY2FsaXphdGlvbiwgbWFudGluZVBhZ2luYXRpb25Qcm9wcywgcGFnaW5hdGlvbkRpc3BsYXlNb2RlLCByb3dDb3VudCwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgcGFnaW5hdGlvbjogeyBwYWdlU2l6ZSA9IDEwLCBwYWdlSW5kZXggPSAwIH0sIHNob3dHbG9iYWxGaWx0ZXIsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHBhZ2luYXRpb25Qcm9wcyA9IG1hbnRpbmVQYWdpbmF0aW9uUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVQYWdpbmF0aW9uUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVQYWdpbmF0aW9uUHJvcHM7XG4gICAgY29uc3QgdG90YWxSb3dDb3VudCA9IHJvd0NvdW50ICE9PSBudWxsICYmIHJvd0NvdW50ICE9PSB2b2lkIDAgPyByb3dDb3VudCA6IGdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoO1xuICAgIGNvbnN0IG51bWJlck9mUGFnZXMgPSBNYXRoLmNlaWwodG90YWxSb3dDb3VudCAvIHBhZ2VTaXplKTtcbiAgICBjb25zdCBzaG93Rmlyc3RMYXN0UGFnZUJ1dHRvbnMgPSBudW1iZXJPZlBhZ2VzID4gMiAmJiAocGFnaW5hdGlvblByb3BzID09PSBudWxsIHx8IHBhZ2luYXRpb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvblByb3BzLndpdGhFZGdlcykgIT09IGZhbHNlO1xuICAgIGNvbnN0IGZpcnN0Um93SW5kZXggPSBwYWdlSW5kZXggKiBwYWdlU2l6ZTtcbiAgICBjb25zdCBsYXN0Um93SW5kZXggPSBNYXRoLm1pbihwYWdlSW5kZXggKiBwYWdlU2l6ZSArIHBhZ2VTaXplLCB0b3RhbFJvd0NvdW50KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkZsZXgsIHsgYWxpZ246IFwiY2VudGVyXCIsIGp1c3RpZnk6IFwic3BhY2UtYmV0d2VlblwiLCBnYXA6IFwibGdcIiwgcHk6IFwieHNcIiwgcHg6IFwic21cIiwgbXQ6IHBvc2l0aW9uID09PSAndG9wJyAmJiBlbmFibGVUb29sYmFySW50ZXJuYWxBY3Rpb25zICYmICFzaG93R2xvYmFsRmlsdGVyXG4gICAgICAgICAgICA/ICczcmVtJ1xuICAgICAgICAgICAgOiB1bmRlZmluZWQsIHA6IFwicmVsYXRpdmVcIiwgc3g6IHsgekluZGV4OiAyIH0sIGNoaWxkcmVuOiBbKHBhZ2luYXRpb25Qcm9wcyA9PT0gbnVsbCB8fCBwYWdpbmF0aW9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2luYXRpb25Qcm9wcy5zaG93Um93c1BlclBhZ2UpICE9PSBmYWxzZSAmJiAoanN4UnVudGltZS5qc3goY29yZS5TZWxlY3QsIHsgZGF0YTogKF9hID0gcGFnaW5hdGlvblByb3BzID09PSBudWxsIHx8IHBhZ2luYXRpb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvblByb3BzLnJvd3NQZXJQYWdlT3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW1xuICAgICAgICAgICAgICAgICAgICAnNScsXG4gICAgICAgICAgICAgICAgICAgICcxMCcsXG4gICAgICAgICAgICAgICAgICAgICcxNScsXG4gICAgICAgICAgICAgICAgICAgICcyMCcsXG4gICAgICAgICAgICAgICAgICAgICcyNScsXG4gICAgICAgICAgICAgICAgICAgICczMCcsXG4gICAgICAgICAgICAgICAgICAgICc1MCcsXG4gICAgICAgICAgICAgICAgICAgICcxMDAnLFxuICAgICAgICAgICAgICAgIF0sIGxhYmVsOiBsb2NhbGl6YXRpb24ucm93c1BlclBhZ2UsIG9uQ2hhbmdlOiAodmFsdWUpID0+IHNldFBhZ2VTaXplKCt2YWx1ZSksIHZhbHVlOiBwYWdlU2l6ZS50b1N0cmluZygpLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAnQG1lZGlhIChtaW4td2lkdGg6IDcyMHB4KSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiAnOHB4JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJyYgLm1hbnRpbmUtU2VsZWN0LWlucHV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICc4MHB4JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCB3aXRoaW5Qb3J0YWw6IHRydWUgfSkpLCBwYWdpbmF0aW9uRGlzcGxheU1vZGUgPT09ICdwYWdlcycgPyAoanN4UnVudGltZS5qc3goY29yZS5QYWdpbmF0aW9uLCBPYmplY3QuYXNzaWduKHsgb25DaGFuZ2U6IChuZXdQYWdlSW5kZXgpID0+IHNldFBhZ2VJbmRleChuZXdQYWdlSW5kZXggLSAxKSwgdG90YWw6IG51bWJlck9mUGFnZXMsIHZhbHVlOiBwYWdlSW5kZXggKyAxLCB3aXRoRWRnZXM6IHNob3dGaXJzdExhc3RQYWdlQnV0dG9ucywgbmV4dEljb246IEljb25DaGV2cm9uUmlnaHQsIHByZXZpb3VzSWNvbjogSWNvbkNoZXZyb25MZWZ0LCBmaXJzdEljb246IEljb25DaGV2cm9uTGVmdFBpcGUsIGxhc3RJY29uOiBJY29uQ2hldnJvblJpZ2h0UGlwZSB9LCBwYWdpbmF0aW9uUHJvcHMpKSkgOiBwYWdpbmF0aW9uRGlzcGxheU1vZGUgPT09ICdkZWZhdWx0JyA/IChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuVGV4dCwgeyBjaGlsZHJlbjogYCR7bGFzdFJvd0luZGV4ID09PSAwID8gMCA6IChmaXJzdFJvd0luZGV4ICsgMSkudG9Mb2NhbGVTdHJpbmcoKX0tJHtsYXN0Um93SW5kZXgudG9Mb2NhbGVTdHJpbmcoKX0gJHtsb2NhbGl6YXRpb24ub2Z9ICR7dG90YWxSb3dDb3VudC50b0xvY2FsZVN0cmluZygpfWAgfSksIGpzeFJ1bnRpbWUuanN4cyhjb3JlLkZsZXgsIHsgZ2FwOiBcInhzXCIsIGNoaWxkcmVuOiBbc2hvd0ZpcnN0TGFzdFBhZ2VCdXR0b25zICYmIChqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5nb1RvRmlyc3RQYWdlLCBkaXNhYmxlZDogcGFnZUluZGV4IDw9IDAsIG9uQ2xpY2s6ICgpID0+IHNldFBhZ2VJbmRleCgwKSwgc3g6IGNvbW1vbkFjdGlvbkJ1dHRvblN0eWxlcywgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25DaGV2cm9uTGVmdFBpcGUsIHt9KSB9KSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmdvVG9QcmV2aW91c1BhZ2UsIGRpc2FibGVkOiBwYWdlSW5kZXggPD0gMCwgb25DbGljazogKCkgPT4gc2V0UGFnZUluZGV4KHBhZ2VJbmRleCAtIDEpLCBzeDogY29tbW9uQWN0aW9uQnV0dG9uU3R5bGVzLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvbkNoZXZyb25MZWZ0LCB7fSkgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmdvVG9OZXh0UGFnZSwgZGlzYWJsZWQ6IGxhc3RSb3dJbmRleCA+PSB0b3RhbFJvd0NvdW50LCBvbkNsaWNrOiAoKSA9PiBzZXRQYWdlSW5kZXgocGFnZUluZGV4ICsgMSksIHN4OiBjb21tb25BY3Rpb25CdXR0b25TdHlsZXMsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uQ2hldnJvblJpZ2h0LCB7fSkgfSksIHNob3dGaXJzdExhc3RQYWdlQnV0dG9ucyAmJiAoanN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uZ29Ub0xhc3RQYWdlLCBkaXNhYmxlZDogbGFzdFJvd0luZGV4ID49IHRvdGFsUm93Q291bnQsIG9uQ2xpY2s6ICgpID0+IHNldFBhZ2VJbmRleChudW1iZXJPZlBhZ2VzIC0gMSksIHN4OiBjb21tb25BY3Rpb25CdXR0b25TdHlsZXMsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uQ2hldnJvblJpZ2h0UGlwZSwge30pIH0pKV0gfSldIH0pKSA6IG51bGxdIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9GaWx0ZXJDaGVja2JveCA9ICh7IGNvbHVtbiwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGxvY2FsaXphdGlvbiwgbWFudGluZUZpbHRlckNoZWNrYm94UHJvcHMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZGVuc2l0eSB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IG1UYWJsZUhlYWRDZWxsRmlsdGVyQ2hlY2tib3hQcm9wcyA9IG1hbnRpbmVGaWx0ZXJDaGVja2JveFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lRmlsdGVyQ2hlY2tib3hQcm9wcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBtYW50aW5lRmlsdGVyQ2hlY2tib3hQcm9wcztcbiAgICBjb25zdCBtY1RhYmxlSGVhZENlbGxGaWx0ZXJDaGVja2JveFByb3BzID0gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJDaGVja2JveFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBjb2x1bW5EZWYubWFudGluZUZpbHRlckNoZWNrYm94UHJvcHMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pXG4gICAgICAgIDogY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJDaGVja2JveFByb3BzO1xuICAgIGNvbnN0IGNoZWNrYm94UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1UYWJsZUhlYWRDZWxsRmlsdGVyQ2hlY2tib3hQcm9wcyksIG1jVGFibGVIZWFkQ2VsbEZpbHRlckNoZWNrYm94UHJvcHMpO1xuICAgIGNvbnN0IGZpbHRlckxhYmVsID0gKF9hID0gbG9jYWxpemF0aW9uLmZpbHRlckJ5Q29sdW1uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW5EZWYuaGVhZGVyKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIG9wZW5EZWxheTogMTAwMCwgbGFiZWw6IChfYiA9IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmlsdGVyTGFiZWwsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkNoZWNrYm94LCBPYmplY3QuYXNzaWduKHsgY2hlY2tlZDogY29sdW1uLmdldEZpbHRlclZhbHVlKCkgPT09ICd0cnVlJywgaW5kZXRlcm1pbmF0ZTogY29sdW1uLmdldEZpbHRlclZhbHVlKCkgPT09IHVuZGVmaW5lZCwgY29sb3I6IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpID09PSB1bmRlZmluZWQgPyAnZGVmYXVsdCcgOiAncHJpbWFyeScsIHNpemU6IGRlbnNpdHkgPT09ICd4cycgPyAnc20nIDogJ21kJywgbGFiZWw6IChfYyA9IGNoZWNrYm94UHJvcHMudGl0bGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZpbHRlckxhYmVsIH0sIGNoZWNrYm94UHJvcHMsIHsgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBjaGVja2JveFByb3BzID09PSBudWxsIHx8IGNoZWNrYm94UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoZWNrYm94UHJvcHMub25DbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2hlY2tib3hQcm9wcywgZSk7XG4gICAgICAgICAgICB9LCBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgOiBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdmYWxzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBjaGVja2JveFByb3BzID09PSBudWxsIHx8IGNoZWNrYm94UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoZWNrYm94UHJvcHMub25DaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoZWNrYm94UHJvcHMsIGUpO1xuICAgICAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBmb250V2VpZ2h0OiAnbm9ybWFsJywgbWFyZ2luVG9wOiAnOHB4JyB9LCAoKGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgID8gY2hlY2tib3hQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgICAgICA6IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy5zeCkpKSwgdGl0bGU6IHVuZGVmaW5lZCB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX0ZpbHRlclRleHRJbnB1dCA9ICh7IGhlYWRlciwgcmFuZ2VGaWx0ZXJJbmRleCwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGNvbHVtbkZpbHRlck1vZGVPcHRpb25zLCBpY29uczogeyBJY29uWCB9LCBsb2NhbGl6YXRpb24sIG1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcywgbWFudGluZUZpbHRlckRhdGVJbnB1dFByb3BzLCBtYW50aW5lRmlsdGVyTXVsdGlTZWxlY3RQcm9wcywgbWFudGluZUZpbHRlclNlbGVjdFByb3BzLCBtYW50aW5lRmlsdGVyVGV4dElucHV0UHJvcHMsIG1hbnVhbEZpbHRlcmluZywgfSwgcmVmczogeyBmaWx0ZXJJbnB1dFJlZnMgfSwgc2V0Q29sdW1uRmlsdGVyRm5zLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IG1GaWx0ZXJUZXh0SW5wdXRQcm9wcyA9IG1hbnRpbmVGaWx0ZXJUZXh0SW5wdXRQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUZpbHRlclRleHRJbnB1dFByb3BzKHtcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgcmFuZ2VGaWx0ZXJJbmRleCxcbiAgICAgICAgfSlcbiAgICAgICAgOiBtYW50aW5lRmlsdGVyVGV4dElucHV0UHJvcHM7XG4gICAgY29uc3QgbWNGaWx0ZXJUZXh0SW5wdXRQcm9wcyA9IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyVGV4dElucHV0UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyVGV4dElucHV0UHJvcHMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICByYW5nZUZpbHRlckluZGV4LFxuICAgICAgICB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyVGV4dElucHV0UHJvcHM7XG4gICAgY29uc3QgdGV4dElucHV0UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1GaWx0ZXJUZXh0SW5wdXRQcm9wcyksIG1jRmlsdGVyVGV4dElucHV0UHJvcHMpO1xuICAgIGNvbnN0IG1TZWxlY3RQcm9wcyA9IG1hbnRpbmVGaWx0ZXJTZWxlY3RQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUZpbHRlclNlbGVjdFByb3BzKHsgY29sdW1uLCB0YWJsZSwgcmFuZ2VGaWx0ZXJJbmRleCB9KVxuICAgICAgICA6IG1hbnRpbmVGaWx0ZXJTZWxlY3RQcm9wcztcbiAgICBjb25zdCBtY1NlbGVjdFByb3BzID0gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJTZWxlY3RQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJTZWxlY3RQcm9wcyh7IGNvbHVtbiwgdGFibGUsIHJhbmdlRmlsdGVySW5kZXggfSlcbiAgICAgICAgOiBjb2x1bW5EZWYubWFudGluZUZpbHRlclNlbGVjdFByb3BzO1xuICAgIGNvbnN0IHNlbGVjdFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtU2VsZWN0UHJvcHMpLCBtY1NlbGVjdFByb3BzKTtcbiAgICBjb25zdCBtTXVsdGlTZWxlY3RQcm9wcyA9IG1hbnRpbmVGaWx0ZXJNdWx0aVNlbGVjdFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lRmlsdGVyTXVsdGlTZWxlY3RQcm9wcyh7IGNvbHVtbiwgdGFibGUsIHJhbmdlRmlsdGVySW5kZXggfSlcbiAgICAgICAgOiBtYW50aW5lRmlsdGVyTXVsdGlTZWxlY3RQcm9wcztcbiAgICBjb25zdCBtY011bHRpU2VsZWN0UHJvcHMgPSBjb2x1bW5EZWYubWFudGluZUZpbHRlck11bHRpU2VsZWN0UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyTXVsdGlTZWxlY3RQcm9wcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHJhbmdlRmlsdGVySW5kZXgsXG4gICAgICAgIH0pXG4gICAgICAgIDogY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJNdWx0aVNlbGVjdFByb3BzO1xuICAgIGNvbnN0IG11bHRpU2VsZWN0UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1NdWx0aVNlbGVjdFByb3BzKSwgbWNNdWx0aVNlbGVjdFByb3BzKTtcbiAgICBjb25zdCBtRGF0ZUlucHV0UHJvcHMgPSBtYW50aW5lRmlsdGVyRGF0ZUlucHV0UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVGaWx0ZXJEYXRlSW5wdXRQcm9wcyh7IGNvbHVtbiwgdGFibGUsIHJhbmdlRmlsdGVySW5kZXggfSlcbiAgICAgICAgOiBtYW50aW5lRmlsdGVyRGF0ZUlucHV0UHJvcHM7XG4gICAgY29uc3QgbWNEYXRlSW5wdXRQcm9wcyA9IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyRGF0ZUlucHV0UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyRGF0ZUlucHV0UHJvcHMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICByYW5nZUZpbHRlckluZGV4LFxuICAgICAgICB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lRmlsdGVyRGF0ZUlucHV0UHJvcHM7XG4gICAgY29uc3QgZGF0ZUlucHV0UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1EYXRlSW5wdXRQcm9wcyksIG1jRGF0ZUlucHV0UHJvcHMpO1xuICAgIGNvbnN0IG1BdXRvQ29tcGxldGVQcm9wcyA9IG1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUZpbHRlckF1dG9jb21wbGV0ZVByb3BzKHsgY29sdW1uLCB0YWJsZSwgcmFuZ2VGaWx0ZXJJbmRleCB9KVxuICAgICAgICA6IG1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcztcbiAgICBjb25zdCBtY0F1dG9Db21wbGV0ZVByb3BzID0gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHJhbmdlRmlsdGVySW5kZXgsXG4gICAgICAgIH0pXG4gICAgICAgIDogY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJBdXRvY29tcGxldGVQcm9wcztcbiAgICBjb25zdCBhdXRvQ29tcGxldGVQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbUF1dG9Db21wbGV0ZVByb3BzKSwgbWNBdXRvQ29tcGxldGVQcm9wcyk7XG4gICAgY29uc3QgaXNSYW5nZUZpbHRlciA9IGNvbHVtbkRlZi5maWx0ZXJWYXJpYW50ID09PSAncmFuZ2UnIHx8XG4gICAgICAgIGNvbHVtbkRlZi5maWx0ZXJWYXJpYW50ID09PSAnZGF0ZS1yYW5nZScgfHxcbiAgICAgICAgcmFuZ2VGaWx0ZXJJbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzU2VsZWN0RmlsdGVyID0gY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdzZWxlY3QnO1xuICAgIGNvbnN0IGlzTXVsdGlTZWxlY3RGaWx0ZXIgPSBjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCA9PT0gJ211bHRpLXNlbGVjdCc7XG4gICAgY29uc3QgaXNEYXRlRmlsdGVyID0gY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdkYXRlJyB8fFxuICAgICAgICBjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCA9PT0gJ2RhdGUtcmFuZ2UnO1xuICAgIGNvbnN0IGlzQXV0b0NvbXBsZXRlRmlsdGVyID0gY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdhdXRvY29tcGxldGUnO1xuICAgIGNvbnN0IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmNvbHVtbkZpbHRlck1vZGVPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2x1bW5GaWx0ZXJNb2RlT3B0aW9ucztcbiAgICBjb25zdCBjdXJyZW50RmlsdGVyT3B0aW9uID0gY29sdW1uRGVmLl9maWx0ZXJGbjtcbiAgICBjb25zdCBmaWx0ZXJDaGlwTGFiZWwgPSBbJ2VtcHR5JywgJ25vdEVtcHR5J10uaW5jbHVkZXMoY3VycmVudEZpbHRlck9wdGlvbilcbiAgICAgICAgPyAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGxvY2FsaXphdGlvbltgZmlsdGVyJHsoKF9jID0gKF9iID0gY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLmNoYXJBdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoY3VycmVudEZpbHRlck9wdGlvbiwgMCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1VwcGVyQ2FzZSgpKSArXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IG51bGwgfHwgY3VycmVudEZpbHRlck9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZpbHRlck9wdGlvbi5zbGljZSgxKSl9YF1cbiAgICAgICAgOiAnJztcbiAgICBjb25zdCBmaWx0ZXJQbGFjZWhvbGRlciA9ICFpc1JhbmdlRmlsdGVyXG4gICAgICAgID8gKF9kID0gdGV4dElucHV0UHJvcHMgPT09IG51bGwgfHwgdGV4dElucHV0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRJbnB1dFByb3BzLnBsYWNlaG9sZGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoX2UgPSBsb2NhbGl6YXRpb24uZmlsdGVyQnlDb2x1bW4pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSlcbiAgICAgICAgOiByYW5nZUZpbHRlckluZGV4ID09PSAwXG4gICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5taW5cbiAgICAgICAgICAgIDogcmFuZ2VGaWx0ZXJJbmRleCA9PT0gMVxuICAgICAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLm1heFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgY29uc3QgZmFjZXRlZFVuaXF1ZVZhbHVlcyA9IGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgY29uc3QgZmlsdGVyU2VsZWN0T3B0aW9ucyA9IHJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICgoX2MgPSAoX2IgPSAoX2EgPSBhdXRvQ29tcGxldGVQcm9wcyA9PT0gbnVsbCB8fCBhdXRvQ29tcGxldGVQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0b0NvbXBsZXRlUHJvcHMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2VsZWN0UHJvcHMgPT09IG51bGwgfHwgc2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdFByb3BzLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG11bHRpU2VsZWN0UHJvcHMgPT09IG51bGwgfHwgbXVsdGlTZWxlY3RQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXVsdGlTZWxlY3RQcm9wcy5kYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKGlzQXV0b0NvbXBsZXRlRmlsdGVyIHx8IGlzU2VsZWN0RmlsdGVyIHx8IGlzTXVsdGlTZWxlY3RGaWx0ZXIpICYmXG4gICAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzXG4gICAgICAgICAgICA/IEFycmF5LmZyb20oZmFjZXRlZFVuaXF1ZVZhbHVlcy5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSlcbiAgICAgICAgICAgIDogW10pKVxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAuZmlsdGVyKChvKSA9PiBvICE9PSB1bmRlZmluZWQgJiYgbyAhPT0gbnVsbCk7XG4gICAgfSwgW1xuICAgICAgICBhdXRvQ29tcGxldGVQcm9wcyA9PT0gbnVsbCB8fCBhdXRvQ29tcGxldGVQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0b0NvbXBsZXRlUHJvcHMuZGF0YSxcbiAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcyxcbiAgICAgICAgaXNBdXRvQ29tcGxldGVGaWx0ZXIsXG4gICAgICAgIGlzTXVsdGlTZWxlY3RGaWx0ZXIsXG4gICAgICAgIGlzU2VsZWN0RmlsdGVyLFxuICAgICAgICBtdWx0aVNlbGVjdFByb3BzID09PSBudWxsIHx8IG11bHRpU2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11bHRpU2VsZWN0UHJvcHMuZGF0YSxcbiAgICAgICAgc2VsZWN0UHJvcHMgPT09IG51bGwgfHwgc2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdFByb3BzLmRhdGEsXG4gICAgXSk7XG4gICAgY29uc3QgaXNNb3VudGVkID0gcmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBbZmlsdGVyVmFsdWUsIHNldEZpbHRlclZhbHVlXSA9IHJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIGlzTXVsdGlTZWxlY3RGaWx0ZXJcbiAgICAgICAgICAgID8gY29sdW1uLmdldEZpbHRlclZhbHVlKCkgfHwgW11cbiAgICAgICAgICAgIDogaXNSYW5nZUZpbHRlclxuICAgICAgICAgICAgICAgID8gKChfYSA9IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmFuZ2VGaWx0ZXJJbmRleF0pIHx8ICcnXG4gICAgICAgICAgICAgICAgOiAoX2IgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgfSk7XG4gICAgY29uc3QgW2RlYm91bmNlZEZpbHRlclZhbHVlXSA9IGhvb2tzLnVzZURlYm91bmNlZFZhbHVlKGZpbHRlclZhbHVlLCBtYW51YWxGaWx0ZXJpbmcgPyA0MDAgOiAyMDApO1xuICAgIC8vc2VuZCBkZWJvdW5jZWQgZmlsdGVyVmFsdWUgdG8gdGFibGUgaW5zdGFuY2VcbiAgICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXNSYW5nZUZpbHRlcikge1xuICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKChvbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWx0ZXJWYWx1ZXMgPSBBcnJheS5pc0FycmF5KG9sZCkgPyBvbGQgOiBbJycsICcnXTtcbiAgICAgICAgICAgICAgICBuZXdGaWx0ZXJWYWx1ZXNbcmFuZ2VGaWx0ZXJJbmRleF0gPVxuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZWRGaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RmlsdGVyVmFsdWVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoZGVib3VuY2VkRmlsdGVyVmFsdWUgIT09IG51bGwgJiYgZGVib3VuY2VkRmlsdGVyVmFsdWUgIT09IHZvaWQgMCA/IGRlYm91bmNlZEZpbHRlclZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWJvdW5jZWRGaWx0ZXJWYWx1ZV0pO1xuICAgIC8vcmVjZWl2ZSB0YWJsZSBmaWx0ZXIgdmFsdWUgYW5kIHNldCBpdCB0byBsb2NhbCBzdGF0ZVxuICAgIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUZpbHRlclZhbHVlID0gY29sdW1uLmdldEZpbHRlclZhbHVlKCk7XG4gICAgICAgIGlmICh0YWJsZUZpbHRlclZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZUNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSYW5nZUZpbHRlciAmJiByYW5nZUZpbHRlckluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldEZpbHRlclZhbHVlKCh0YWJsZUZpbHRlclZhbHVlICE9PSBudWxsICYmIHRhYmxlRmlsdGVyVmFsdWUgIT09IHZvaWQgMCA/IHRhYmxlRmlsdGVyVmFsdWUgOiBbJycsICcnXSlbcmFuZ2VGaWx0ZXJJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWUodGFibGVGaWx0ZXJWYWx1ZSAhPT0gbnVsbCAmJiB0YWJsZUZpbHRlclZhbHVlICE9PSB2b2lkIDAgPyB0YWJsZUZpbHRlclZhbHVlIDogJycpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpXSk7XG4gICAgY29uc3QgaGFuZGxlQ2xlYXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc011bHRpU2VsZWN0RmlsdGVyKSB7XG4gICAgICAgICAgICBzZXRGaWx0ZXJWYWx1ZShbXSk7XG4gICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFuZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIHNldEZpbHRlclZhbHVlKCcnKTtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSgob2xkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RmlsdGVyVmFsdWVzID0gQXJyYXkuaXNBcnJheShvbGQpID8gb2xkIDogWycnLCAnJ107XG4gICAgICAgICAgICAgICAgbmV3RmlsdGVyVmFsdWVzW3JhbmdlRmlsdGVySW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJWYWx1ZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldEZpbHRlclZhbHVlKCcnKTtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoY29sdW1uRGVmLkZpbHRlcikge1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IChfZiA9IGNvbHVtbkRlZi5GaWx0ZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKGNvbHVtbkRlZiwgeyBjb2x1bW4sIGhlYWRlciwgcmFuZ2VGaWx0ZXJJbmRleCwgdGFibGUgfSkgfSkpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVDbGVhckVtcHR5RmlsdGVyQ2hpcCA9ICgpID0+IHtcbiAgICAgICAgc2V0RmlsdGVyVmFsdWUoJycpO1xuICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0Q29sdW1uRmlsdGVyRm5zKChwcmV2KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIHsgW2hlYWRlci5pZF06IChfYSA9IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSBudWxsIHx8IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9uc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2Z1enp5JyB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgICAgIGRpc2FibGVkOiAhIWZpbHRlckNoaXBMYWJlbCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IGZpbHRlclBsYWNlaG9sZGVyLFxuICAgICAgICB0aXRsZTogZmlsdGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIG9uQ2xpY2s6IChldmVudCkgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgICAgIG9uQ2hhbmdlOiBzZXRGaWx0ZXJWYWx1ZSxcbiAgICAgICAgdmFsdWU6IGZpbHRlclZhbHVlLFxuICAgICAgICB2YXJpYW50OiAndW5zdHlsZWQnLFxuICAgICAgICBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ncmF5W3RoZW1lLmNvbG9yU2NoZW1lID09PSAnZGFyaycgPyA3IDogM119YCwgbWluV2lkdGg6IGlzRGF0ZUZpbHRlclxuICAgICAgICAgICAgICAgID8gJzEyNXB4J1xuICAgICAgICAgICAgICAgIDogaXNSYW5nZUZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/ICc4MHB4J1xuICAgICAgICAgICAgICAgICAgICA6ICFmaWx0ZXJDaGlwTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJzEwMHB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnYXV0bycsIHdpZHRoOiAnMTAwJScsICcmIC5tYW50aW5lLVRleHRJbnB1dC1pbnB1dCc6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgfSwgJyYgLm1hbnRpbmUtRGF0ZUlucHV0LWlucHV0Jzoge1xuICAgICAgICAgICAgICAgIGhlaWdodDogJzIuMXJlbScsXG4gICAgICAgICAgICB9IH0sIGNvcmUucGFja1N4KGlzTXVsdGlTZWxlY3RGaWx0ZXJcbiAgICAgICAgICAgID8gbXVsdGlTZWxlY3RQcm9wcy5zeFxuICAgICAgICAgICAgOiBpc1NlbGVjdEZpbHRlclxuICAgICAgICAgICAgICAgID8gc2VsZWN0UHJvcHMuc3hcbiAgICAgICAgICAgICAgICA6IGlzRGF0ZUZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/IGRhdGVJbnB1dFByb3BzLnN4XG4gICAgICAgICAgICAgICAgICAgIDogdGV4dElucHV0UHJvcHMgPT09IG51bGwgfHwgdGV4dElucHV0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRJbnB1dFByb3BzLnN4KSkpLFxuICAgIH07XG4gICAgY29uc3QgQ2xlYXJCdXR0b24gPSBmaWx0ZXJWYWx1ZSA/IChqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5jbGVhckZpbHRlciwgb25DbGljazogaGFuZGxlQ2xlYXIsIHNpemU6IFwic21cIiwgdGl0bGU6IChfZyA9IGxvY2FsaXphdGlvbi5jbGVhckZpbHRlcikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogJycsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uWCwge30pIH0pKSA6IG51bGw7XG4gICAgcmV0dXJuIGZpbHRlckNoaXBMYWJlbCA/IChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgeyBzeDogY29tbW9uUHJvcHMuc3gsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkJhZGdlLCB7IHNpemU6IFwibGdcIiwgb25DbGljazogaGFuZGxlQ2xlYXJFbXB0eUZpbHRlckNoaXAsIHN4OiB7IG1hcmdpbjogJzVweCcgfSwgcmlnaHRTZWN0aW9uOiBDbGVhckJ1dHRvbiwgY2hpbGRyZW46IGZpbHRlckNoaXBMYWJlbCB9KSB9KSkgOiBpc011bHRpU2VsZWN0RmlsdGVyID8gKGpzeFJ1bnRpbWUuanN4KGNvcmUuTXVsdGlTZWxlY3QsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblByb3BzLCB7IGNsZWFyYWJsZTogdHJ1ZSwgc2VhcmNoYWJsZTogdHJ1ZSwgd2l0aGluUG9ydGFsOiB0cnVlIH0sIG11bHRpU2VsZWN0UHJvcHMsIHsgZGF0YTogZmlsdGVyU2VsZWN0T3B0aW9ucywgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbnB1dFJlZnMuY3VycmVudFtgJHtjb2x1bW4uaWR9LSR7cmFuZ2VGaWx0ZXJJbmRleCAhPT0gbnVsbCAmJiByYW5nZUZpbHRlckluZGV4ICE9PSB2b2lkIDAgPyByYW5nZUZpbHRlckluZGV4IDogMH1gXSA9XG4gICAgICAgICAgICAgICAgICAgIG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0UHJvcHMucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpU2VsZWN0UHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6IGNvbW1vblByb3BzLnN4IH0pKSkgOiBpc1NlbGVjdEZpbHRlciA/IChqc3hSdW50aW1lLmpzeChjb3JlLlNlbGVjdCwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUHJvcHMsIHsgY2xlYXJhYmxlOiB0cnVlLCBzZWFyY2hhYmxlOiB0cnVlLCB3aXRoaW5Qb3J0YWw6IHRydWUgfSwgc2VsZWN0UHJvcHMsIHsgZGF0YTogZmlsdGVyU2VsZWN0T3B0aW9ucywgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbnB1dFJlZnMuY3VycmVudFtgJHtjb2x1bW4uaWR9LSR7cmFuZ2VGaWx0ZXJJbmRleCAhPT0gbnVsbCAmJiByYW5nZUZpbHRlckluZGV4ICE9PSB2b2lkIDAgPyByYW5nZUZpbHRlckluZGV4IDogMH1gXSA9XG4gICAgICAgICAgICAgICAgICAgIG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdFByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RQcm9wcy5yZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzeDogY29tbW9uUHJvcHMuc3ggfSkpKSA6IGlzRGF0ZUZpbHRlciA/IChqc3hSdW50aW1lLmpzeChkYXRlcy5EYXRlSW5wdXQsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblByb3BzLCB7IGFsbG93RGVzZWxlY3Q6IHRydWUsIGNsZWFyYWJsZTogdHJ1ZSwgcG9wb3ZlclByb3BzOiB7IHdpdGhpblBvcnRhbDogY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgIT09ICdwb3BvdmVyJyB9IH0sIGRhdGVJbnB1dFByb3BzLCB7IHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5wdXRSZWZzLmN1cnJlbnRbYCR7Y29sdW1uLmlkfS0ke3JhbmdlRmlsdGVySW5kZXggIT09IG51bGwgJiYgcmFuZ2VGaWx0ZXJJbmRleCAhPT0gdm9pZCAwID8gcmFuZ2VGaWx0ZXJJbmRleCA6IDB9YF0gPVxuICAgICAgICAgICAgICAgICAgICBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5wdXRQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUlucHV0UHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6IGNvbW1vblByb3BzLnN4IH0pKSkgOiBpc0F1dG9Db21wbGV0ZUZpbHRlciA/IChqc3hSdW50aW1lLmpzeChjb3JlLkF1dG9jb21wbGV0ZSwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUHJvcHMsIHsgcmlnaHRTZWN0aW9uOiAoKF9oID0gZmlsdGVyVmFsdWUgPT09IG51bGwgfHwgZmlsdGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlclZhbHVlLnRvU3RyaW5nKCkpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5sZW5ndGgpID8gQ2xlYXJCdXR0b24gOiB1bmRlZmluZWQsIG9uQ2hhbmdlOiAodmFsdWUpID0+IHNldEZpbHRlclZhbHVlKHZhbHVlKSwgd2l0aGluUG9ydGFsOiB0cnVlIH0sIGF1dG9Db21wbGV0ZVByb3BzLCB7IGRhdGE6IGZpbHRlclNlbGVjdE9wdGlvbnMsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5wdXRSZWZzLmN1cnJlbnRbYCR7Y29sdW1uLmlkfS0ke3JhbmdlRmlsdGVySW5kZXggIT09IG51bGwgJiYgcmFuZ2VGaWx0ZXJJbmRleCAhPT0gdm9pZCAwID8gcmFuZ2VGaWx0ZXJJbmRleCA6IDB9YF0gPVxuICAgICAgICAgICAgICAgICAgICBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChhdXRvQ29tcGxldGVQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlUHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6IGNvbW1vblByb3BzLnN4IH0pKSkgOiAoanN4UnVudGltZS5qc3goY29yZS5UZXh0SW5wdXQsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblByb3BzLCB7IHJpZ2h0U2VjdGlvbjogKChfaiA9IGZpbHRlclZhbHVlID09PSBudWxsIHx8IGZpbHRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZS50b1N0cmluZygpKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oubGVuZ3RoKSA/IENsZWFyQnV0dG9uIDogdW5kZWZpbmVkLCBvbkNoYW5nZTogKGUpID0+IHNldEZpbHRlclZhbHVlKGUudGFyZ2V0LnZhbHVlKSB9LCB0ZXh0SW5wdXRQcm9wcywgeyByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklucHV0UmVmcy5jdXJyZW50W2Ake2NvbHVtbi5pZH0tJHtyYW5nZUZpbHRlckluZGV4ICE9PSBudWxsICYmIHJhbmdlRmlsdGVySW5kZXggIT09IHZvaWQgMCA/IHJhbmdlRmlsdGVySW5kZXggOiAwfWBdID1cbiAgICAgICAgICAgICAgICAgICAgbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dElucHV0UHJvcHMucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRJbnB1dFByb3BzLnJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN4OiBjb21tb25Qcm9wcy5zeCB9KSkpO1xufTtcblxuY29uc3QgTVJUX0ZpbHRlclJhbmdlRmllbGRzID0gKHsgaGVhZGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdncmlkJywgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzZmciA2ZnInLCBnYXA6ICcxNnB4JyB9LCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KE1SVF9GaWx0ZXJUZXh0SW5wdXQsIHsgaGVhZGVyOiBoZWFkZXIsIHJhbmdlRmlsdGVySW5kZXg6IDAsIHRhYmxlOiB0YWJsZSB9KSwganN4UnVudGltZS5qc3goTVJUX0ZpbHRlclRleHRJbnB1dCwgeyBoZWFkZXI6IGhlYWRlciwgcmFuZ2VGaWx0ZXJJbmRleDogMSwgdGFibGU6IHRhYmxlIH0pXSB9KSk7XG59O1xuXG5jb25zdCBNUlRfVG9vbGJhckFsZXJ0QmFubmVyID0gKHsgc3RhY2tBbGVydEJhbm5lciwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCwgZ2V0U2VsZWN0ZWRSb3dNb2RlbCwgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlUm93U2VsZWN0aW9uLCBlbmFibGVTZWxlY3RBbGwsIGljb25zOiB7IEljb25YIH0sIGxvY2FsaXphdGlvbiwgbWFudGluZVRvb2xiYXJBbGVydEJhbm5lckJhZGdlUHJvcHMsIG1hbnRpbmVUb29sYmFyQWxlcnRCYW5uZXJQcm9wcywgcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIsIHJlbmRlclRvb2xiYXJBbGVydEJhbm5lckNvbnRlbnQsIHJvd0NvdW50LCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBncm91cGluZywgc2hvd0FsZXJ0QmFubmVyLCBkZW5zaXR5IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGFsZXJ0UHJvcHMgPSBtYW50aW5lVG9vbGJhckFsZXJ0QmFubmVyUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUb29sYmFyQWxlcnRCYW5uZXJQcm9wcyh7IHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVRvb2xiYXJBbGVydEJhbm5lclByb3BzO1xuICAgIGNvbnN0IGJhZGdlUHJvcHMgPSBtYW50aW5lVG9vbGJhckFsZXJ0QmFubmVyQmFkZ2VQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRvb2xiYXJBbGVydEJhbm5lckJhZGdlUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVUb29sYmFyQWxlcnRCYW5uZXJCYWRnZVByb3BzO1xuICAgIGNvbnN0IHNlbGVjdGVkQWxlcnQgPSBnZXRTZWxlY3RlZFJvd01vZGVsKCkucm93cy5sZW5ndGggPiAwXG4gICAgICAgID8gKF9iID0gKF9hID0gbG9jYWxpemF0aW9uLnNlbGVjdGVkQ291bnRPZlJvd0NvdW50Um93c1NlbGVjdGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgne3NlbGVjdGVkQ291bnR9JywgZ2V0U2VsZWN0ZWRSb3dNb2RlbCgpLnJvd3MubGVuZ3RoLnRvU3RyaW5nKCkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgne3Jvd0NvdW50fScsIChyb3dDb3VudCAhPT0gbnVsbCAmJiByb3dDb3VudCAhPT0gdm9pZCAwID8gcm93Q291bnQgOiBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5yb3dzLmxlbmd0aCkudG9TdHJpbmcoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGdyb3VwZWRBbGVydCA9IGdyb3VwaW5nLmxlbmd0aCA+IDAgPyAoanN4UnVudGltZS5qc3hzKGNvcmUuRmxleCwgeyBjaGlsZHJlbjogW2xvY2FsaXphdGlvbi5ncm91cGVkQnksICcgJywgZ3JvdXBpbmcubWFwKChjb2x1bW5JZCwgaW5kZXgpID0+IChqc3hSdW50aW1lLmpzeHMocmVhY3QuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtpbmRleCA+IDAgPyBsb2NhbGl6YXRpb24udGhlbkJ5IDogJycsIGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJhZGdlLCBPYmplY3QuYXNzaWduKHsgcmlnaHRTZWN0aW9uOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIHsgb25DbGljazogKCkgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKS50b2dnbGVHcm91cGluZygpLCBzaXplOiBcInhzXCIsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uWCwge30pIH0pLCBzeDogeyBtYXJnaW5MZWZ0OiAnMWNoJyB9LCB2YXJpYW50OiBcImZpbGxlZFwiIH0sIGJhZGdlUHJvcHMsIHsgY2hpbGRyZW46IFt0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpLmNvbHVtbkRlZi5oZWFkZXIsICcgJ10gfSkpXSB9LCBgJHtpbmRleH0tJHtjb2x1bW5JZH1gKSkpXSB9KSkgOiBudWxsO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5Db2xsYXBzZSwgeyBpbjogc2hvd0FsZXJ0QmFubmVyIHx8ICEhc2VsZWN0ZWRBbGVydCB8fCAhIWdyb3VwZWRBbGVydCwgdHJhbnNpdGlvbkR1cmF0aW9uOiBzdGFja0FsZXJ0QmFubmVyID8gMjAwIDogMCwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWxlcnQsIE9iamVjdC5hc3NpZ24oeyBjb2xvcjogXCJibHVlXCIsIGljb246IGZhbHNlIH0sIGFsZXJ0UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBib3JkZXJSYWRpdXM6IDAsIGZvbnRTaXplOiAnMTZweCcsIGxlZnQ6IDAsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBtYXJnaW5Cb3R0b206IHN0YWNrQWxlcnRCYW5uZXJcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIgPT09ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICctMTZweCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBwYWRkaW5nOiAnOHB4JywgcmlnaHQ6IDAsIHRvcDogMCwgd2lkdGg6ICcxMDAlJywgekluZGV4OiAyIH0sICgoYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyBhbGVydFByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgIDogYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLnN4KSkpLCBjaGlsZHJlbjogKF9jID0gcmVuZGVyVG9vbGJhckFsZXJ0QmFubmVyQ29udGVudCA9PT0gbnVsbCB8fCByZW5kZXJUb29sYmFyQWxlcnRCYW5uZXJDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJUb29sYmFyQWxlcnRCYW5uZXJDb250ZW50KHtcbiAgICAgICAgICAgICAgICBncm91cGVkQWxlcnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRBbGVydCxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoanN4UnVudGltZS5qc3hzKGNvcmUuRmxleCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICBnYXA6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIgPT09ICdoZWFkLW92ZXJsYXknXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRlbnNpdHkgPT09ICd4bCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcxNnB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVuc2l0eSA9PT0gJ21kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICc4cHgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzJweCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJzhweCAxNnB4JyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2VuYWJsZVJvd1NlbGVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlU2VsZWN0QWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciA9PT0gJ2hlYWQtb3ZlcmxheScgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9TZWxlY3RDaGVja2JveCwgeyBzZWxlY3RBbGw6IHRydWUsIHRhYmxlOiB0YWJsZSB9KSksIGpzeFJ1bnRpbWUuanN4cyhjb3JlLlN0YWNrLCB7IGNoaWxkcmVuOiBbYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLmNoaWxkcmVuLCAoYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLmNoaWxkcmVuKSAmJiAoc2VsZWN0ZWRBbGVydCB8fCBncm91cGVkQWxlcnQpICYmIChqc3hSdW50aW1lLmpzeChcImJyXCIsIHt9KSksIHNlbGVjdGVkQWxlcnQsIHNlbGVjdGVkQWxlcnQgJiYgZ3JvdXBlZEFsZXJ0ICYmIGpzeFJ1bnRpbWUuanN4KFwiYnJcIiwge30pLCBncm91cGVkQWxlcnRdIH0pXSB9KSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub2dnbGVGdWxsU2NyZWVuQnV0dG9uID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgSWNvbk1pbmltaXplLCBJY29uTWF4aW1pemUgfSwgbG9jYWxpemF0aW9uLCB9LCBzZXRJc0Z1bGxTY3JlZW4sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBbdG9vbHRpcE9wZW5lZCwgc2V0VG9vbHRpcE9wZW5lZF0gPSByZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlRnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICAgICAgc2V0VG9vbHRpcE9wZW5lZChmYWxzZSk7XG4gICAgICAgIHNldElzRnVsbFNjcmVlbighaXNGdWxsU2NyZWVuKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IG9wZW5lZDogdG9vbHRpcE9wZW5lZCwgd2l0aGluUG9ydGFsOiB0cnVlLCBsYWJlbDogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24udG9nZ2xlRnVsbFNjcmVlbiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24udG9nZ2xlRnVsbFNjcmVlbiwgb25DbGljazogaGFuZGxlVG9nZ2xlRnVsbFNjcmVlbiwgb25Nb3VzZUVudGVyOiAoKSA9PiBzZXRUb29sdGlwT3BlbmVkKHRydWUpLCBvbk1vdXNlTGVhdmU6ICgpID0+IHNldFRvb2x0aXBPcGVuZWQoZmFsc2UpLCBzaXplOiBcImxnXCIgfSwgcmVzdCwgeyB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogaXNGdWxsU2NyZWVuID8ganN4UnVudGltZS5qc3goSWNvbk1pbmltaXplLCB7fSkgOiBqc3hSdW50aW1lLmpzeChJY29uTWF4aW1pemUsIHt9KSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX0NvbHVtblBpbm5pbmdCdXR0b25zID0gKHsgY29sdW1uLCB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBpY29uczogeyBJY29uUGlubmVkLCBJY29uUGlubmVkT2ZmIH0sIGxvY2FsaXphdGlvbiwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IGhhbmRsZVBpbkNvbHVtbiA9IChwaW5EaXJlY3Rpb24pID0+IHtcbiAgICAgICAgY29sdW1uLnBpbihwaW5EaXJlY3Rpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkZsZXgsIHsgc3g6IHtcbiAgICAgICAgICAgIG1pbldpZHRoOiAnNzBweCcsXG4gICAgICAgICAgICBhbGlnbkNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICB9LCBjaGlsZHJlbjogY29sdW1uLmdldElzUGlubmVkKCkgPyAoanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgbGFiZWw6IGxvY2FsaXphdGlvbi51bnBpbiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oZmFsc2UpLCBzaXplOiBcIm1kXCIsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChJY29uUGlubmVkT2ZmLCB7fSkgfSkgfSkpIDogKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgbGFiZWw6IGxvY2FsaXphdGlvbi5waW5Ub0xlZnQsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIHsgb25DbGljazogKCkgPT4gaGFuZGxlUGluQ29sdW1uKCdsZWZ0JyksIHNpemU6IFwibWRcIiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25QaW5uZWQsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDkwZGVnKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSB9KSB9KSwganN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IHdpdGhpblBvcnRhbDogdHJ1ZSwgbGFiZWw6IGxvY2FsaXphdGlvbi5waW5Ub1JpZ2h0LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCB7IG9uQ2xpY2s6ICgpID0+IGhhbmRsZVBpbkNvbHVtbigncmlnaHQnKSwgc2l6ZTogXCJtZFwiLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvblBpbm5lZCwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSB9KSB9KV0gfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9TaG93SGlkZUNvbHVtbnNNZW51SXRlbXMgPSAoeyBhbGxDb2x1bW5zLCBob3ZlcmVkQ29sdW1uLCBzZXRIb3ZlcmVkQ29sdW1uLCBjb2x1bW4sIGlzU3ViTWVudSwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVDb2x1bW5PcmRlcmluZywgZW5hYmxlSGlkaW5nLCBlbmFibGVQaW5uaW5nLCBsb2NhbGl6YXRpb24sIH0sIHNldENvbHVtbk9yZGVyLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5PcmRlciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmVHlwZSB9ID0gY29sdW1uRGVmO1xuICAgIGNvbnN0IHN3aXRjaENoZWNrZWQgPSAoY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJyAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpIHx8XG4gICAgICAgIChjb2x1bW5EZWZUeXBlID09PSAnZ3JvdXAnICYmXG4gICAgICAgICAgICBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5zb21lKChjb2wpID0+IGNvbC5nZXRJc1Zpc2libGUoKSkpO1xuICAgIGNvbnN0IGhhbmRsZVRvZ2dsZUNvbHVtbkhpZGRlbiA9IChjb2x1bW4pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGNvbHVtbkRlZlR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbi5jb2x1bW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIChjaGlsZENvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1uLnRvZ2dsZVZpc2liaWxpdHkoIXN3aXRjaENoZWNrZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZW51SXRlbVJlZiA9IHJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSByZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGUpID0+IHtcbiAgICAgICAgc2V0SXNEcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKG1lbnVJdGVtUmVmLmN1cnJlbnQsIDAsIDApO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IChfZSkgPT4ge1xuICAgICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgc2V0SG92ZXJlZENvbHVtbihudWxsKTtcbiAgICAgICAgaWYgKGhvdmVyZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHNldENvbHVtbk9yZGVyKHJlb3JkZXJDb2x1bW4oY29sdW1uLCBob3ZlcmVkQ29sdW1uLCBjb2x1bW5PcmRlcikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW50ZXIgPSAoX2UpID0+IHtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nICYmIGNvbHVtbkRlZi5lbmFibGVDb2x1bW5PcmRlcmluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGNvbXBvbmVudDogXCJzcGFuXCIsIHJlZjogbWVudUl0ZW1SZWYsIG9uRHJhZ0VudGVyOiBoYW5kbGVEcmFnRW50ZXIsIHN4OiAodGhlbWUpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogaXNEcmFnZ2luZyA/IDAuNSA6IDEsXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IGlzRHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYDFweCBkYXNoZWQgJHt0aGVtZS5jb2xvcnMuZ3JheVs3XX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChob3ZlcmVkQ29sdW1uID09PSBudWxsIHx8IGhvdmVyZWRDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvdmVyZWRDb2x1bW4uaWQpID09PSBjb2x1bW4uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAycHggZGFzaGVkICR7Z2V0UHJpbWFyeUNvbG9yKHRoZW1lKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBgJHsoY29sdW1uLmRlcHRoICsgMC41KSAqIDJ9cmVtYCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzZweCcsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICc2cHgnLFxuICAgICAgICAgICAgICAgIH0pLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3hzKGNvcmUuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4V3JhcDogJ25vd3JhcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXA6ICc4cHgnLFxuICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWyFpc1N1Yk1lbnUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5EZWZUeXBlICE9PSAnZ3JvdXAnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlQ29sdW1uT3JkZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYWxsQ29sdW1ucy5zb21lKChjb2wpID0+IGNvbC5jb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSA/IChqc3hSdW50aW1lLmpzeChNUlRfR3JhYkhhbmRsZUJ1dHRvbiwgeyBvbkRyYWdFbmQ6IGhhbmRsZURyYWdFbmQsIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsIHRhYmxlOiB0YWJsZSB9KSkgOiAoanN4UnVudGltZS5qc3goY29yZS5Cb3gsIHsgc3g6IHsgd2lkdGg6ICcyMnB4JyB9IH0pKSksICFpc1N1Yk1lbnUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVQaW5uaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbHVtbi5nZXRDYW5QaW4oKSA/IChqc3hSdW50aW1lLmpzeChNUlRfQ29sdW1uUGlubmluZ0J1dHRvbnMsIHsgY29sdW1uOiBjb2x1bW4sIHRhYmxlOiB0YWJsZSB9KSkgOiAoanN4UnVudGltZS5qc3goY29yZS5Cb3gsIHsgc3g6IHsgd2lkdGg6ICc3MHB4JyB9IH0pKSksIGVuYWJsZUhpZGluZyA/IChqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBvcGVuRGVsYXk6IDEwMDAsIGxhYmVsOiBsb2NhbGl6YXRpb24udG9nZ2xlVmlzaWJpbGl0eSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuU3dpdGNoLCB7IGNoZWNrZWQ6IHN3aXRjaENoZWNrZWQsIGRpc2FibGVkOiAoaXNTdWJNZW51ICYmIHN3aXRjaENoZWNrZWQpIHx8ICFjb2x1bW4uZ2V0Q2FuSGlkZSgpLCBsYWJlbDogY29sdW1uRGVmLmhlYWRlciwgb25DaGFuZ2U6ICgpID0+IGhhbmRsZVRvZ2dsZUNvbHVtbkhpZGRlbihjb2x1bW4pLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlciAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSB9KSkgOiAoanN4UnVudGltZS5qc3goY29yZS5UZXh0LCB7IHN4OiB7IGFsaWduU2VsZjogJ2NlbnRlcicgfSwgY2hpbGRyZW46IGNvbHVtbkRlZi5oZWFkZXIgfSkpXSB9KSB9KSwgKF9hID0gY29sdW1uLmNvbHVtbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGMsIGkpID0+IChqc3hSdW50aW1lLmpzeChNUlRfU2hvd0hpZGVDb2x1bW5zTWVudUl0ZW1zLCB7IGFsbENvbHVtbnM6IGFsbENvbHVtbnMsIGNvbHVtbjogYywgaG92ZXJlZENvbHVtbjogaG92ZXJlZENvbHVtbiwgaXNTdWJNZW51OiBpc1N1Yk1lbnUsIHNldEhvdmVyZWRDb2x1bW46IHNldEhvdmVyZWRDb2x1bW4sIHRhYmxlOiB0YWJsZSB9LCBgJHtpfS0ke2MuaWR9YCkpKV0gfSkpO1xufTtcblxuY29uc3QgTVJUX1Nob3dIaWRlQ29sdW1uc01lbnUgPSAoeyBpc1N1Yk1lbnUsIHRhYmxlLCB9KSA9PiB7XG4gICAgY29uc3QgeyBnZXRBbGxDb2x1bW5zLCBnZXRBbGxMZWFmQ29sdW1ucywgZ2V0Q2VudGVyTGVhZkNvbHVtbnMsIGdldElzQWxsQ29sdW1uc1Zpc2libGUsIGdldElzU29tZUNvbHVtbnNQaW5uZWQsIGdldElzU29tZUNvbHVtbnNWaXNpYmxlLCBnZXRMZWZ0TGVhZkNvbHVtbnMsIGdldFJpZ2h0TGVhZkNvbHVtbnMsIGdldFN0YXRlLCB0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSwgb3B0aW9uczogeyBlbmFibGVDb2x1bW5PcmRlcmluZywgZW5hYmxlSGlkaW5nLCBlbmFibGVQaW5uaW5nLCBsb2NhbGl6YXRpb24sIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbk9yZGVyLCBjb2x1bW5QaW5uaW5nIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGhpZGVBbGxDb2x1bW5zID0gKCkgPT4ge1xuICAgICAgICBnZXRBbGxMZWFmQ29sdW1ucygpXG4gICAgICAgICAgICAuZmlsdGVyKChjb2wpID0+IGNvbC5jb2x1bW5EZWYuZW5hYmxlSGlkaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb2wpID0+IGNvbC50b2dnbGVWaXNpYmlsaXR5KGZhbHNlKSk7XG4gICAgfTtcbiAgICBjb25zdCBhbGxDb2x1bW5zID0gcmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBnZXRBbGxDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5PcmRlci5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhY29sdW1ucy5zb21lKChjb2wpID0+IGNvbC5jb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJykpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0TGVmdExlYWZDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShuZXcgU2V0KGNvbHVtbk9yZGVyKSkubWFwKChjb2xJZCkgPT4gZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKS5maW5kKChjb2wpID0+IChjb2wgPT09IG51bGwgfHwgY29sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2wuaWQpID09PSBjb2xJZCkpLFxuICAgICAgICAgICAgICAgIC4uLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSxcbiAgICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH0sIFtcbiAgICAgICAgY29sdW1uT3JkZXIsXG4gICAgICAgIGNvbHVtblBpbm5pbmcsXG4gICAgICAgIGdldEFsbENvbHVtbnMoKSxcbiAgICAgICAgZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKSxcbiAgICAgICAgZ2V0TGVmdExlYWZDb2x1bW5zKCksXG4gICAgICAgIGdldFJpZ2h0TGVhZkNvbHVtbnMoKSxcbiAgICBdKTtcbiAgICBjb25zdCBbaG92ZXJlZENvbHVtbiwgc2V0SG92ZXJlZENvbHVtbl0gPSByZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLk1lbnUuRHJvcGRvd24sIHsgc3g6IHtcbiAgICAgICAgICAgIG1heEhlaWdodDogJ2NhbGMoODB2aCAtIDEwMHB4KScsXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeHMoY29yZS5GbGV4LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBpc1N1Yk1lbnUgPyAnY2VudGVyJyA6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCcsXG4gICAgICAgICAgICAgICAgICAgIGdhcDogJzhweCcsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFshaXNTdWJNZW51ICYmIGVuYWJsZUhpZGluZyAmJiAoanN4UnVudGltZS5qc3goY29yZS5CdXR0b24sIHsgZGlzYWJsZWQ6ICFnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSgpLCBvbkNsaWNrOiBoaWRlQWxsQ29sdW1ucywgdmFyaWFudDogXCJzdWJ0bGVcIiwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5oaWRlQWxsIH0pKSwgIWlzU3ViTWVudSAmJiBlbmFibGVDb2x1bW5PcmRlcmluZyAmJiAoanN4UnVudGltZS5qc3goY29yZS5CdXR0b24sIHsgb25DbGljazogKCkgPT4gdGFibGUuc2V0Q29sdW1uT3JkZXIoZ2V0RGVmYXVsdENvbHVtbk9yZGVySWRzKHRhYmxlLm9wdGlvbnMpKSwgdmFyaWFudDogXCJzdWJ0bGVcIiwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5yZXNldE9yZGVyIH0pKSwgIWlzU3ViTWVudSAmJiBlbmFibGVQaW5uaW5nICYmIChqc3hSdW50aW1lLmpzeChjb3JlLkJ1dHRvbiwgeyBkaXNhYmxlZDogIWdldElzU29tZUNvbHVtbnNQaW5uZWQoKSwgb25DbGljazogKCkgPT4gdGFibGUucmVzZXRDb2x1bW5QaW5uaW5nKHRydWUpLCB2YXJpYW50OiBcInN1YnRsZVwiLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLnVucGluQWxsIH0pKSwgZW5hYmxlSGlkaW5nICYmIChqc3hSdW50aW1lLmpzeChjb3JlLkJ1dHRvbiwgeyBkaXNhYmxlZDogZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpLCBvbkNsaWNrOiAoKSA9PiB0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSh0cnVlKSwgdmFyaWFudDogXCJzdWJ0bGVcIiwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5zaG93QWxsIH0pKV0gfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuRGl2aWRlciwge30pLCBhbGxDb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gKGpzeFJ1bnRpbWUuanN4KE1SVF9TaG93SGlkZUNvbHVtbnNNZW51SXRlbXMsIHsgYWxsQ29sdW1uczogYWxsQ29sdW1ucywgY29sdW1uOiBjb2x1bW4sIGhvdmVyZWRDb2x1bW46IGhvdmVyZWRDb2x1bW4sIGlzU3ViTWVudTogaXNTdWJNZW51LCBzZXRIb3ZlcmVkQ29sdW1uOiBzZXRIb3ZlcmVkQ29sdW1uLCB0YWJsZTogdGFibGUgfSwgYCR7aW5kZXh9LSR7Y29sdW1uLmlkfWApKSldIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9TaG93SGlkZUNvbHVtbnNCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGljb25zOiB7IEljb25Db2x1bW5zIH0sIGxvY2FsaXphdGlvbiwgfSwgfSA9IHRhYmxlO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuTWVudSwgeyBjbG9zZU9uSXRlbUNsaWNrOiBmYWxzZSwgd2l0aGluUG9ydGFsOiB0cnVlLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIGxhYmVsOiAoX2IgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxvY2FsaXphdGlvbi5zaG93SGlkZUNvbHVtbnMsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuVGFyZ2V0LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnNob3dIaWRlQ29sdW1ucywgc2l6ZTogXCJsZ1wiIH0sIHJlc3QsIHsgdGl0bGU6IHVuZGVmaW5lZCwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KEljb25Db2x1bW5zLCB7fSkgfSkpIH0pIH0pLCBqc3hSdW50aW1lLmpzeChNUlRfU2hvd0hpZGVDb2x1bW5zTWVudSwgeyB0YWJsZTogdGFibGUgfSldIH0pKTtcbn07XG5cbmNvbnN0IHNpemVzID0gWyd4cycsICdtZCcsICd4bCddO1xuY29uc3QgTVJUX1RvZ2dsZURlbnNlUGFkZGluZ0J1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGljb25zOiB7IEljb25CYXNlbGluZURlbnNpdHlMYXJnZSwgSWNvbkJhc2VsaW5lRGVuc2l0eU1lZGl1bSwgSWNvbkJhc2VsaW5lRGVuc2l0eVNtYWxsLCB9LCBsb2NhbGl6YXRpb24sIH0sIHNldERlbnNpdHksIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlRGVuc2VQYWRkaW5nID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHNldERlbnNpdHkoKF9hID0gc2l6ZXNbKHNpemVzLmluZGV4T2YoZGVuc2l0eSkgLSAxKSAlIHNpemVzLmxlbmd0aF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd4bCcpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBsYWJlbDogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24udG9nZ2xlRGVuc2l0eSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24udG9nZ2xlRGVuc2l0eSwgb25DbGljazogaGFuZGxlVG9nZ2xlRGVuc2VQYWRkaW5nLCBzaXplOiBcImxnXCIgfSwgcmVzdCwgeyB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogZGVuc2l0eSA9PT0gJ3hzJyA/IChqc3hSdW50aW1lLmpzeChJY29uQmFzZWxpbmVEZW5zaXR5U21hbGwsIHt9KSkgOiBkZW5zaXR5ID09PSAnbWQnID8gKGpzeFJ1bnRpbWUuanN4KEljb25CYXNlbGluZURlbnNpdHlNZWRpdW0sIHt9KSkgOiAoanN4UnVudGltZS5qc3goSWNvbkJhc2VsaW5lRGVuc2l0eUxhcmdlLCB7fSkpIH0pKSB9KSk7XG59O1xuXG5jb25zdCBNUlRfVG9nZ2xlRmlsdGVyc0J1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGljb25zOiB7IEljb25GaWx0ZXIsIEljb25GaWx0ZXJPZmYgfSwgbG9jYWxpemF0aW9uLCB9LCBzZXRTaG93Q29sdW1uRmlsdGVycywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgc2hvd0NvbHVtbkZpbHRlcnMgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlU2hvd0ZpbHRlcnMgPSAoKSA9PiB7XG4gICAgICAgIHNldFNob3dDb2x1bW5GaWx0ZXJzKCFzaG93Q29sdW1uRmlsdGVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIGxhYmVsOiAoX2IgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxvY2FsaXphdGlvbi5zaG93SGlkZUZpbHRlcnMsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnNob3dIaWRlRmlsdGVycywgb25DbGljazogaGFuZGxlVG9nZ2xlU2hvd0ZpbHRlcnMsIHNpemU6IFwibGdcIiB9LCByZXN0LCB7IHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBzaG93Q29sdW1uRmlsdGVycyA/IGpzeFJ1bnRpbWUuanN4KEljb25GaWx0ZXJPZmYsIHt9KSA6IGpzeFJ1bnRpbWUuanN4KEljb25GaWx0ZXIsIHt9KSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1RvZ2dsZUdsb2JhbEZpbHRlckJ1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBpY29uczogeyBJY29uU2VhcmNoLCBJY29uU2VhcmNoT2ZmIH0sIGxvY2FsaXphdGlvbiwgfSwgcmVmczogeyBzZWFyY2hJbnB1dFJlZiB9LCBzZXRTaG93R2xvYmFsRmlsdGVyLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBnbG9iYWxGaWx0ZXIsIHNob3dHbG9iYWxGaWx0ZXIgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlU2VhcmNoID0gKCkgPT4ge1xuICAgICAgICBzZXRTaG93R2xvYmFsRmlsdGVyKCFzaG93R2xvYmFsRmlsdGVyKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHNlYXJjaElucHV0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpOyB9LCAxMDApO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBsYWJlbDogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24uc2hvd0hpZGVTZWFyY2gsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogKF9jID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBsb2NhbGl6YXRpb24uc2hvd0hpZGVTZWFyY2gsIGRpc2FibGVkOiAhIWdsb2JhbEZpbHRlciwgb25DbGljazogaGFuZGxlVG9nZ2xlU2VhcmNoLCBzaXplOiBcImxnXCIgfSwgcmVzdCwgeyB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogc2hvd0dsb2JhbEZpbHRlciA/IGpzeFJ1bnRpbWUuanN4KEljb25TZWFyY2hPZmYsIHt9KSA6IGpzeFJ1bnRpbWUuanN4KEljb25TZWFyY2gsIHt9KSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1Rvb2xiYXJJbnRlcm5hbEJ1dHRvbnMgPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGVuYWJsZUNvbHVtbkZpbHRlcnMsIGVuYWJsZUNvbHVtbk9yZGVyaW5nLCBlbmFibGVEZW5zaXR5VG9nZ2xlLCBlbmFibGVGaWx0ZXJzLCBlbmFibGVGdWxsU2NyZWVuVG9nZ2xlLCBlbmFibGVHbG9iYWxGaWx0ZXIsIGVuYWJsZUhpZGluZywgZW5hYmxlUGlubmluZywgaW5pdGlhbFN0YXRlLCByZW5kZXJUb29sYmFySW50ZXJuYWxBY3Rpb25zLCB9LCB9ID0gdGFibGU7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkZsZXgsIHsgc3g6IHtcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgZ2FwOiAnMnB4JyxcbiAgICAgICAgICAgIHpJbmRleDogMyxcbiAgICAgICAgfSwgY2hpbGRyZW46IChfYSA9IHJlbmRlclRvb2xiYXJJbnRlcm5hbEFjdGlvbnMgPT09IG51bGwgfHwgcmVuZGVyVG9vbGJhckludGVybmFsQWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyVG9vbGJhckludGVybmFsQWN0aW9ucyh7XG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgfSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2VuYWJsZUZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlR2xvYmFsRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICEoaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLnNob3dHbG9iYWxGaWx0ZXIpICYmIChqc3hSdW50aW1lLmpzeChNUlRfVG9nZ2xlR2xvYmFsRmlsdGVyQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KSksIGVuYWJsZUZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlQ29sdW1uRmlsdGVycyAmJlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSAhPT0gJ3BvcG92ZXInICYmIChqc3hSdW50aW1lLmpzeChNUlRfVG9nZ2xlRmlsdGVyc0J1dHRvbiwgeyB0YWJsZTogdGFibGUgfSkpLCAoZW5hYmxlSGlkaW5nIHx8IGVuYWJsZUNvbHVtbk9yZGVyaW5nIHx8IGVuYWJsZVBpbm5pbmcpICYmIChqc3hSdW50aW1lLmpzeChNUlRfU2hvd0hpZGVDb2x1bW5zQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KSksIGVuYWJsZURlbnNpdHlUb2dnbGUgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9Ub2dnbGVEZW5zZVBhZGRpbmdCdXR0b24sIHsgdGFibGU6IHRhYmxlIH0pKSwgZW5hYmxlRnVsbFNjcmVlblRvZ2dsZSAmJiAoanN4UnVudGltZS5qc3goTVJUX1RvZ2dsZUZ1bGxTY3JlZW5CdXR0b24sIHsgdGFibGU6IHRhYmxlIH0pKV0gfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub29sYmFyRHJvcFpvbmUgPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlR3JvdXBpbmcsIGxvY2FsaXphdGlvbiB9LCBzZXRIb3ZlcmVkQ29sdW1uLCBzZXRTaG93VG9vbGJhckRyb3Bab25lLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkcmFnZ2luZ0NvbHVtbiwgaG92ZXJlZENvbHVtbiwgZ3JvdXBpbmcsIHNob3dUb29sYmFyRHJvcFpvbmUgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKF9ldmVudCkgPT4ge1xuICAgICAgICBzZXRIb3ZlcmVkQ29sdW1uKHsgaWQ6ICdkcm9wLXpvbmUnIH0pO1xuICAgIH07XG4gICAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRhYmxlLm9wdGlvbnMuc3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93VG9vbGJhckRyb3Bab25lKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXRTaG93VG9vbGJhckRyb3Bab25lKCEhZW5hYmxlR3JvdXBpbmcgJiZcbiAgICAgICAgICAgICAgICAhIWRyYWdnaW5nQ29sdW1uICYmXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdDb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFncm91cGluZy5pbmNsdWRlcyhkcmFnZ2luZ0NvbHVtbi5pZCkpO1xuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZUdyb3VwaW5nLCBkcmFnZ2luZ0NvbHVtbiwgZ3JvdXBpbmddKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuVHJhbnNpdGlvbiwgeyBtb3VudGVkOiBzaG93VG9vbGJhckRyb3Bab25lLCB0cmFuc2l0aW9uOiBcImZhZGVcIiwgY2hpbGRyZW46IChzdHlsZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuRmxleCwgeyBjbGFzc05hbWU6IFwibWFudGluZS1Ub29sYmFyRHJvcFpvbmVcIiwgc3g6ICh0aGVtZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUuZm4ucmdiYShnZXRQcmltYXJ5Q29sb3IodGhlbWUpLCAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gJ2Ryb3Atem9uZScgPyAwLjIgOiAwLjEpLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGBkYXNoZWQgJHtnZXRQcmltYXJ5Q29sb3IodGhlbWUpfSAycHhgLFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoMTAwJSknLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICdjYWxjKDEwMCUpJyxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyLFxuICAgICAgICAgICAgICAgIH0pLCBvbkRyYWdFbnRlcjogaGFuZGxlRHJhZ0VudGVyLCBzdHlsZTogc3R5bGVzLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5UZXh0LCB7IGNoaWxkcmVuOiBsb2NhbGl6YXRpb24uZHJvcFRvR3JvdXBCeS5yZXBsYWNlKCd7Y29sdW1ufScsIChfYiA9IChfYSA9IGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5jb2x1bW5EZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKSB9KSB9KSk7XG4gICAgICAgIH0gfSkpO1xufTtcblxuY29uc3QgY29tbW9uVG9vbGJhclN0eWxlcyA9ICh7IHRoZW1lIH0pID0+ICh7XG4gICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnLFxuICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUuY29sb3JTY2hlbWUgPT09ICdkYXJrJyA/IHRoZW1lLmNvbG9ycy5kYXJrWzddIDogdGhlbWUud2hpdGUsXG4gICAgYmFja2dyb3VuZEltYWdlOiAnbm9uZScsXG4gICAgZGlzcGxheTogJ2dyaWQnLFxuICAgIGZsZXhXcmFwOiAnd3JhcC1yZXZlcnNlJyxcbiAgICBtaW5IZWlnaHQ6ICczLjVyZW0nLFxuICAgIG92ZXJmbG93OiAndmlzaWJsZScsXG4gICAgcGFkZGluZzogJzAnLFxuICAgIHRyYW5zaXRpb246ICdhbGwgMTAwbXMgZWFzZS1pbi1vdXQnLFxuICAgIHpJbmRleDogMyxcbn0pO1xuY29uc3QgTVJUX1RvcFRvb2xiYXIgPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZUdsb2JhbEZpbHRlciwgZW5hYmxlUGFnaW5hdGlvbiwgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucywgbWFudGluZVRvcFRvb2xiYXJQcm9wcywgcG9zaXRpb25HbG9iYWxGaWx0ZXIsIHBvc2l0aW9uUGFnaW5hdGlvbiwgcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIsIHBvc2l0aW9uVG9vbGJhckRyb3Bab25lLCByZW5kZXJUb3BUb29sYmFyQ3VzdG9tQWN0aW9ucywgfSwgcmVmczogeyB0b3BUb29sYmFyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiwgc2hvd0dsb2JhbEZpbHRlciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc01vYmlsZSA9IGhvb2tzLnVzZU1lZGlhUXVlcnkoJyhtYXgtd2lkdGg6IDcyMHB4KScpO1xuICAgIGNvbnN0IHRvb2xiYXJQcm9wcyA9IG1hbnRpbmVUb3BUb29sYmFyUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUb3BUb29sYmFyUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVUb3BUb29sYmFyUHJvcHM7XG4gICAgY29uc3Qgc3RhY2tBbGVydEJhbm5lciA9IGlzTW9iaWxlIHx8ICEhcmVuZGVyVG9wVG9vbGJhckN1c3RvbUFjdGlvbnMgfHwgc2hvd0dsb2JhbEZpbHRlcjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7fSwgdG9vbGJhclByb3BzLCB7IHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdG9wVG9vbGJhclJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyUHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiBpc0Z1bGxTY3JlZW4gPyAnc3RpY2t5JyA6ICdyZWxhdGl2ZScsIHRvcDogaXNGdWxsU2NyZWVuID8gJzAnIDogdW5kZWZpbmVkIH0sIGNvbW1vblRvb2xiYXJTdHlsZXMoeyB0aGVtZSB9KSksICgodG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHRvb2xiYXJQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgIDogdG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnN4KSkpLCBjaGlsZHJlbjogW3Bvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyID09PSAndG9wJyAmJiAoanN4UnVudGltZS5qc3goTVJUX1Rvb2xiYXJBbGVydEJhbm5lciwgeyBzdGFja0FsZXJ0QmFubmVyOiBzdGFja0FsZXJ0QmFubmVyLCB0YWJsZTogdGFibGUgfSkpLCBbJ2JvdGgnLCAndG9wJ10uaW5jbHVkZXMocG9zaXRpb25Ub29sYmFyRHJvcFpvbmUgIT09IG51bGwgJiYgcG9zaXRpb25Ub29sYmFyRHJvcFpvbmUgIT09IHZvaWQgMCA/IHBvc2l0aW9uVG9vbGJhckRyb3Bab25lIDogJycpICYmIChqc3hSdW50aW1lLmpzeChNUlRfVG9vbGJhckRyb3Bab25lLCB7IHRhYmxlOiB0YWJsZSB9KSksIGpzeFJ1bnRpbWUuanN4cyhjb3JlLkZsZXgsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCcsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFja0FsZXJ0QmFubmVyID8gJ3JlbGF0aXZlJyA6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtlbmFibGVHbG9iYWxGaWx0ZXIgJiYgcG9zaXRpb25HbG9iYWxGaWx0ZXIgPT09ICdsZWZ0JyAmJiAoanN4UnVudGltZS5qc3goTVJUX0dsb2JhbEZpbHRlclRleHRJbnB1dCwgeyB0YWJsZTogdGFibGUgfSkpLCAoX2EgPSByZW5kZXJUb3BUb29sYmFyQ3VzdG9tQWN0aW9ucyA9PT0gbnVsbCB8fCByZW5kZXJUb3BUb29sYmFyQ3VzdG9tQWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyVG9wVG9vbGJhckN1c3RvbUFjdGlvbnMoeyB0YWJsZSB9KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoganN4UnVudGltZS5qc3goXCJzcGFuXCIsIHt9KSwgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucyA/IChqc3hSdW50aW1lLmpzeHMoY29yZS5GbGV4LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleFdyYXA6ICd3cmFwLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtlbmFibGVHbG9iYWxGaWx0ZXIgJiYgcG9zaXRpb25HbG9iYWxGaWx0ZXIgPT09ICdyaWdodCcgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9HbG9iYWxGaWx0ZXJUZXh0SW5wdXQsIHsgdGFibGU6IHRhYmxlIH0pKSwganN4UnVudGltZS5qc3goTVJUX1Rvb2xiYXJJbnRlcm5hbEJ1dHRvbnMsIHsgdGFibGU6IHRhYmxlIH0pXSB9KSkgOiAoZW5hYmxlR2xvYmFsRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkdsb2JhbEZpbHRlciA9PT0gJ3JpZ2h0JyAmJiAoanN4UnVudGltZS5qc3goTVJUX0dsb2JhbEZpbHRlclRleHRJbnB1dCwgeyB0YWJsZTogdGFibGUgfSkpKV0gfSksIGVuYWJsZVBhZ2luYXRpb24gJiZcbiAgICAgICAgICAgICAgICBbJ3RvcCcsICdib3RoJ10uaW5jbHVkZXMocG9zaXRpb25QYWdpbmF0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uUGFnaW5hdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb25QYWdpbmF0aW9uIDogJycpICYmIChqc3hSdW50aW1lLmpzeChjb3JlLkZsZXgsIHsganVzdGlmeTogXCJlbmRcIiwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZVBhZ2luYXRpb24sIHsgdGFibGU6IHRhYmxlLCBwb3NpdGlvbjogXCJ0b3BcIiB9KSB9KSksIGpzeFJ1bnRpbWUuanN4KE1SVF9Qcm9ncmVzc0JhciwgeyBpc1RvcFRvb2xiYXI6IHRydWUsIHRhYmxlOiB0YWJsZSB9KV0gfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9Cb3R0b21Ub29sYmFyID0gKHsgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVBhZ2luYXRpb24sIG1hbnRpbmVCb3R0b21Ub29sYmFyUHJvcHMsIHBvc2l0aW9uUGFnaW5hdGlvbiwgcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIsIHBvc2l0aW9uVG9vbGJhckRyb3Bab25lLCByZW5kZXJCb3R0b21Ub29sYmFyQ3VzdG9tQWN0aW9ucywgfSwgcmVmczogeyBib3R0b21Ub29sYmFyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc01vYmlsZSA9IGhvb2tzLnVzZU1lZGlhUXVlcnkoJyhtYXgtd2lkdGg6IDcyMHB4KScpO1xuICAgIGNvbnN0IHRvb2xiYXJQcm9wcyA9IG1hbnRpbmVCb3R0b21Ub29sYmFyUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVCb3R0b21Ub29sYmFyUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVCb3R0b21Ub29sYmFyUHJvcHM7XG4gICAgY29uc3Qgc3RhY2tBbGVydEJhbm5lciA9IGlzTW9iaWxlIHx8ICEhcmVuZGVyQm90dG9tVG9vbGJhckN1c3RvbUFjdGlvbnM7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoY29yZS5Cb3gsIE9iamVjdC5hc3NpZ24oe30sIHRvb2xiYXJQcm9wcywgeyByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGJvdHRvbVRvb2xiYXJSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xiYXJQcm9wcyA9PT0gbnVsbCB8fCB0b29sYmFyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvb2xiYXJQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhclByb3BzLnJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVG9vbGJhclN0eWxlcyh7IHRoZW1lIH0pKSwgeyBib3R0b206IGlzRnVsbFNjcmVlbiA/ICcwJyA6IHVuZGVmaW5lZCwgYm94U2hhZG93OiBgMCAxcHggMnB4IC0xcHggJHt0aGVtZS5mbi5yZ2JhKHRoZW1lLmJsYWNrLCAwLjEpfSBpbnNldGAsIGxlZnQ6IDAsIHBvc2l0aW9uOiBpc0Z1bGxTY3JlZW4gPyAnZml4ZWQnIDogJ3JlbGF0aXZlJywgcmlnaHQ6IDAgfSksICgodG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHRvb2xiYXJQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgIDogdG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnN4KSkpLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KE1SVF9Qcm9ncmVzc0JhciwgeyBpc1RvcFRvb2xiYXI6IGZhbHNlLCB0YWJsZTogdGFibGUgfSksIHBvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyID09PSAnYm90dG9tJyAmJiAoanN4UnVudGltZS5qc3goTVJUX1Rvb2xiYXJBbGVydEJhbm5lciwgeyBzdGFja0FsZXJ0QmFubmVyOiBzdGFja0FsZXJ0QmFubmVyLCB0YWJsZTogdGFibGUgfSkpLCBbJ2JvdGgnLCAnYm90dG9tJ10uaW5jbHVkZXMocG9zaXRpb25Ub29sYmFyRHJvcFpvbmUgIT09IG51bGwgJiYgcG9zaXRpb25Ub29sYmFyRHJvcFpvbmUgIT09IHZvaWQgMCA/IHBvc2l0aW9uVG9vbGJhckRyb3Bab25lIDogJycpICYmIChqc3hSdW50aW1lLmpzeChNUlRfVG9vbGJhckRyb3Bab25lLCB7IHRhYmxlOiB0YWJsZSB9KSksIGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtyZW5kZXJCb3R0b21Ub29sYmFyQ3VzdG9tQWN0aW9ucyA/IChyZW5kZXJCb3R0b21Ub29sYmFyQ3VzdG9tQWN0aW9ucyh7IHRhYmxlIH0pKSA6IChqc3hSdW50aW1lLmpzeChcInNwYW5cIiwge30pKSwganN4UnVudGltZS5qc3goY29yZS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YWNrQWxlcnRCYW5uZXIgPyAncmVsYXRpdmUnIDogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogZW5hYmxlUGFnaW5hdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnYm90dG9tJywgJ2JvdGgnXS5pbmNsdWRlcyhwb3NpdGlvblBhZ2luYXRpb24gIT09IG51bGwgJiYgcG9zaXRpb25QYWdpbmF0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvblBhZ2luYXRpb24gOiAnJykgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZVBhZ2luYXRpb24sIHsgdGFibGU6IHRhYmxlLCBwb3NpdGlvbjogXCJib3R0b21cIiB9KSkgfSldIH0pXSB9KSkpO1xufTtcblxuY29uc3QgTVJUX0NvbHVtbkFjdGlvbk1lbnUgPSAoeyBoZWFkZXIsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIHRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlLCBzZXRDb2x1bW5PcmRlciwgb3B0aW9uczogeyBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSwgZW5hYmxlQ29sdW1uRmlsdGVycywgZW5hYmxlQ29sdW1uUmVzaXppbmcsIGVuYWJsZUdyb3VwaW5nLCBlbmFibGVIaWRpbmcsIGVuYWJsZVBpbm5pbmcsIGVuYWJsZVNvcnRpbmcsIGVuYWJsZVNvcnRpbmdSZW1vdmFsLCBpY29uczogeyBJY29uQXJyb3dBdXRvZml0Q29udGVudCwgSWNvbkJveE11bHRpcGxlLCBJY29uQ2xlYXJBbGwsIEljb25Db2x1bW5zLCBJY29uRG90c1ZlcnRpY2FsLCBJY29uRXllT2ZmLCBJY29uRmlsdGVyLCBJY29uRmlsdGVyT2ZmLCBJY29uUGlubmVkLCBJY29uUGlubmVkT2ZmLCBJY29uU29ydEFzY2VuZGluZywgSWNvblNvcnREZXNjZW5kaW5nLCB9LCBsb2NhbGl6YXRpb24sIG1hbnRpbmVDb2x1bW5BY3Rpb25zQnV0dG9uUHJvcHMsIHJlbmRlckNvbHVtbkFjdGlvbnNNZW51SXRlbXMsIH0sIHJlZnM6IHsgZmlsdGVySW5wdXRSZWZzIH0sIHNldENvbHVtblNpemluZ0luZm8sIHNldFNob3dDb2x1bW5GaWx0ZXJzLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgY29sdW1uU2l6aW5nLCBjb2x1bW5WaXNpYmlsaXR5IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG1UYWJsZUhlYWRDZWxsQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzID0gbWFudGluZUNvbHVtbkFjdGlvbnNCdXR0b25Qcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUNvbHVtbkFjdGlvbnNCdXR0b25Qcm9wcyh7IGNvbHVtbiwgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzO1xuICAgIGNvbnN0IG1jVGFibGVIZWFkQ2VsbENvbHVtbkFjdGlvbnNCdXR0b25Qcm9wcyA9IGNvbHVtbkRlZi5tYW50aW5lQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBjb2x1bW5EZWYubWFudGluZUNvbHVtbkFjdGlvbnNCdXR0b25Qcm9wcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBjb2x1bW5EZWYubWFudGluZUNvbHVtbkFjdGlvbnNCdXR0b25Qcm9wcztcbiAgICBjb25zdCBhY3Rpb25JY29uUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1UYWJsZUhlYWRDZWxsQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzKSwgbWNUYWJsZUhlYWRDZWxsQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzKTtcbiAgICBjb25zdCBoYW5kbGVDbGVhclNvcnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbHVtbi5jbGVhclNvcnRpbmcoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVNvcnRBc2MgPSAoKSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVNvcnREZXNjID0gKCkgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZyh0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVJlc2V0Q29sdW1uU2l6ZSA9ICgpID0+IHtcbiAgICAgICAgc2V0Q29sdW1uU2l6aW5nSW5mbygob2xkKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGQpLCB7IGlzUmVzaXppbmdDb2x1bW46IGZhbHNlIH0pKSk7XG4gICAgICAgIGNvbHVtbi5yZXNldFNpemUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUhpZGVDb2x1bW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVBpbkNvbHVtbiA9IChwaW5EaXJlY3Rpb24pID0+IHtcbiAgICAgICAgY29sdW1uLnBpbihwaW5EaXJlY3Rpb24pO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlR3JvdXBCeUNvbHVtbiA9ICgpID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nKCk7XG4gICAgICAgIHNldENvbHVtbk9yZGVyKChvbGQpID0+IFsnbXJ0LXJvdy1leHBhbmQnLCAuLi5vbGRdKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNsZWFyRmlsdGVyID0gKCkgPT4ge1xuICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoJycpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRmlsdGVyQnlDb2x1bW4gPSAoKSA9PiB7XG4gICAgICAgIHNldFNob3dDb2x1bW5GaWx0ZXJzKHRydWUpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZmlsdGVySW5wdXRSZWZzLmN1cnJlbnRbYCR7Y29sdW1uLmlkfS0wYF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpOyB9LCAxMDApO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU2hvd0FsbENvbHVtbnMgPSAoKSA9PiB7XG4gICAgICAgIHRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxDb2x1bW5NZW51SXRlbXMgPSAoanN4UnVudGltZS5qc3hzKGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtlbmFibGVTb3J0aW5nICYmIGNvbHVtbi5nZXRDYW5Tb3J0KCkgJiYgKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbZW5hYmxlU29ydGluZ1JlbW92YWwgIT09IGZhbHNlICYmIChqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuSXRlbSwgeyBkaXNhYmxlZDogIWNvbHVtbi5nZXRJc1NvcnRlZCgpLCBpY29uOiBqc3hSdW50aW1lLmpzeChJY29uQ2xlYXJBbGwsIHt9KSwgb25DbGljazogaGFuZGxlQ2xlYXJTb3J0LCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLmNsZWFyU29ydCB9KSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGRpc2FibGVkOiBjb2x1bW4uZ2V0SXNTb3J0ZWQoKSA9PT0gJ2FzYycsIGljb246IGpzeFJ1bnRpbWUuanN4KEljb25Tb3J0QXNjZW5kaW5nLCB7fSksIG9uQ2xpY2s6IGhhbmRsZVNvcnRBc2MsIGNoaWxkcmVuOiAoX2EgPSBsb2NhbGl6YXRpb24uc29ydEJ5Q29sdW1uQXNjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgne2NvbHVtbn0nLCBTdHJpbmcoY29sdW1uRGVmLmhlYWRlcikpIH0pLCBqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuSXRlbSwgeyBpY29uOiBqc3hSdW50aW1lLmpzeChJY29uU29ydERlc2NlbmRpbmcsIHt9KSwgZGlzYWJsZWQ6IGNvbHVtbi5nZXRJc1NvcnRlZCgpID09PSAnZGVzYycsIG9uQ2xpY2s6IGhhbmRsZVNvcnREZXNjLCBjaGlsZHJlbjogKF9iID0gbG9jYWxpemF0aW9uLnNvcnRCeUNvbHVtbkRlc2MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSkgfSksIChlbmFibGVDb2x1bW5GaWx0ZXJzIHx8IGVuYWJsZUdyb3VwaW5nIHx8IGVuYWJsZUhpZGluZykgJiYgKGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5EaXZpZGVyLCB7fSwgMykpXSB9KSksIGVuYWJsZUNvbHVtbkZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSAhPT0gJ3BvcG92ZXInICYmXG4gICAgICAgICAgICAgICAgY29sdW1uLmdldENhbkZpbHRlcigpICYmIChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGRpc2FibGVkOiAhY29sdW1uLmdldEZpbHRlclZhbHVlKCksIGljb246IGpzeFJ1bnRpbWUuanN4KEljb25GaWx0ZXJPZmYsIHt9KSwgb25DbGljazogaGFuZGxlQ2xlYXJGaWx0ZXIsIGNoaWxkcmVuOiBsb2NhbGl6YXRpb24uY2xlYXJGaWx0ZXIgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGljb246IGpzeFJ1bnRpbWUuanN4KEljb25GaWx0ZXIsIHt9KSwgb25DbGljazogaGFuZGxlRmlsdGVyQnlDb2x1bW4sIGNoaWxkcmVuOiAoX2MgPSBsb2NhbGl6YXRpb24uZmlsdGVyQnlDb2x1bW4pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSkgfSksIChlbmFibGVHcm91cGluZyB8fCBlbmFibGVIaWRpbmcpICYmIGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5EaXZpZGVyLCB7fSwgMildIH0pKSwgZW5hYmxlR3JvdXBpbmcgJiYgY29sdW1uLmdldENhbkdyb3VwKCkgJiYgKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgaWNvbjoganN4UnVudGltZS5qc3goSWNvbkJveE11bHRpcGxlLCB7fSksIG9uQ2xpY2s6IGhhbmRsZUdyb3VwQnlDb2x1bW4sIGNoaWxkcmVuOiAoX2QgPSBsb2NhbGl6YXRpb25bY29sdW1uLmdldElzR3JvdXBlZCgpID8gJ3VuZ3JvdXBCeUNvbHVtbicgOiAnZ3JvdXBCeUNvbHVtbiddKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZSgne2NvbHVtbn0nLCBTdHJpbmcoY29sdW1uRGVmLmhlYWRlcikpIH0pLCBlbmFibGVQaW5uaW5nICYmIGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5EaXZpZGVyLCB7fSldIH0pKSwgZW5hYmxlUGlubmluZyAmJiBjb2x1bW4uZ2V0Q2FuUGluKCkgJiYgKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgZGlzYWJsZWQ6IGNvbHVtbi5nZXRJc1Bpbm5lZCgpID09PSAnbGVmdCcgfHwgIWNvbHVtbi5nZXRDYW5QaW4oKSwgaWNvbjoganN4UnVudGltZS5qc3goSWNvblBpbm5lZCwgeyBzdHlsZTogeyB0cmFuc2Zvcm06ICdyb3RhdGUoOTBkZWcpJyB9IH0pLCBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oJ2xlZnQnKSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5waW5Ub0xlZnQgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGRpc2FibGVkOiBjb2x1bW4uZ2V0SXNQaW5uZWQoKSA9PT0gJ3JpZ2h0JyB8fCAhY29sdW1uLmdldENhblBpbigpLCBpY29uOiBqc3hSdW50aW1lLmpzeChJY29uUGlubmVkLCB7IHN0eWxlOiB7IHRyYW5zZm9ybTogJ3JvdGF0ZSgtOTBkZWcpJyB9IH0pLCBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oJ3JpZ2h0JyksIGNoaWxkcmVuOiBsb2NhbGl6YXRpb24ucGluVG9SaWdodCB9KSwganN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgZGlzYWJsZWQ6ICFjb2x1bW4uZ2V0SXNQaW5uZWQoKSwgaWNvbjoganN4UnVudGltZS5qc3goSWNvblBpbm5lZE9mZiwge30pLCBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oZmFsc2UpLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLnVucGluIH0pLCBlbmFibGVIaWRpbmcgJiYganN4UnVudGltZS5qc3goY29yZS5NZW51LkRpdmlkZXIsIHt9KV0gfSkpLCBlbmFibGVDb2x1bW5SZXNpemluZyAmJiBjb2x1bW4uZ2V0Q2FuUmVzaXplKCkgJiYgKGpzeFJ1bnRpbWUuanN4KGNvcmUuTWVudS5JdGVtLCB7IGRpc2FibGVkOiAhY29sdW1uU2l6aW5nW2NvbHVtbi5pZF0sIGljb246IGpzeFJ1bnRpbWUuanN4KEljb25BcnJvd0F1dG9maXRDb250ZW50LCB7fSksIG9uQ2xpY2s6IGhhbmRsZVJlc2V0Q29sdW1uU2l6ZSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5yZXNldENvbHVtblNpemUgfSwgMCkpLCBlbmFibGVIaWRpbmcgJiYgKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgZGlzYWJsZWQ6ICFjb2x1bW4uZ2V0Q2FuSGlkZSgpLCBpY29uOiBqc3hSdW50aW1lLmpzeChJY29uRXllT2ZmLCB7fSksIG9uQ2xpY2s6IGhhbmRsZUhpZGVDb2x1bW4sIGNoaWxkcmVuOiAoX2UgPSBsb2NhbGl6YXRpb24uaGlkZUNvbHVtbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKSB9LCAwKSwganN4UnVudGltZS5qc3goY29yZS5NZW51Lkl0ZW0sIHsgZGlzYWJsZWQ6ICFPYmplY3QudmFsdWVzKGNvbHVtblZpc2liaWxpdHkpLmZpbHRlcigodmlzaWJsZSkgPT4gIXZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCwgaWNvbjoganN4UnVudGltZS5qc3goSWNvbkNvbHVtbnMsIHt9KSwgb25DbGljazogaGFuZGxlU2hvd0FsbENvbHVtbnMsIGNoaWxkcmVuOiAoX2YgPSBsb2NhbGl6YXRpb24uc2hvd0FsbENvbHVtbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSkgfSwgMSldIH0pKV0gfSkpO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuTWVudSwgeyBjbG9zZU9uSXRlbUNsaWNrOiB0cnVlLCB3aXRoaW5Qb3J0YWw6IHRydWUsIHBvc2l0aW9uOiBcImJvdHRvbS1zdGFydFwiLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuVG9vbHRpcCwgeyB3aXRoaW5Qb3J0YWw6IHRydWUsIG9wZW5EZWxheTogMTAwMCwgbGFiZWw6IChfZyA9IGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogbG9jYWxpemF0aW9uLmNvbHVtbkFjdGlvbnMsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLk1lbnUuVGFyZ2V0LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkFjdGlvbkljb24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmNvbHVtbkFjdGlvbnMsIHNpemU6IFwic21cIiB9LCBhY3Rpb25JY29uUHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBvcGFjaXR5OiAwLjUsIHRyYW5zaXRpb246ICdvcGFjaXR5IDEwMG1zJywgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCAoKGFjdGlvbkljb25Qcm9wcyA9PT0gbnVsbCB8fCBhY3Rpb25JY29uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkljb25Qcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWN0aW9uSWNvblByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLnN4KSkpLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvbkRvdHNWZXJ0aWNhbCwge30pIH0pKSB9KSB9KSwganN4UnVudGltZS5qc3goY29yZS5NZW51LkRyb3Bkb3duLCB7IGNoaWxkcmVuOiAoX2sgPSAoX2ogPSAoX2ggPSBjb2x1bW5EZWYucmVuZGVyQ29sdW1uQWN0aW9uc01lbnVJdGVtcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoY29sdW1uRGVmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsQ29sdW1uTWVudUl0ZW1zLFxuICAgICAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiByZW5kZXJDb2x1bW5BY3Rpb25zTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlckNvbHVtbkFjdGlvbnNNZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckNvbHVtbkFjdGlvbnNNZW51SXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENvbHVtbk1lbnVJdGVtcyxcbiAgICAgICAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogaW50ZXJuYWxDb2x1bW5NZW51SXRlbXMgfSldIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9GaWx0ZXJSYW5nZVNsaWRlciA9ICh7IGhlYWRlciwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IG1hbnRpbmVGaWx0ZXJSYW5nZVNsaWRlclByb3BzIH0sIHJlZnM6IHsgZmlsdGVySW5wdXRSZWZzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbiB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgbUZpbHRlclJhbmdlU2xpZGVyUHJvcHMgPSBtYW50aW5lRmlsdGVyUmFuZ2VTbGlkZXJQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUZpbHRlclJhbmdlU2xpZGVyUHJvcHMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pXG4gICAgICAgIDogbWFudGluZUZpbHRlclJhbmdlU2xpZGVyUHJvcHM7XG4gICAgY29uc3QgbWNGaWx0ZXJSYW5nZVNsaWRlclByb3BzID0gY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJSYW5nZVNsaWRlclByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBjb2x1bW5EZWYubWFudGluZUZpbHRlclJhbmdlU2xpZGVyUHJvcHMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pXG4gICAgICAgIDogY29sdW1uRGVmLm1hbnRpbmVGaWx0ZXJSYW5nZVNsaWRlclByb3BzO1xuICAgIGNvbnN0IHJhbmdlU2xpZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1GaWx0ZXJSYW5nZVNsaWRlclByb3BzKSwgbWNGaWx0ZXJSYW5nZVNsaWRlclByb3BzKTtcbiAgICBsZXQgW21pbiwgbWF4XSA9IHJhbmdlU2xpZGVyUHJvcHMubWluICE9PSB1bmRlZmluZWQgJiYgcmFuZ2VTbGlkZXJQcm9wcy5tYXggIT09IHVuZGVmaW5lZFxuICAgICAgICA/IFtyYW5nZVNsaWRlclByb3BzLm1pbiwgcmFuZ2VTbGlkZXJQcm9wcy5tYXhdXG4gICAgICAgIDogKF9hID0gY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogWzAsIDFdO1xuICAgIC8vZml4IHBvdGVudGlhbCBUYW5TdGFjayBUYWJsZSBidWdzIHdoZXJlIG1pbiBvciBtYXggaXMgYW4gYXJyYXlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtaW4pKVxuICAgICAgICBtaW4gPSBtaW5bMF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF4KSlcbiAgICAgICAgbWF4ID0gbWF4WzBdO1xuICAgIGlmIChtaW4gPT09IG51bGwpXG4gICAgICAgIG1pbiA9IDA7XG4gICAgaWYgKG1heCA9PT0gbnVsbClcbiAgICAgICAgbWF4ID0gMTtcbiAgICBjb25zdCBbZmlsdGVyVmFsdWVzLCBzZXRGaWx0ZXJWYWx1ZXNdID0gcmVhY3QudXNlU3RhdGUoW1xuICAgICAgICBtaW4sXG4gICAgICAgIG1heCxcbiAgICBdKTtcbiAgICBjb25zdCBjb2x1bW5GaWx0ZXJWYWx1ZSA9IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uRmlsdGVyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldEZpbHRlclZhbHVlcyhbbWluLCBtYXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uRmlsdGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWVzKGNvbHVtbkZpbHRlclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfSwgW2NvbHVtbkZpbHRlclZhbHVlLCBtaW4sIG1heF0pO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goY29yZS5SYW5nZVNsaWRlciwgT2JqZWN0LmFzc2lnbih7IG1pbjogbWluLCBtYXg6IG1heCwgb25DaGFuZ2U6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgIHNldEZpbHRlclZhbHVlcyh2YWx1ZXMpO1xuICAgICAgICB9LCBvbkNoYW5nZUVuZDogKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbMF0gPD0gbWluICYmIHZhbHVlc1sxXSA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlIGVudGlyZSByYW5nZSwgcmVtb3ZlIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUodmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZhbHVlOiBmaWx0ZXJWYWx1ZXMgfSwgcmFuZ2VTbGlkZXJQcm9wcywgeyByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZpbHRlcklucHV0UmVmcy5jdXJyZW50W2Ake2NvbHVtbi5pZH0tMGBdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlU2xpZGVyUHJvcHMgPT09IG51bGwgfHwgcmFuZ2VTbGlkZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2VTbGlkZXJQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlU2xpZGVyUHJvcHMucmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgbWFyZ2luOiAnYXV0bycsIG1hcmdpblRvcDogJzE2cHgnLCBtYXJnaW5Cb3R0b206ICc2cHgnLCB3aWR0aDogJ2NhbGMoMTAwJSAtIDhweCknIH0sICgocmFuZ2VTbGlkZXJQcm9wcyA9PT0gbnVsbCB8fCByYW5nZVNsaWRlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZVNsaWRlclByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHJhbmdlU2xpZGVyUHJvcHMuc3godGhlbWUpXG4gICAgICAgICAgICA6IHJhbmdlU2xpZGVyUHJvcHMgPT09IG51bGwgfHwgcmFuZ2VTbGlkZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2VTbGlkZXJQcm9wcy5zeCkpKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlSGVhZENlbGxGaWx0ZXJDb250YWluZXIgPSAoeyBoZWFkZXIsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSwgZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMsIGNvbHVtbkZpbHRlck1vZGVPcHRpb25zLCBpY29uczogeyBJY29uRmlsdGVyQ29nIH0sIGxvY2FsaXphdGlvbiwgfSwgcmVmczogeyBmaWx0ZXJJbnB1dFJlZnMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgc2hvd0NvbHVtbkZpbHRlcnMgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJPcHRpb24gPSBjb2x1bW5EZWYuX2ZpbHRlckZuO1xuICAgIGNvbnN0IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmNvbHVtbkZpbHRlck1vZGVPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2x1bW5GaWx0ZXJNb2RlT3B0aW9ucztcbiAgICBjb25zdCBzaG93Q2hhbmdlTW9kZUJ1dHRvbiA9IGVuYWJsZUNvbHVtbkZpbHRlck1vZGVzICYmXG4gICAgICAgIGNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXJNb2RlcyAhPT0gZmFsc2UgJiZcbiAgICAgICAgKGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICEhKGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSBudWxsIHx8IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucy5sZW5ndGgpKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuQ29sbGFwc2UsIHsgaW46IHNob3dDb2x1bW5GaWx0ZXJzIHx8IGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID09PSAncG9wb3ZlcicsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeHMoY29yZS5GbGV4LCB7IGRpcmVjdGlvbjogXCJjb2x1bW5cIiwgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeHMoY29yZS5GbGV4LCB7IGFsaWduOiBcImZsZXgtZW5kXCIsIGNoaWxkcmVuOiBbY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdjaGVja2JveCcgPyAoanN4UnVudGltZS5qc3goTVJUX0ZpbHRlckNoZWNrYm94LCB7IGNvbHVtbjogY29sdW1uLCB0YWJsZTogdGFibGUgfSkpIDogY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdyYW5nZS1zbGlkZXInID8gKGpzeFJ1bnRpbWUuanN4KE1SVF9GaWx0ZXJSYW5nZVNsaWRlciwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlIH0pKSA6IFsncmFuZ2UnLCAnZGF0ZS1yYW5nZSddLmluY2x1ZGVzKChfYiA9IGNvbHVtbkRlZi5maWx0ZXJWYXJpYW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2JldHdlZW4nLCAnYmV0d2VlbkluY2x1c2l2ZScsICdpbk51bWJlclJhbmdlJ10uaW5jbHVkZXMoY29sdW1uRGVmLl9maWx0ZXJGbikgPyAoanN4UnVudGltZS5qc3goTVJUX0ZpbHRlclJhbmdlRmllbGRzLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSkpIDogKGpzeFJ1bnRpbWUuanN4KE1SVF9GaWx0ZXJUZXh0SW5wdXQsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSksIHNob3dDaGFuZ2VNb2RlQnV0dG9uICYmIChqc3hSdW50aW1lLmpzeHMoY29yZS5NZW51LCB7IHdpdGhpblBvcnRhbDogY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgIT09ICdwb3BvdmVyJywgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgbGFiZWw6IGxvY2FsaXphdGlvbi5jaGFuZ2VGaWx0ZXJNb2RlLCBwb3NpdGlvbjogXCJib3R0b20tc3RhcnRcIiwgd2l0aGluUG9ydGFsOiB0cnVlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5NZW51LlRhcmdldCwgeyBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uY2hhbmdlRmlsdGVyTW9kZSwgc2l6ZTogXCJtZFwiLCBzeDogeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycHgpJyB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvbkZpbHRlckNvZywge30pIH0pIH0pIH0pLCBqc3hSdW50aW1lLmpzeChNUlRfRmlsdGVyT3B0aW9uTWVudSwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlLCBvblNlbGVjdDogKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGZpbHRlcklucHV0UmVmcy5jdXJyZW50W2Ake2NvbHVtbi5pZH0tMGBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTsgfSwgMTAwKSB9KV0gfSkpXSB9KSwgc2hvd0NoYW5nZU1vZGVCdXR0b24gPyAoanN4UnVudGltZS5qc3goY29yZS5UZXh0LCB7IGNvbXBvbmVudDogXCJsYWJlbFwiLCBjb2xvcjogXCJkaW1tZWRcIiwgc3g6IHsgd2hpdGVTcGFjZTogJ25vd3JhcCcsIG1hcmdpblRvcDogJzRweCcsIGZvbnRTaXplOiAnMTBweCcgfSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5maWx0ZXJNb2RlLnJlcGxhY2UoJ3tmaWx0ZXJUeXBlfScsIFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsaXphdGlvbltgZmlsdGVyJHsoKF9jID0gY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLmNoYXJBdCgwKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvVXBwZXJDYXNlKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50RmlsdGVyT3B0aW9uID09PSBudWxsIHx8IGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJPcHRpb24uc2xpY2UoMSkpfWBdKSB9KSkgOiBudWxsXSB9KSB9KSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVIZWFkQ2VsbEZpbHRlckxhYmVsID0gKHsgaGVhZGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGljb25zOiB7IEljb25GaWx0ZXIgfSwgbG9jYWxpemF0aW9uLCB9LCByZWZzOiB7IGZpbHRlcklucHV0UmVmcyB9LCBzZXRTaG93Q29sdW1uRmlsdGVycywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB0aGVtZSA9IGNvcmUudXNlTWFudGluZVRoZW1lKCk7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKTtcbiAgICBjb25zdCBbcG9wb3Zlck9wZW5lZCwgc2V0UG9wb3Zlck9wZW5lZF0gPSByZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaXNGaWx0ZXJBY3RpdmUgPSAoQXJyYXkuaXNBcnJheShmaWx0ZXJWYWx1ZSkgJiYgZmlsdGVyVmFsdWUuc29tZShCb29sZWFuKSkgfHxcbiAgICAgICAgKCEhZmlsdGVyVmFsdWUgJiYgIUFycmF5LmlzQXJyYXkoZmlsdGVyVmFsdWUpKTtcbiAgICBjb25zdCBpc1JhbmdlRmlsdGVyID0gY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdyYW5nZScgfHxcbiAgICAgICAgWydiZXR3ZWVuJywgJ2JldHdlZW5JbmNsdXNpdmUnLCAnaW5OdW1iZXJSYW5nZSddLmluY2x1ZGVzKGNvbHVtbkRlZi5fZmlsdGVyRm4pO1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJPcHRpb24gPSBjb2x1bW5EZWYuX2ZpbHRlckZuO1xuICAgIGNvbnN0IGZpbHRlclRvb2x0aXAgPSBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSA9PT0gJ3BvcG92ZXInICYmICFpc0ZpbHRlckFjdGl2ZVxuICAgICAgICA/IChfYSA9IGxvY2FsaXphdGlvbi5maWx0ZXJCeUNvbHVtbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKVxuICAgICAgICA6IGxvY2FsaXphdGlvbi5maWx0ZXJpbmdCeUNvbHVtblxuICAgICAgICAgICAgLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3tmaWx0ZXJUeXBlfScsIFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxvY2FsaXphdGlvbltgZmlsdGVyJHsoKF9iID0gY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLmNoYXJBdCgwKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvVXBwZXJDYXNlKCkpICtcbiAgICAgICAgICAgIChjdXJyZW50RmlsdGVyT3B0aW9uID09PSBudWxsIHx8IGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJPcHRpb24uc2xpY2UoMSkpfWBdKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3tmaWx0ZXJWYWx1ZX0nLCBgXCIke0FycmF5LmlzQXJyYXkoY29sdW1uLmdldEZpbHRlclZhbHVlKCkpXG4gICAgICAgICAgICA/IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpLmpvaW4oYFwiICR7aXNSYW5nZUZpbHRlciA/IGxvY2FsaXphdGlvbi5hbmQgOiBsb2NhbGl6YXRpb24ub3J9IFwiYClcbiAgICAgICAgICAgIDogY29sdW1uLmdldEZpbHRlclZhbHVlKCl9XCJgKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ1wiIFwiJywgJycpO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuUG9wb3ZlciwgeyBvbkNsb3NlOiAoKSA9PiBzZXRQb3BvdmVyT3BlbmVkKGZhbHNlKSwgb3BlbmVkOiBwb3BvdmVyT3BlbmVkLCBwb3NpdGlvbjogXCJ0b3BcIiwga2VlcE1vdW50ZWQ6IGNvbHVtbkRlZi5maWx0ZXJWYXJpYW50ID09PSAncmFuZ2Utc2xpZGVyJywgc2hhZG93OiBcInhsXCIsIHdpZHRoOiAzNjAsIHdpdGhpblBvcnRhbDogdHJ1ZSwgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeChjb3JlLlRyYW5zaXRpb24sIHsgdHJhbnNpdGlvbjogXCJzY2FsZVwiLCBtb3VudGVkOiBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSA9PT0gJ3BvcG92ZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICghIWNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpICYmICFpc1JhbmdlRmlsdGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNSYW5nZUZpbHRlciAmJiAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAoISEoKF9jID0gY29sdW1uLmdldEZpbHRlclZhbHVlKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1swXSkgfHwgISEoKF9kID0gY29sdW1uLmdldEZpbHRlclZhbHVlKCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFsxXSkpKSwgY2hpbGRyZW46IChzdHlsZXMpID0+IChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgeyBjb21wb25lbnQ6IFwic3BhblwiLCBzeDogeyBmbGV4OiAnMCAwJyB9LCBzdHlsZTogc3R5bGVzLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5Qb3BvdmVyLlRhcmdldCwgeyBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5Ub29sdGlwLCB7IGRpc2FibGVkOiBwb3BvdmVyT3BlbmVkLCBsYWJlbDogZmlsdGVyVG9vbHRpcCwgbXVsdGlsaW5lOiB0cnVlLCB3aWR0aDogZmlsdGVyVG9vbHRpcC5sZW5ndGggPiA0MCA/IDMwMCA6IHVuZGVmaW5lZCwgd2l0aGluUG9ydGFsOiB0cnVlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goY29yZS5BY3Rpb25JY29uLCB7IGNvbG9yOiBpc0ZpbHRlckFjdGl2ZSA/IGdldFByaW1hcnlDb2xvcih0aGVtZSkgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBvcG92ZXJPcGVuZWQoKG9wZW5lZCkgPT4gIW9wZW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTaG93Q29sdW1uRmlsdGVycyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gZmlsdGVySW5wdXRSZWZzLmN1cnJlbnRbYCR7Y29sdW1uLmlkfS0wYF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGZpbHRlcklucHV0UmVmcy5jdXJyZW50W2Ake2NvbHVtbi5pZH0tMGBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaXplOiBcInNtXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0ZpbHRlckFjdGl2ZSA/IDEgOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goSWNvbkZpbHRlciwge30pIH0pIH0pIH0pIH0pKSB9KSwgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgPT09ICdwb3BvdmVyJyAmJiAoanN4UnVudGltZS5qc3goY29yZS5Qb3BvdmVyLkRyb3Bkb3duLCB7IG9uQ2xpY2s6IChldmVudCkgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIG9uS2V5RG93bjogKGV2ZW50KSA9PiBldmVudC5rZXkgPT09ICdFbnRlcicgJiYgc2V0UG9wb3Zlck9wZW5lZChmYWxzZSksIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChNUlRfVGFibGVIZWFkQ2VsbEZpbHRlckNvbnRhaW5lciwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlIH0pIH0pKV0gfSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlSGVhZENlbGxHcmFiSGFuZGxlID0gKHsgY29sdW1uLCB0YWJsZSwgdGFibGVIZWFkQ2VsbFJlZiwgfSkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlQ29sdW1uT3JkZXJpbmcsIG1hbnRpbmVDb2x1bW5EcmFnSGFuZGxlUHJvcHMgfSwgc2V0Q29sdW1uT3JkZXIsIHNldERyYWdnaW5nQ29sdW1uLCBzZXRIb3ZlcmVkQ29sdW1uLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGhvdmVyZWRDb2x1bW4sIGRyYWdnaW5nQ29sdW1uLCBjb2x1bW5PcmRlciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBtQWN0aW9uSWNvblByb3BzID0gbWFudGluZUNvbHVtbkRyYWdIYW5kbGVQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZUNvbHVtbkRyYWdIYW5kbGVQcm9wcyh7IGNvbHVtbiwgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lQ29sdW1uRHJhZ0hhbmRsZVByb3BzO1xuICAgIGNvbnN0IG1jQWN0aW9uSWNvblByb3BzID0gY29sdW1uRGVmLm1hbnRpbmVDb2x1bW5EcmFnSGFuZGxlUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtbkRlZi5tYW50aW5lQ29sdW1uRHJhZ0hhbmRsZVByb3BzKHsgY29sdW1uLCB0YWJsZSB9KVxuICAgICAgICA6IGNvbHVtbkRlZi5tYW50aW5lQ29sdW1uRHJhZ0hhbmRsZVByb3BzO1xuICAgIGNvbnN0IGFjdGlvbkljb25Qcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbUFjdGlvbkljb25Qcm9wcyksIG1jQWN0aW9uSWNvblByb3BzKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBhY3Rpb25JY29uUHJvcHMgPT09IG51bGwgfHwgYWN0aW9uSWNvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25JY29uUHJvcHMub25EcmFnU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbkljb25Qcm9wcywgZXZlbnQpO1xuICAgICAgICBzZXREcmFnZ2luZ0NvbHVtbihjb2x1bW4pO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKHRhYmxlSGVhZENlbGxSZWYuY3VycmVudCwgMCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gYWN0aW9uSWNvblByb3BzID09PSBudWxsIHx8IGFjdGlvbkljb25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uSWNvblByb3BzLm9uRHJhZ0VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9uSWNvblByb3BzLCBldmVudCk7XG4gICAgICAgIGlmICgoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gJ2Ryb3Atem9uZScpIHtcbiAgICAgICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuYWJsZUNvbHVtbk9yZGVyaW5nICYmXG4gICAgICAgICAgICBob3ZlcmVkQ29sdW1uICYmXG4gICAgICAgICAgICAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSAhPT0gKGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZCkpIHtcbiAgICAgICAgICAgIHNldENvbHVtbk9yZGVyKHJlb3JkZXJDb2x1bW4oY29sdW1uLCBob3ZlcmVkQ29sdW1uLCBjb2x1bW5PcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHNldERyYWdnaW5nQ29sdW1uKG51bGwpO1xuICAgICAgICBzZXRIb3ZlcmVkQ29sdW1uKG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChNUlRfR3JhYkhhbmRsZUJ1dHRvbiwgeyBhY3Rpb25JY29uUHJvcHM6IGFjdGlvbkljb25Qcm9wcywgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCwgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCB0YWJsZTogdGFibGUgfSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlSGVhZENlbGxSZXNpemVIYW5kbGUgPSAoeyBoZWFkZXIsIHRhYmxlLCB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uUmVzaXplTW9kZSB9LCBzZXRDb2x1bW5TaXppbmdJbmZvLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgeyBvbkRvdWJsZUNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRDb2x1bW5TaXppbmdJbmZvKChvbGQpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZCksIHsgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UgfSkpKTtcbiAgICAgICAgICAgIGNvbHVtbi5yZXNldFNpemUoKTtcbiAgICAgICAgfSwgb25Nb3VzZURvd246IGhlYWRlci5nZXRSZXNpemVIYW5kbGVyKCksIG9uVG91Y2hTdGFydDogaGVhZGVyLmdldFJlc2l6ZUhhbmRsZXIoKSwgc3g6ICh0aGVtZSkgPT4gKHtcbiAgICAgICAgICAgIGN1cnNvcjogJ2NvbC1yZXNpemUnLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IGRlbnNpdHkgPT09ICd4bCcgPyAnLTI0cHgnIDogZGVuc2l0eSA9PT0gJ21kJyA/ICctMjBweCcgOiAnLTE0cHgnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICByaWdodDogJzRweCcsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogJzFweCcsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgJyY6YWN0aXZlID4gLm1hbnRpbmUtRGl2aWRlci12ZXJ0aWNhbCc6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IGdldFByaW1hcnlDb2xvcih0aGVtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSwgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogY29sdW1uLmdldElzUmVzaXppbmcoKSAmJiBjb2x1bW5SZXNpemVNb2RlID09PSAnb25FbmQnXG4gICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlWCgkeyhfYSA9IGdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5kZWx0YU9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMH1weClgXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkRpdmlkZXIsIHsgb3JpZW50YXRpb246IFwidmVydGljYWxcIiwgc2l6ZTogXCJsZ1wiLCBzeDoge1xuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6ICc0cHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzI0cHgnLFxuICAgICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogY29sdW1uLmdldElzUmVzaXppbmcoKVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6ICdhbGwgMTAwbXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsU29ydExhYmVsID0gKHsgaGVhZGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgSWNvblNvcnREZXNjZW5kaW5nLCBJY29uU29ydEFzY2VuZGluZywgSWNvbkFycm93c1NvcnQgfSwgbG9jYWxpemF0aW9uLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgc29ydGluZyB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvcmUudXNlTWFudGluZVRoZW1lKCk7XG4gICAgY29uc3Qgc29ydFRvb2x0aXAgPSBjb2x1bW4uZ2V0SXNTb3J0ZWQoKVxuICAgICAgICA/IGNvbHVtbi5nZXRJc1NvcnRlZCgpID09PSAnZGVzYydcbiAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLnNvcnRlZEJ5Q29sdW1uRGVzYy5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbkRlZi5oZWFkZXIpXG4gICAgICAgICAgICA6IGxvY2FsaXphdGlvbi5zb3J0ZWRCeUNvbHVtbkFzYy5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbkRlZi5oZWFkZXIpXG4gICAgICAgIDogY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIoKSA9PT0gJ2Rlc2MnXG4gICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5zb3J0QnlDb2x1bW5EZXNjLnJlcGxhY2UoJ3tjb2x1bW59JywgY29sdW1uRGVmLmhlYWRlcilcbiAgICAgICAgICAgIDogbG9jYWxpemF0aW9uLnNvcnRCeUNvbHVtbkFzYy5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbkRlZi5oZWFkZXIpO1xuICAgIGNvbnN0IHNob3dJbmRpY2F0b3IgPSBzb3J0aW5nLmxlbmd0aCA+PSAyICYmIGNvbHVtbi5nZXRTb3J0SW5kZXgoKSAhPT0gLTE7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLlRvb2x0aXAsIHsgd2l0aGluUG9ydGFsOiB0cnVlLCBsYWJlbDogc29ydFRvb2x0aXAsIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChjb3JlLkluZGljYXRvciwgeyBjb2xvcjogXCJ0cmFuc3BhcmVudFwiLCBkaXNhYmxlZDogIXNob3dJbmRpY2F0b3IsIGlubGluZTogdHJ1ZSwgbGFiZWw6IGNvbHVtbi5nZXRTb3J0SW5kZXgoKSArIDEsIG9mZnNldDogMywgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuQWN0aW9uSWNvbiwgeyBcImFyaWEtbGFiZWxcIjogc29ydFRvb2x0aXAsIGNvbG9yOiBjb2x1bW4uZ2V0SXNTb3J0ZWQoKSA/IGdldFByaW1hcnlDb2xvcih0aGVtZSkgOiB1bmRlZmluZWQsIHNpemU6IFwieHNcIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogY29sdW1uLmdldElzU29ydGVkKCkgPyAxIDogMC41LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNob3dJbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RyYW5zbGF0ZSgtMnB4LCAycHgpIHNjYWxlKDAuOSknXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMTAwbXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGNvbHVtbi5nZXRJc1NvcnRlZCgpID09PSAnZGVzYycgPyAoanN4UnVudGltZS5qc3goSWNvblNvcnREZXNjZW5kaW5nLCB7fSkpIDogY29sdW1uLmdldElzU29ydGVkKCkgPT09ICdhc2MnID8gKGpzeFJ1bnRpbWUuanN4KEljb25Tb3J0QXNjZW5kaW5nLCB7fSkpIDogKGpzeFJ1bnRpbWUuanN4KEljb25BcnJvd3NTb3J0LCB7fSkpIH0pIH0pIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsID0gKHsgaGVhZGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB0aGVtZSA9IGNvcmUudXNlTWFudGluZVRoZW1lKCk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSwgZW5hYmxlQ29sdW1uQWN0aW9ucywgZW5hYmxlQ29sdW1uRHJhZ2dpbmcsIGVuYWJsZUNvbHVtbk9yZGVyaW5nLCBlbmFibGVHcm91cGluZywgZW5hYmxlTXVsdGlTb3J0LCBsYXlvdXRNb2RlLCBtYW50aW5lVGFibGVIZWFkQ2VsbFByb3BzLCB9LCByZWZzOiB7IHRhYmxlSGVhZENlbGxSZWZzIH0sIHNldEhvdmVyZWRDb2x1bW4sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHksIGRyYWdnaW5nQ29sdW1uLCBncm91cGluZywgaG92ZXJlZENvbHVtbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IGNvbHVtbiB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgeyBjb2x1bW5EZWZUeXBlIH0gPSBjb2x1bW5EZWY7XG4gICAgY29uc3QgbVRhYmxlSGVhZENlbGxQcm9wcyA9IG1hbnRpbmVUYWJsZUhlYWRDZWxsUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUYWJsZUhlYWRDZWxsUHJvcHMoeyBjb2x1bW4sIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVRhYmxlSGVhZENlbGxQcm9wcztcbiAgICBjb25zdCBtY1RhYmxlSGVhZENlbGxQcm9wcyA9IGNvbHVtbkRlZi5tYW50aW5lVGFibGVIZWFkQ2VsbFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBjb2x1bW5EZWYubWFudGluZVRhYmxlSGVhZENlbGxQcm9wcyh7IGNvbHVtbiwgdGFibGUgfSlcbiAgICAgICAgOiBjb2x1bW5EZWYubWFudGluZVRhYmxlSGVhZENlbGxQcm9wcztcbiAgICBjb25zdCB0YWJsZUNlbGxQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbVRhYmxlSGVhZENlbGxQcm9wcyksIG1jVGFibGVIZWFkQ2VsbFByb3BzKTtcbiAgICBjb25zdCBzaG93Q29sdW1uQWN0aW9ucyA9IChlbmFibGVDb2x1bW5BY3Rpb25zIHx8IGNvbHVtbkRlZi5lbmFibGVDb2x1bW5BY3Rpb25zKSAmJlxuICAgICAgICBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uQWN0aW9ucyAhPT0gZmFsc2U7XG4gICAgY29uc3Qgc2hvd0RyYWdIYW5kbGUgPSBlbmFibGVDb2x1bW5EcmFnZ2luZyAhPT0gZmFsc2UgJiZcbiAgICAgICAgY29sdW1uRGVmLmVuYWJsZUNvbHVtbkRyYWdnaW5nICE9PSBmYWxzZSAmJlxuICAgICAgICAoZW5hYmxlQ29sdW1uRHJhZ2dpbmcgfHxcbiAgICAgICAgICAgIChlbmFibGVDb2x1bW5PcmRlcmluZyAmJiBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uT3JkZXJpbmcgIT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgKGVuYWJsZUdyb3VwaW5nICYmXG4gICAgICAgICAgICAgICAgY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFncm91cGluZy5pbmNsdWRlcyhjb2x1bW4uaWQpKSk7XG4gICAgY29uc3QgaGVhZGVyUEwgPSByZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IHBsID0gMDtcbiAgICAgICAgaWYgKGNvbHVtbi5nZXRDYW5Tb3J0KCkpXG4gICAgICAgICAgICBwbCsrO1xuICAgICAgICBpZiAoc2hvd0NvbHVtbkFjdGlvbnMpXG4gICAgICAgICAgICBwbCArPSAxLjc1O1xuICAgICAgICBpZiAoc2hvd0RyYWdIYW5kbGUpXG4gICAgICAgICAgICBwbCArPSAxLjI1O1xuICAgICAgICByZXR1cm4gcGw7XG4gICAgfSwgW3Nob3dDb2x1bW5BY3Rpb25zLCBzaG93RHJhZ0hhbmRsZV0pO1xuICAgIGNvbnN0IGRyYWdnaW5nQm9yZGVyID0gcmVhY3QudXNlTWVtbygoKSA9PiAoZHJhZ2dpbmdDb2x1bW4gPT09IG51bGwgfHwgZHJhZ2dpbmdDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkXG4gICAgICAgID8gYDFweCBkYXNoZWQgJHt0aGVtZS5jb2xvcnMuZ3JheVs3XX0gIWltcG9ydGFudGBcbiAgICAgICAgOiAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkXG4gICAgICAgICAgICA/IGAycHggZGFzaGVkICR7Z2V0UHJpbWFyeUNvbG9yKHRoZW1lKX0gIWltcG9ydGFudGBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBbZHJhZ2dpbmdDb2x1bW4sIGhvdmVyZWRDb2x1bW5dKTtcbiAgICBjb25zdCBkcmFnZ2luZ0JvcmRlcnMgPSBkcmFnZ2luZ0JvcmRlclxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGRyYWdnaW5nQm9yZGVyLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGRyYWdnaW5nQm9yZGVyLFxuICAgICAgICAgICAgYm9yZGVyVG9wOiBkcmFnZ2luZ0JvcmRlcixcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW50ZXIgPSAoX2UpID0+IHtcbiAgICAgICAgaWYgKGVuYWJsZUdyb3VwaW5nICYmIChob3ZlcmVkQ29sdW1uID09PSBudWxsIHx8IGhvdmVyZWRDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvdmVyZWRDb2x1bW4uaWQpID09PSAnZHJvcC16b25lJykge1xuICAgICAgICAgICAgc2V0SG92ZXJlZENvbHVtbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlQ29sdW1uT3JkZXJpbmcgJiYgZHJhZ2dpbmdDb2x1bW4gJiYgY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgc2V0SG92ZXJlZENvbHVtbihjb2x1bW5EZWYuZW5hYmxlQ29sdW1uT3JkZXJpbmcgIT09IGZhbHNlID8gY29sdW1uIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlckVsZW1lbnQgPSAoY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLkhlYWRlcikgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IChfYSA9IGNvbHVtbkRlZiA9PT0gbnVsbCB8fCBjb2x1bW5EZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbkRlZi5IZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbHVtbkRlZiwge1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pXG4gICAgICAgIDogKF9iID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLkhlYWRlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29sdW1uRGVmLmhlYWRlcjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0aFwiLCBhbGlnbjogY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJyA/ICdjZW50ZXInIDogJ2xlZnQnLCBjb2xTcGFuOiBoZWFkZXIuY29sU3Bhbiwgb25EcmFnRW50ZXI6IGhhbmRsZURyYWdFbnRlciwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWRDZWxsUmVmcy5jdXJyZW50W2NvbHVtbi5pZF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IH0sIHRhYmxlQ2VsbFByb3BzLCB7IHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBmbGV4RGlyZWN0aW9uOiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnY29sdW1uJyA6IHVuZGVmaW5lZCwgZm9udFdlaWdodDogJ2JvbGQnLCBvdmVyZmxvdzogJ3Zpc2libGUnLCBwYWRkaW5nOiBkZW5zaXR5ID09PSAneGwnID8gJzIzcHgnIDogZGVuc2l0eSA9PT0gJ21kJyA/ICcxNnB4JyA6ICcxMHB4JywgdXNlclNlbGVjdDogZW5hYmxlTXVsdGlTb3J0ICYmIGNvbHVtbi5nZXRDYW5Tb3J0KCkgPyAnbm9uZScgOiB1bmRlZmluZWQsIHZlcnRpY2FsQWxpZ246ICd0b3AnLCB6SW5kZXg6IGNvbHVtbi5nZXRJc1Jlc2l6aW5nKCkgfHwgKGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZCkgPT09IGNvbHVtbi5pZFxuICAgICAgICAgICAgICAgID8gM1xuICAgICAgICAgICAgICAgIDogY29sdW1uLmdldElzUGlubmVkKCkgJiYgY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJ1xuICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgOiAxLCAnJjpob3ZlciAubWFudGluZS1BY3Rpb25JY29uLXJvb3QnOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIH0gfSwgZ2V0Q29tbW9uQ2VsbFN0eWxlcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHRhYmxlQ2VsbFByb3BzLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgIH0pKSwgZHJhZ2dpbmdCb3JkZXJzKSksIGNoaWxkcmVuOiBbaGVhZGVyLmlzUGxhY2Vob2xkZXIgPyBudWxsIDogKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkZsZXgsIHsgY2xhc3NOYW1lOiBcIm1hbnRpbmUtVGFibGVIZWFkQ2VsbC1Db250ZW50XCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogKHRhYmxlQ2VsbFByb3BzID09PSBudWxsIHx8IHRhYmxlQ2VsbFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUNlbGxQcm9wcy5hbGlnbikgPT09ICdyaWdodCcgPyAncm93LXJldmVyc2UnIDogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBjb2x1bW5EZWZUeXBlID09PSAnZ3JvdXAnIHx8ICh0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMuYWxpZ24pID09PSAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2x1bW4uZ2V0Q2FuUmVzaXplKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdzcGFjZS1iZXR3ZWVuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4cyhjb3JlLkZsZXgsIHsgY2xhc3NOYW1lOiBcIm1hbnRpbmUtVGFibGVIZWFkQ2VsbC1Db250ZW50LUxhYmVsc1wiLCBvbkNsaWNrOiBjb2x1bW4uZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIoKSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGNvbHVtbi5nZXRDYW5Tb3J0KCkgJiYgY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAodGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLmFsaWduKSA9PT0gJ3JpZ2h0JyA/ICdyb3ctcmV2ZXJzZScgOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogY29sdW1uRGVmVHlwZSA9PT0gJ2RhdGEnID8gJ2hpZGRlbicgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICh0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMuYWxpZ24pID09PSAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAke2hlYWRlclBMfXJlbWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KGNvcmUuRmxleCwgeyBjbGFzc05hbWU6IFwibWFudGluZS1UYWJsZUhlYWRDZWxsLUNvbnRlbnQtV3JhcHBlclwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJyA/ICdoaWRkZW4nIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogKChfZCA9IChfYyA9IGNvbHVtbkRlZi5oZWFkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApIDwgMjAgPyAnbm93cmFwJyA6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aXRsZTogY29sdW1uRGVmVHlwZSA9PT0gJ2RhdGEnID8gY29sdW1uRGVmLmhlYWRlciA6IHVuZGVmaW5lZCwgY2hpbGRyZW46IGhlYWRlckVsZW1lbnQgfSksIGNvbHVtbi5nZXRDYW5Tb3J0KCkgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUhlYWRDZWxsU29ydExhYmVsLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSkpLCBjb2x1bW4uZ2V0Q2FuRmlsdGVyKCkgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUhlYWRDZWxsRmlsdGVyTGFiZWwsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSldIH0pLCBjb2x1bW5EZWZUeXBlICE9PSAnZ3JvdXAnICYmIChqc3hSdW50aW1lLmpzeHMoY29yZS5GbGV4LCB7IGNsYXNzTmFtZTogXCJtYW50aW5lLVRhYmxlSGVhZENlbGwtQ29udGVudC1BY3Rpb25zXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbc2hvd0RyYWdIYW5kbGUgJiYgKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUhlYWRDZWxsR3JhYkhhbmRsZSwgeyBjb2x1bW46IGNvbHVtbiwgdGFibGU6IHRhYmxlLCB0YWJsZUhlYWRDZWxsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB0YWJsZUhlYWRDZWxsUmVmcy5jdXJyZW50W2NvbHVtbi5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpLCBzaG93Q29sdW1uQWN0aW9ucyAmJiAoanN4UnVudGltZS5qc3goTVJUX0NvbHVtbkFjdGlvbk1lbnUsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSldIH0pKSwgY29sdW1uLmdldENhblJlc2l6ZSgpICYmIChqc3hSdW50aW1lLmpzeChNUlRfVGFibGVIZWFkQ2VsbFJlc2l6ZUhhbmRsZSwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlIH0pKV0gfSkpLCBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSA9PT0gJ3N1YmhlYWRlcicgJiYgY29sdW1uLmdldENhbkZpbHRlcigpICYmIChqc3hSdW50aW1lLmpzeChNUlRfVGFibGVIZWFkQ2VsbEZpbHRlckNvbnRhaW5lciwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlIH0pKV0gfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRSb3cgPSAoeyBoZWFkZXJHcm91cCwgdGFibGUsIHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVN0aWNreUhlYWRlciwgbGF5b3V0TW9kZSwgbWFudGluZVRhYmxlSGVhZFJvd1Byb3BzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZVJvd1Byb3BzID0gbWFudGluZVRhYmxlSGVhZFJvd1Byb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lVGFibGVIZWFkUm93UHJvcHMoeyBoZWFkZXJHcm91cCwgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lVGFibGVIZWFkUm93UHJvcHM7XG4gICAgY29uc3Qgc3RpY2t5SGVhZGVyID0gZW5hYmxlU3RpY2t5SGVhZGVyIHx8IGlzRnVsbFNjcmVlbjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0clwiIH0sIHRhYmxlUm93UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogdGhlbWUuY29sb3JTY2hlbWUgPT09ICdkYXJrJyA/IHRoZW1lLmNvbG9ycy5kYXJrWzddIDogdGhlbWUud2hpdGUsIGJveFNoYWRvdzogYDAgNHB4IDhweCAke3RoZW1lLmZuLnJnYmEodGhlbWUuYmxhY2ssIDAuMSl9YCwgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2ZsZXgnIDogJ3RhYmxlLXJvdycsIHRvcDogc3RpY2t5SGVhZGVyID8gMCA6IHVuZGVmaW5lZCB9LCAoKHRhYmxlUm93UHJvcHMgPT09IG51bGwgfHwgdGFibGVSb3dQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dQcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgPyB0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3godGhlbWUpXG4gICAgICAgICAgICA6IHRhYmxlUm93UHJvcHMgPT09IG51bGwgfHwgdGFibGVSb3dQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dQcm9wcy5zeCkpLCB7IHBvc2l0aW9uOiBzdGlja3lIZWFkZXIgPyAnc3RpY2t5JyA6IHVuZGVmaW5lZCB9KSksIGNoaWxkcmVuOiBbdmlydHVhbFBhZGRpbmdMZWZ0ID8gKGpzeFJ1bnRpbWUuanN4KFwidGhcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiAnZmxleCcsIHdpZHRoOiB2aXJ0dWFsUGFkZGluZ0xlZnQgfSB9KSkgOiBudWxsLCAodmlydHVhbENvbHVtbnMgIT09IG51bGwgJiYgdmlydHVhbENvbHVtbnMgIT09IHZvaWQgMCA/IHZpcnR1YWxDb2x1bW5zIDogaGVhZGVyR3JvdXAuaGVhZGVycykubWFwKChoZWFkZXJPclZpcnR1YWxIZWFkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB2aXJ0dWFsQ29sdW1uc1xuICAgICAgICAgICAgICAgICAgICA/IGhlYWRlckdyb3VwLmhlYWRlcnNbaGVhZGVyT3JWaXJ0dWFsSGVhZGVyLmluZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IGhlYWRlck9yVmlydHVhbEhlYWRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUhlYWRDZWxsLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSwgaGVhZGVyLmlkKSk7XG4gICAgICAgICAgICB9KSwgdmlydHVhbFBhZGRpbmdSaWdodCA/IChqc3hSdW50aW1lLmpzeChcInRoXCIsIHsgc3R5bGU6IHsgZGlzcGxheTogJ2ZsZXgnLCB3aWR0aDogdmlydHVhbFBhZGRpbmdSaWdodCB9IH0pKSA6IG51bGxdIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVIZWFkID0gKHsgdGFibGUsIHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldEhlYWRlckdyb3VwcywgZ2V0U2VsZWN0ZWRSb3dNb2RlbCwgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlU3RpY2t5SGVhZGVyLCBsYXlvdXRNb2RlLCBtYW50aW5lVGFibGVIZWFkUHJvcHMsIHBvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBpc0Z1bGxTY3JlZW4sIHNob3dBbGVydEJhbm5lciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZUhlYWRQcm9wcyA9IG1hbnRpbmVUYWJsZUhlYWRQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRhYmxlSGVhZFByb3BzKHsgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lVGFibGVIZWFkUHJvcHM7XG4gICAgY29uc3Qgc3RpY2t5SGVhZGVyID0gZW5hYmxlU3RpY2t5SGVhZGVyIHx8IGlzRnVsbFNjcmVlbjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGNvcmUuQm94LCBPYmplY3QuYXNzaWduKHsgY29tcG9uZW50OiBcInRoZWFkXCIgfSwgdGFibGVIZWFkUHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5OiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnZ3JpZCcgOiAndGFibGUtcm93LWdyb3VwJywgcG9zaXRpb246IHN0aWNreUhlYWRlciAmJiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnc3RpY2t5JyA6ICdyZWxhdGl2ZScsIG9wYWNpdHk6IDAuOTcsIHRvcDogc3RpY2t5SGVhZGVyID8gMCA6IHVuZGVmaW5lZCwgekluZGV4OiBzdGlja3lIZWFkZXIgPyAyIDogdW5kZWZpbmVkIH0sICgodGFibGVIZWFkUHJvcHMgPT09IG51bGwgfHwgdGFibGVIZWFkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlSGVhZFByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHRhYmxlSGVhZFByb3BzID09PSBudWxsIHx8IHRhYmxlSGVhZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUhlYWRQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgIDogdGFibGVIZWFkUHJvcHMgPT09IG51bGwgfHwgdGFibGVIZWFkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlSGVhZFByb3BzLnN4KSkpLCBjaGlsZHJlbjogcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIgPT09ICdoZWFkLW92ZXJsYXknICYmXG4gICAgICAgICAgICAoc2hvd0FsZXJ0QmFubmVyIHx8IGdldFNlbGVjdGVkUm93TW9kZWwoKS5yb3dzLmxlbmd0aCA+IDApID8gKGpzeFJ1bnRpbWUuanN4KFwidHJcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBsYXlvdXRNb2RlID09PSAnZ3JpZCcgPyAnZ3JpZCcgOiAndGFibGUtcm93JyB9LCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goXCJ0aFwiLCB7IGNvbFNwYW46IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLmxlbmd0aCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2dyaWQnIDogJ3RhYmxlLWNlbGwnLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChNUlRfVG9vbGJhckFsZXJ0QmFubmVyLCB7IHRhYmxlOiB0YWJsZSB9KSB9KSB9KSkgOiAoZ2V0SGVhZGVyR3JvdXBzKCkubWFwKChoZWFkZXJHcm91cCkgPT4gKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUhlYWRSb3csIHsgaGVhZGVyR3JvdXA6IGhlYWRlckdyb3VwLCB0YWJsZTogdGFibGUsIHZpcnR1YWxDb2x1bW5zOiB2aXJ0dWFsQ29sdW1ucywgdmlydHVhbFBhZGRpbmdMZWZ0OiB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQ6IHZpcnR1YWxQYWRkaW5nUmlnaHQgfSwgaGVhZGVyR3JvdXAuaWQpKSkpIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVGb290ZXJDZWxsID0gKHsgZm9vdGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBsYXlvdXRNb2RlLCBtYW50aW5lVGFibGVGb290ZXJDZWxsUHJvcHMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBmb290ZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZlR5cGUgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBtVGFibGVGb290ZXJDZWxsUHJvcHMgPSBtYW50aW5lVGFibGVGb290ZXJDZWxsUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUYWJsZUZvb3RlckNlbGxQcm9wcyh7IGNvbHVtbiwgdGFibGUgfSlcbiAgICAgICAgOiBtYW50aW5lVGFibGVGb290ZXJDZWxsUHJvcHM7XG4gICAgY29uc3QgbWNUYWJsZUZvb3RlckNlbGxQcm9wcyA9IGNvbHVtbkRlZi5tYW50aW5lVGFibGVGb290ZXJDZWxsUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtbkRlZi5tYW50aW5lVGFibGVGb290ZXJDZWxsUHJvcHMoeyBjb2x1bW4sIHRhYmxlIH0pXG4gICAgICAgIDogY29sdW1uRGVmLm1hbnRpbmVUYWJsZUZvb3RlckNlbGxQcm9wcztcbiAgICBjb25zdCB0YWJsZUNlbGxQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbVRhYmxlRm9vdGVyQ2VsbFByb3BzKSwgbWNUYWJsZUZvb3RlckNlbGxQcm9wcyk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0aFwiLCBhbGlnbjogY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJyA/ICdjZW50ZXInIDogJ2xlZnQnLCBjb2xTcGFuOiBmb290ZXIuY29sU3BhbiB9LCB0YWJsZUNlbGxQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6IGxheW91dE1vZGUgPT09ICdncmlkJyA/ICdncmlkJyA6ICd0YWJsZS1jZWxsJywgZm9udFdlaWdodDogJ2JvbGQnLCBqdXN0aWZ5Q29udGVudDogY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJyA/ICdjZW50ZXInIDogdW5kZWZpbmVkLCBwYWRkaW5nOiAnOHB4JywgdmVydGljYWxBbGlnbjogJ3RvcCcsIHpJbmRleDogY29sdW1uLmdldElzUGlubmVkKCkgJiYgY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJyA/IDIgOiAxIH0sIGdldENvbW1vbkNlbGxTdHlsZXMoe1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRhYmxlQ2VsbFByb3BzLFxuICAgICAgICB9KSkpLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogZm9vdGVyLmlzUGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IChfYyA9IChfYiA9IChjb2x1bW5EZWYuRm9vdGVyIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgPyAoX2EgPSBjb2x1bW5EZWYuRm9vdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb2x1bW5EZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IGNvbHVtbkRlZi5Gb290ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb2x1bW5EZWYuZm9vdGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsIH0pIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVGb290ZXJSb3cgPSAoeyBmb290ZXJHcm91cCwgdGFibGUsIHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGxheW91dE1vZGUsIG1hbnRpbmVUYWJsZUZvb3RlclJvd1Byb3BzIH0sIH0gPSB0YWJsZTtcbiAgICAvLyBpZiBubyBjb250ZW50IGluIHJvdywgc2tpcCByb3dcbiAgICBpZiAoISgoX2EgPSBmb290ZXJHcm91cC5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoaGVhZGVyKSA9PiAodHlwZW9mIGhlYWRlci5jb2x1bW4uY29sdW1uRGVmLmZvb3RlciA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgISFoZWFkZXIuY29sdW1uLmNvbHVtbkRlZi5mb290ZXIpIHx8XG4gICAgICAgIGhlYWRlci5jb2x1bW4uY29sdW1uRGVmLkZvb3RlcikpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0YWJsZVJvd1Byb3BzID0gbWFudGluZVRhYmxlRm9vdGVyUm93UHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVUYWJsZUZvb3RlclJvd1Byb3BzKHsgZm9vdGVyR3JvdXAsIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVRhYmxlRm9vdGVyUm93UHJvcHM7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoY29yZS5Cb3gsIE9iamVjdC5hc3NpZ24oeyBjb21wb25lbnQ6IFwidHJcIiB9LCB0YWJsZVJvd1Byb3BzLCB7IHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5mbi5saWdodGVuKHRoZW1lLmNvbG9yU2NoZW1lID09PSAnZGFyaycgPyB0aGVtZS5jb2xvcnMuZGFya1s3XSA6IHRoZW1lLndoaXRlLCAwLjA2KSwgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2ZsZXgnIDogJ3RhYmxlLXJvdycsIHdpZHRoOiAnMTAwJScgfSwgKCh0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3gpIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gdGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgOiB0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3gpKSksIGNoaWxkcmVuOiBbdmlydHVhbFBhZGRpbmdMZWZ0ID8gKGpzeFJ1bnRpbWUuanN4KFwidGhcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiAnZmxleCcsIHdpZHRoOiB2aXJ0dWFsUGFkZGluZ0xlZnQgfSB9KSkgOiBudWxsLCAodmlydHVhbENvbHVtbnMgIT09IG51bGwgJiYgdmlydHVhbENvbHVtbnMgIT09IHZvaWQgMCA/IHZpcnR1YWxDb2x1bW5zIDogZm9vdGVyR3JvdXAuaGVhZGVycykubWFwKChmb290ZXJPclZpcnR1YWxGb290ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb290ZXIgPSB2aXJ0dWFsQ29sdW1uc1xuICAgICAgICAgICAgICAgICAgICA/IGZvb3Rlckdyb3VwLmhlYWRlcnNbZm9vdGVyT3JWaXJ0dWFsRm9vdGVyLmluZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IGZvb3Rlck9yVmlydHVhbEZvb3RlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUZvb3RlckNlbGwsIHsgZm9vdGVyOiBmb290ZXIsIHRhYmxlOiB0YWJsZSB9LCBmb290ZXIuaWQpKTtcbiAgICAgICAgICAgIH0pLCB2aXJ0dWFsUGFkZGluZ1JpZ2h0ID8gKGpzeFJ1bnRpbWUuanN4KFwidGhcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiAnZmxleCcsIHdpZHRoOiB2aXJ0dWFsUGFkZGluZ1JpZ2h0IH0gfSkpIDogbnVsbF0gfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUZvb3RlciA9ICh7IHRhYmxlLCB2aXJ0dWFsQ29sdW1ucywgdmlydHVhbFBhZGRpbmdMZWZ0LCB2aXJ0dWFsUGFkZGluZ1JpZ2h0LCB9KSA9PiB7XG4gICAgY29uc3QgeyBnZXRGb290ZXJHcm91cHMsIGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVN0aWNreUZvb3RlciwgbGF5b3V0TW9kZSwgbWFudGluZVRhYmxlRm9vdGVyUHJvcHMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgaXNGdWxsU2NyZWVuIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRhYmxlRm9vdGVyUHJvcHMgPSBtYW50aW5lVGFibGVGb290ZXJQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRhYmxlRm9vdGVyUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVUYWJsZUZvb3RlclByb3BzO1xuICAgIGNvbnN0IHN0aWNrRm9vdGVyID0gKGlzRnVsbFNjcmVlbiB8fCBlbmFibGVTdGlja3lGb290ZXIpICYmIGVuYWJsZVN0aWNreUZvb3RlciAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChjb3JlLkJveCwgT2JqZWN0LmFzc2lnbih7IGNvbXBvbmVudDogXCJ0Zm9vdFwiIH0sIHRhYmxlRm9vdGVyUHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBib3R0b206IHN0aWNrRm9vdGVyID8gMCA6IHVuZGVmaW5lZCwgZGlzcGxheTogbGF5b3V0TW9kZSA9PT0gJ2dyaWQnID8gJ2dyaWQnIDogJ3RhYmxlLXJvdy1ncm91cCcsIG9wYWNpdHk6IHN0aWNrRm9vdGVyID8gMC45NyA6IHVuZGVmaW5lZCwgb3V0bGluZTogc3RpY2tGb290ZXJcbiAgICAgICAgICAgICAgICA/IHRoZW1lLmNvbG9yU2NoZW1lID09PSAnbGlnaHQnXG4gICAgICAgICAgICAgICAgICAgID8gYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ncmF5WzNdfWBcbiAgICAgICAgICAgICAgICAgICAgOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmdyYXlbN119YFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogc3RpY2tGb290ZXIgPyAnc3RpY2t5JyA6IHVuZGVmaW5lZCwgekluZGV4OiBzdGlja0Zvb3RlciA/IDEgOiB1bmRlZmluZWQgfSwgKCh0YWJsZUZvb3RlclByb3BzID09PSBudWxsIHx8IHRhYmxlRm9vdGVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlRm9vdGVyUHJvcHMuc3gpIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgID8gdGFibGVGb290ZXJQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUZvb3RlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUZvb3RlclByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgOiB0YWJsZUZvb3RlclByb3BzID09PSBudWxsIHx8IHRhYmxlRm9vdGVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlRm9vdGVyUHJvcHMuc3gpKSksIGNoaWxkcmVuOiBnZXRGb290ZXJHcm91cHMoKS5tYXAoKGZvb3Rlckdyb3VwKSA9PiAoanN4UnVudGltZS5qc3goTVJUX1RhYmxlRm9vdGVyUm93LCB7IGZvb3Rlckdyb3VwOiBmb290ZXJHcm91cCwgdGFibGU6IHRhYmxlLCB2aXJ0dWFsQ29sdW1uczogdmlydHVhbENvbHVtbnMsIHZpcnR1YWxQYWRkaW5nTGVmdDogdmlydHVhbFBhZGRpbmdMZWZ0LCB2aXJ0dWFsUGFkZGluZ1JpZ2h0OiB2aXJ0dWFsUGFkZGluZ1JpZ2h0IH0sIGZvb3Rlckdyb3VwLmlkKSkpIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGUgPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IGdldEZsYXRIZWFkZXJzLCBnZXRTdGF0ZSwgb3B0aW9uczogeyBjb2x1bW5WaXJ0dWFsaXplckluc3RhbmNlUmVmLCBjb2x1bW5WaXJ0dWFsaXplclByb3BzLCBjb2x1bW5zLCBlbmFibGVDb2x1bW5SZXNpemluZywgZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24sIGVuYWJsZVBpbm5pbmcsIGVuYWJsZVRhYmxlRm9vdGVyLCBlbmFibGVUYWJsZUhlYWQsIGxheW91dE1vZGUsIG1hbnRpbmVUYWJsZVByb3BzLCBtZW1vTW9kZSwgfSwgcmVmczogeyB0YWJsZUNvbnRhaW5lclJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5QaW5uaW5nLCBjb2x1bW5TaXppbmcsIGNvbHVtblNpemluZ0luZm8sIGNvbHVtblZpc2liaWxpdHksIGRlbnNpdHksIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRhYmxlUHJvcHMgPSBtYW50aW5lVGFibGVQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVRhYmxlUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVUYWJsZVByb3BzO1xuICAgIGNvbnN0IHZQcm9wcyA9IGNvbHVtblZpcnR1YWxpemVyUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGNvbHVtblZpcnR1YWxpemVyUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IGNvbHVtblZpcnR1YWxpemVyUHJvcHM7XG4gICAgY29uc3QgY29sdW1uU2l6ZVZhcnMgPSByZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGdldEZsYXRIZWFkZXJzKCk7XG4gICAgICAgIGNvbnN0IGNvbFNpemVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29sU2l6ZXNbYC0taGVhZGVyLSR7cGFyc2VDU1NWYXJJZChoZWFkZXIuaWQpfS1zaXplYF0gPSBjb2xTaXplO1xuICAgICAgICAgICAgY29sU2l6ZXNbYC0tY29sLSR7cGFyc2VDU1NWYXJJZChoZWFkZXIuY29sdW1uLmlkKX0tc2l6ZWBdID0gY29sU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sU2l6ZXM7XG4gICAgfSwgW2NvbHVtbnMsIGNvbHVtblNpemluZywgY29sdW1uU2l6aW5nSW5mbywgY29sdW1uVmlzaWJpbGl0eV0pO1xuICAgIC8vZ2V0IGZpcnN0IDE2IGNvbHVtbiB3aWR0aHMgYW5kIGF2ZXJhZ2UgdGhlbVxuICAgIGNvbnN0IGF2ZXJhZ2VDb2x1bW5XaWR0aCA9IHJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgY29sdW1uc1dpZHRocyA9IChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRhYmxlXG4gICAgICAgICAgICAuZ2V0Um93TW9kZWwoKVxuICAgICAgICAgICAgLnJvd3NbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKDAsIDE2KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoY2VsbCkgPT4gY2VsbC5jb2x1bW4uZ2V0U2l6ZSgpICogMS4yKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgICAgIHJldHVybiBjb2x1bW5zV2lkdGhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gY29sdW1uc1dpZHRocy5sZW5ndGg7XG4gICAgfSwgW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgY29sdW1uUGlubmluZywgY29sdW1uVmlzaWJpbGl0eV0pO1xuICAgIGNvbnN0IFtsZWZ0UGlubmVkSW5kZXhlcywgcmlnaHRQaW5uZWRJbmRleGVzXSA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24gJiYgZW5hYmxlUGlubmluZ1xuICAgICAgICA/IFtcbiAgICAgICAgICAgIHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucygpLm1hcCgoYykgPT4gYy5nZXRQaW5uZWRJbmRleCgpKSxcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgLmdldFJpZ2h0TGVhZkNvbHVtbnMoKVxuICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLmxlbmd0aCAtIGMuZ2V0UGlubmVkSW5kZXgoKSAtIDEpLFxuICAgICAgICBdXG4gICAgICAgIDogW1tdLCBbXV0sIFtjb2x1bW5QaW5uaW5nLCBlbmFibGVDb2x1bW5WaXJ0dWFsaXphdGlvbiwgZW5hYmxlUGlubmluZ10pO1xuICAgIGNvbnN0IGNvbHVtblZpcnR1YWxpemVyID0gZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb25cbiAgICAgICAgPyByZWFjdFZpcnR1YWwudXNlVmlydHVhbGl6ZXIoT2JqZWN0LmFzc2lnbih7IGNvdW50OiB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKS5sZW5ndGgsIGVzdGltYXRlU2l6ZTogKCkgPT4gYXZlcmFnZUNvbHVtbldpZHRoLCBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0YWJsZUNvbnRhaW5lclJlZi5jdXJyZW50LCBob3Jpem9udGFsOiB0cnVlLCBvdmVyc2NhbjogMywgcmFuZ2VFeHRyYWN0b3I6IHJlYWN0LnVzZUNhbGxiYWNrKChyYW5nZSkgPT4gW1xuICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5sZWZ0UGlubmVkSW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVhY3RWaXJ0dWFsLmRlZmF1bHRSYW5nZUV4dHJhY3RvcihyYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnJpZ2h0UGlubmVkSW5kZXhlcyxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0sIFtsZWZ0UGlubmVkSW5kZXhlcywgcmlnaHRQaW5uZWRJbmRleGVzXSkgfSwgdlByb3BzKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGNvbHVtblZpcnR1YWxpemVySW5zdGFuY2VSZWYgJiYgY29sdW1uVmlydHVhbGl6ZXIpIHtcbiAgICAgICAgY29sdW1uVmlydHVhbGl6ZXJJbnN0YW5jZVJlZi5jdXJyZW50ID0gY29sdW1uVmlydHVhbGl6ZXI7XG4gICAgfVxuICAgIGNvbnN0IHZpcnR1YWxDb2x1bW5zID0gY29sdW1uVmlydHVhbGl6ZXJcbiAgICAgICAgPyBjb2x1bW5WaXJ0dWFsaXplci5nZXRWaXJ0dWFsSXRlbXMoKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBsZXQgdmlydHVhbFBhZGRpbmdMZWZ0O1xuICAgIGxldCB2aXJ0dWFsUGFkZGluZ1JpZ2h0O1xuICAgIGlmIChjb2x1bW5WaXJ0dWFsaXplciAmJiAodmlydHVhbENvbHVtbnMgPT09IG51bGwgfHwgdmlydHVhbENvbHVtbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpcnR1YWxDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgdmlydHVhbFBhZGRpbmdMZWZ0ID0gKF9iID0gKF9hID0gdmlydHVhbENvbHVtbnNbbGVmdFBpbm5lZEluZGV4ZXMubGVuZ3RoXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICB2aXJ0dWFsUGFkZGluZ1JpZ2h0ID1cbiAgICAgICAgICAgIGNvbHVtblZpcnR1YWxpemVyLmdldFRvdGFsU2l6ZSgpIC1cbiAgICAgICAgICAgICAgICAoKF9kID0gKF9jID0gdmlydHVhbENvbHVtbnNbdmlydHVhbENvbHVtbnMubGVuZ3RoIC0gMSAtIHJpZ2h0UGlubmVkSW5kZXhlcy5sZW5ndGhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5kKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGNvbHVtblZpcnR1YWxpemVyLFxuICAgICAgICBlbmFibGVIb3ZlcjogdGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLmhpZ2hsaWdodE9uSG92ZXIsXG4gICAgICAgIGlzU3RyaXBlZDogdGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLnN0cmlwZWQsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICB2aXJ0dWFsQ29sdW1ucyxcbiAgICAgICAgdmlydHVhbFBhZGRpbmdMZWZ0LFxuICAgICAgICB2aXJ0dWFsUGFkZGluZ1JpZ2h0LFxuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoY29yZS5UYWJsZSwgT2JqZWN0LmFzc2lnbih7IGhpZ2hsaWdodE9uSG92ZXI6IHRydWUsIGhvcml6b250YWxTcGFjaW5nOiBkZW5zaXR5LCB2ZXJ0aWNhbFNwYWNpbmc6IGRlbnNpdHkgfSwgdGFibGVQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6IGxheW91dE1vZGUgPT09ICdncmlkJyA/ICdncmlkJyA6ICd0YWJsZScsIHRhYmxlTGF5b3V0OiBsYXlvdXRNb2RlICE9PSAnZ3JpZCcgJiYgZW5hYmxlQ29sdW1uUmVzaXppbmcgPyAnZml4ZWQnIDogdW5kZWZpbmVkLCAnJiB0cjpmaXJzdC1vZi10eXBlIHRkJzoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ncmF5W3RoZW1lLmNvbG9yU2NoZW1lID09PSAnZGFyaycgPyA4IDogM119YCxcbiAgICAgICAgICAgIH0sICcmIHRyOmxhc3Qtb2YtdHlwZSB0ZCc6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZ3JheVt0aGVtZS5jb2xvclNjaGVtZSA9PT0gJ2RhcmsnID8gOCA6IDNdfWAsXG4gICAgICAgICAgICB9IH0sICgodGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHRhYmxlUHJvcHMuc3godGhlbWUpXG4gICAgICAgICAgICA6IHRhYmxlUHJvcHMgPT09IG51bGwgfHwgdGFibGVQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVQcm9wcy5zeCkpKSwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sdW1uU2l6ZVZhcnMpLCB0YWJsZVByb3BzID09PSBudWxsIHx8IHRhYmxlUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUHJvcHMuc3R5bGUpLCBjaGlsZHJlbjogW2VuYWJsZVRhYmxlSGVhZCAmJiBqc3hSdW50aW1lLmpzeChNUlRfVGFibGVIZWFkLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpLCBtZW1vTW9kZSA9PT0gJ3RhYmxlLWJvZHknIHx8IGNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA/IChqc3hSdW50aW1lLmpzeChNZW1vX01SVF9UYWJsZUJvZHksIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpIDogKGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUJvZHksIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpLCBlbmFibGVUYWJsZUZvb3RlciAmJiBqc3hSdW50aW1lLmpzeChNUlRfVGFibGVGb290ZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSldIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfRWRpdFJvd01vZGFsID0gKHsgb3BlbiwgdGFibGUsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBvbkVkaXRpbmdSb3dDYW5jZWwsIG9uQ3JlYXRpbmdSb3dDYW5jZWwsIHJlbmRlckVkaXRSb3dNb2RhbENvbnRlbnQsIHJlbmRlckNyZWF0ZVJvd01vZGFsQ29udGVudCwgbWFudGluZUNyZWF0ZVJvd01vZGFsUHJvcHMsIG1hbnRpbmVFZGl0Um93TW9kYWxQcm9wcywgfSwgc2V0RWRpdGluZ1Jvdywgc2V0Q3JlYXRpbmdSb3csIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNyZWF0aW5nUm93LCBlZGl0aW5nUm93IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHJvdyA9IChjcmVhdGluZ1JvdyAhPT0gbnVsbCAmJiBjcmVhdGluZ1JvdyAhPT0gdm9pZCAwID8gY3JlYXRpbmdSb3cgOiBlZGl0aW5nUm93KTtcbiAgICBjb25zdCBjcmVhdGVNb2RhbFByb3BzID0gbWFudGluZUNyZWF0ZVJvd01vZGFsUHJvcHMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IG1hbnRpbmVDcmVhdGVSb3dNb2RhbFByb3BzKHsgcm93LCB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVDcmVhdGVSb3dNb2RhbFByb3BzO1xuICAgIGNvbnN0IGVkaXRNb2RhbFByb3BzID0gbWFudGluZUVkaXRSb3dNb2RhbFByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lRWRpdFJvd01vZGFsUHJvcHMoeyByb3csIHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZUVkaXRSb3dNb2RhbFByb3BzO1xuICAgIGNvbnN0IG1vZGFsUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVkaXRNb2RhbFByb3BzKSwgKGNyZWF0aW5nUm93ICYmIGNyZWF0ZU1vZGFsUHJvcHMpKTtcbiAgICBjb25zdCBpbnRlcm5hbEVkaXRDb21wb25lbnRzID0gcm93XG4gICAgICAgIC5nZXRBbGxDZWxscygpXG4gICAgICAgIC5maWx0ZXIoKGNlbGwpID0+IGNlbGwuY29sdW1uLmNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID09PSAnZGF0YScpXG4gICAgICAgIC5tYXAoKGNlbGwpID0+IChqc3hSdW50aW1lLmpzeChNUlRfRWRpdENlbGxUZXh0SW5wdXQsIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlIH0sIGNlbGwuaWQpKSk7XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChjcmVhdGluZ1Jvdykge1xuICAgICAgICAgICAgb25DcmVhdGluZ1Jvd0NhbmNlbCA9PT0gbnVsbCB8fCBvbkNyZWF0aW5nUm93Q2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNyZWF0aW5nUm93Q2FuY2VsKHsgcm93LCB0YWJsZSB9KTtcbiAgICAgICAgICAgIHNldENyZWF0aW5nUm93KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25FZGl0aW5nUm93Q2FuY2VsID09PSBudWxsIHx8IG9uRWRpdGluZ1Jvd0NhbmNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FZGl0aW5nUm93Q2FuY2VsKHsgcm93LCB0YWJsZSB9KTtcbiAgICAgICAgICAgIHNldEVkaXRpbmdSb3cobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcm93Ll92YWx1ZXNDYWNoZSA9IHt9OyAvL3Jlc2V0IHZhbHVlcyBjYWNoZVxuICAgICAgICAoX2EgPSBtb2RhbFByb3BzLm9uQ2xvc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG1vZGFsUHJvcHMpO1xuICAgIH07XG4gICAgcmV0dXJuIChyZWFjdC5jcmVhdGVFbGVtZW50KGNvcmUuTW9kYWwsIE9iamVjdC5hc3NpZ24oeyBvcGVuZWQ6IG9wZW4sIHdpdGhDbG9zZUJ1dHRvbjogZmFsc2UgfSwgbW9kYWxQcm9wcywgeyBvbkNsb3NlOiBoYW5kbGVDYW5jZWwsIGtleTogcm93LmlkIH0pLCAoX2EgPSAoKGNyZWF0aW5nUm93ICYmXG4gICAgICAgIChyZW5kZXJDcmVhdGVSb3dNb2RhbENvbnRlbnQgPT09IG51bGwgfHwgcmVuZGVyQ3JlYXRlUm93TW9kYWxDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJDcmVhdGVSb3dNb2RhbENvbnRlbnQoe1xuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICBpbnRlcm5hbEVkaXRDb21wb25lbnRzLFxuICAgICAgICB9KSkpIHx8XG4gICAgICAgIChyZW5kZXJFZGl0Um93TW9kYWxDb250ZW50ID09PSBudWxsIHx8IHJlbmRlckVkaXRSb3dNb2RhbENvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckVkaXRSb3dNb2RhbENvbnRlbnQoe1xuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICBpbnRlcm5hbEVkaXRDb21wb25lbnRzLFxuICAgICAgICB9KSkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoanN4UnVudGltZS5qc3hzKGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeChcImZvcm1cIiwgeyBvblN1Ym1pdDogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KGNvcmUuU3RhY2ssIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogJzI0cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzE2cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGludGVybmFsRWRpdENvbXBvbmVudHMgfSkgfSksIGpzeFJ1bnRpbWUuanN4KGNvcmUuRmxleCwgeyBzeDogeyBwYWRkaW5nVG9wOiAnMjRweCcsIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnIH0sIGNoaWxkcmVuOiBqc3hSdW50aW1lLmpzeChNUlRfRWRpdEFjdGlvbkJ1dHRvbnMsIHsgcm93OiByb3csIHRhYmxlOiB0YWJsZSwgdmFyaWFudDogXCJ0ZXh0XCIgfSkgfSldIH0pKSkpO1xufTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gcmVhY3QudXNlTGF5b3V0RWZmZWN0IDogcmVhY3QudXNlRWZmZWN0O1xuY29uc3QgTVJUX1RhYmxlQ29udGFpbmVyID0gKHsgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZVN0aWNreUhlYWRlciwgbWFudGluZUxvYWRpbmdPdmVybGF5UHJvcHMsIG1hbnRpbmVUYWJsZUNvbnRhaW5lclByb3BzLCB9LCByZWZzOiB7IHRhYmxlQ29udGFpbmVyUmVmLCBib3R0b21Ub29sYmFyUmVmLCB0b3BUb29sYmFyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiwgaXNMb2FkaW5nLCBzaG93TG9hZGluZ092ZXJsYXksIGNyZWF0aW5nUm93LCBlZGl0aW5nUm93LCB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBbdG90YWxUb29sYmFySGVpZ2h0LCBzZXRUb3RhbFRvb2xiYXJIZWlnaHRdID0gcmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgdGFibGVDb250YWluZXJQcm9wcyA9IG1hbnRpbmVUYWJsZUNvbnRhaW5lclByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lVGFibGVDb250YWluZXJQcm9wcyh7IHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZVRhYmxlQ29udGFpbmVyUHJvcHM7XG4gICAgY29uc3QgbG9hZGluZ092ZXJsYXlQcm9wcyA9IG1hbnRpbmVMb2FkaW5nT3ZlcmxheVByb3BzIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBtYW50aW5lTG9hZGluZ092ZXJsYXlQcm9wcyh7IHRhYmxlIH0pXG4gICAgICAgIDogbWFudGluZUxvYWRpbmdPdmVybGF5UHJvcHM7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgdG9wVG9vbGJhckhlaWdodCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gKF9iID0gKF9hID0gdG9wVG9vbGJhclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2Zmc2V0SGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIGNvbnN0IGJvdHRvbVRvb2xiYXJIZWlnaHQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IChfZCA9IChfYyA9IGJvdHRvbVRvb2xiYXJSZWYgPT09IG51bGwgfHwgYm90dG9tVG9vbGJhclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm90dG9tVG9vbGJhclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub2Zmc2V0SGVpZ2h0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHNldFRvdGFsVG9vbGJhckhlaWdodCh0b3BUb29sYmFySGVpZ2h0ICsgYm90dG9tVG9vbGJhckhlaWdodCk7XG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlTW9kYWxPcGVuID0gY3JlYXRlRGlzcGxheU1vZGUgPT09ICdtb2RhbCcgJiYgY3JlYXRpbmdSb3c7XG4gICAgY29uc3QgZWRpdE1vZGFsT3BlbiA9IGVkaXREaXNwbGF5TW9kZSA9PT0gJ21vZGFsJyAmJiBlZGl0aW5nUm93O1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuQm94LCBPYmplY3QuYXNzaWduKHt9LCB0YWJsZUNvbnRhaW5lclByb3BzLCB7IHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGFibGVDb250YWluZXJSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IG51bGwgfHwgdGFibGVDb250YWluZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDb250YWluZXJQcm9wcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyUHJvcHMucmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBtYXhXaWR0aDogJzEwMCUnLCBtYXhIZWlnaHQ6IGVuYWJsZVN0aWNreUhlYWRlclxuICAgICAgICAgICAgICAgID8gYGNsYW1wKDM1MHB4LCBjYWxjKDEwMHZoIC0gJHt0b3RhbFRvb2xiYXJIZWlnaHR9cHgpLCA5OTk5cHgpYFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvdmVyZmxvdzogJ2F1dG8nLCBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9LCAoKHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IG51bGwgfHwgdGFibGVDb250YWluZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDb250YWluZXJQcm9wcy5zeCkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgPyB0YWJsZUNvbnRhaW5lclByb3BzLnN4KHRoZW1lKVxuICAgICAgICAgICAgOiB0YWJsZUNvbnRhaW5lclByb3BzID09PSBudWxsIHx8IHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ29udGFpbmVyUHJvcHMuc3gpKSksIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgbWF4SGVpZ2h0OiBpc0Z1bGxTY3JlZW5cbiAgICAgICAgICAgICAgICA/IGBjYWxjKDEwMHZoIC0gJHt0b3RhbFRvb2xiYXJIZWlnaHR9cHgpYFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IG51bGwgfHwgdGFibGVDb250YWluZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDb250YWluZXJQcm9wcy5zdHlsZSksIGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goY29yZS5Mb2FkaW5nT3ZlcmxheSwgT2JqZWN0LmFzc2lnbih7IHZpc2libGU6IGlzTG9hZGluZyB8fCBzaG93TG9hZGluZ092ZXJsYXkgfSwgbG9hZGluZ092ZXJsYXlQcm9wcykpLCBqc3hSdW50aW1lLmpzeChNUlRfVGFibGUsIHsgdGFibGU6IHRhYmxlIH0pLCAoY3JlYXRlTW9kYWxPcGVuIHx8IGVkaXRNb2RhbE9wZW4pICYmIChqc3hSdW50aW1lLmpzeChNUlRfRWRpdFJvd01vZGFsLCB7IG9wZW46IHRydWUsIHRhYmxlOiB0YWJsZSB9KSldIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVQYXBlciA9ICh7IHRhYmxlLCB9KSA9PiB7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVCb3R0b21Ub29sYmFyLCBlbmFibGVUb3BUb29sYmFyLCBtYW50aW5lUGFwZXJQcm9wcywgcmVuZGVyQm90dG9tVG9vbGJhciwgcmVuZGVyVG9wVG9vbGJhciwgfSwgcmVmczogeyB0YWJsZVBhcGVyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZVBhcGVyUHJvcHMgPSBtYW50aW5lUGFwZXJQcm9wcyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gbWFudGluZVBhcGVyUHJvcHMoeyB0YWJsZSB9KVxuICAgICAgICA6IG1hbnRpbmVQYXBlclByb3BzO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGNvcmUuUGFwZXIsIE9iamVjdC5hc3NpZ24oeyBzaGFkb3c6IFwieHNcIiwgd2l0aEJvcmRlcjogdHJ1ZSB9LCB0YWJsZVBhcGVyUHJvcHMsIHsgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICB0YWJsZVBhcGVyUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICBpZiAodGFibGVQYXBlclByb3BzID09PSBudWxsIHx8IHRhYmxlUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVQYXBlclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgIHRhYmxlUGFwZXJQcm9wcy5yZWYuY3VycmVudCA9IHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBvdmVyZmxvdzogJ2hpZGRlbicsIHRyYW5zaXRpb246ICdhbGwgMTAwbXMgZWFzZS1pbi1vdXQnIH0sICgodGFibGVQYXBlclByb3BzID09PSBudWxsIHx8IHRhYmxlUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVQYXBlclByb3BzLnN4KSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICA/IHRhYmxlUGFwZXJQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVBhcGVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUGFwZXJQcm9wcy5zeCh0aGVtZSlcbiAgICAgICAgICAgIDogdGFibGVQYXBlclByb3BzID09PSBudWxsIHx8IHRhYmxlUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVQYXBlclByb3BzLnN4KSkpLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoaXNGdWxsU2NyZWVuXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMHZ3JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pKSwgdGFibGVQYXBlclByb3BzID09PSBudWxsIHx8IHRhYmxlUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVQYXBlclByb3BzLnN0eWxlKSwgY2hpbGRyZW46IFtlbmFibGVUb3BUb29sYmFyICYmXG4gICAgICAgICAgICAgICAgKHJlbmRlclRvcFRvb2xiYXIgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclRvcFRvb2xiYXIoeyB0YWJsZSB9KVxuICAgICAgICAgICAgICAgICAgICA6IHJlbmRlclRvcFRvb2xiYXIgIT09IG51bGwgJiYgcmVuZGVyVG9wVG9vbGJhciAhPT0gdm9pZCAwID8gcmVuZGVyVG9wVG9vbGJhciA6IGpzeFJ1bnRpbWUuanN4KE1SVF9Ub3BUb29sYmFyLCB7IHRhYmxlOiB0YWJsZSB9KSksIGpzeFJ1bnRpbWUuanN4KE1SVF9UYWJsZUNvbnRhaW5lciwgeyB0YWJsZTogdGFibGUgfSksIGVuYWJsZUJvdHRvbVRvb2xiYXIgJiZcbiAgICAgICAgICAgICAgICAocmVuZGVyQm90dG9tVG9vbGJhciBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gcmVuZGVyQm90dG9tVG9vbGJhcih7IHRhYmxlIH0pXG4gICAgICAgICAgICAgICAgICAgIDogcmVuZGVyQm90dG9tVG9vbGJhciAhPT0gbnVsbCAmJiByZW5kZXJCb3R0b21Ub29sYmFyICE9PSB2b2lkIDAgPyByZW5kZXJCb3R0b21Ub29sYmFyIDoganN4UnVudGltZS5qc3goTVJUX0JvdHRvbVRvb2xiYXIsIHsgdGFibGU6IHRhYmxlIH0pKV0gfSkpKTtcbn07XG5cbmNvbnN0IGlzVGFibGVJbnN0YW5jZVByb3AgPSAocHJvcHMpID0+IHByb3BzLnRhYmxlICE9PSB1bmRlZmluZWQ7XG5jb25zdCBNYW50aW5lUmVhY3RUYWJsZSA9IChwcm9wcykgPT4ge1xuICAgIGxldCB0YWJsZTtcbiAgICBpZiAoaXNUYWJsZUluc3RhbmNlUHJvcChwcm9wcykpIHtcbiAgICAgICAgdGFibGUgPSBwcm9wcy50YWJsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhYmxlID0gdXNlTWFudGluZVJlYWN0VGFibGUocHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4ganN4UnVudGltZS5qc3goTVJUX1RhYmxlUGFwZXIsIHsgdGFibGU6IHRhYmxlIH0pO1xufTtcblxuZXhwb3J0cy5NUlRfQWdncmVnYXRpb25GbnMgPSBNUlRfQWdncmVnYXRpb25GbnM7XG5leHBvcnRzLk1SVF9Cb3R0b21Ub29sYmFyID0gTVJUX0JvdHRvbVRvb2xiYXI7XG5leHBvcnRzLk1SVF9Db2x1bW5BY3Rpb25NZW51ID0gTVJUX0NvbHVtbkFjdGlvbk1lbnU7XG5leHBvcnRzLk1SVF9Db2x1bW5QaW5uaW5nQnV0dG9ucyA9IE1SVF9Db2x1bW5QaW5uaW5nQnV0dG9ucztcbmV4cG9ydHMuTVJUX0NvcHlCdXR0b24gPSBNUlRfQ29weUJ1dHRvbjtcbmV4cG9ydHMuTVJUX0RlZmF1bHRDb2x1bW4gPSBNUlRfRGVmYXVsdENvbHVtbjtcbmV4cG9ydHMuTVJUX0RlZmF1bHREaXNwbGF5Q29sdW1uID0gTVJUX0RlZmF1bHREaXNwbGF5Q29sdW1uO1xuZXhwb3J0cy5NUlRfRWRpdEFjdGlvbkJ1dHRvbnMgPSBNUlRfRWRpdEFjdGlvbkJ1dHRvbnM7XG5leHBvcnRzLk1SVF9FZGl0Q2VsbFRleHRJbnB1dCA9IE1SVF9FZGl0Q2VsbFRleHRJbnB1dDtcbmV4cG9ydHMuTVJUX0VkaXRSb3dNb2RhbCA9IE1SVF9FZGl0Um93TW9kYWw7XG5leHBvcnRzLk1SVF9FeHBhbmRBbGxCdXR0b24gPSBNUlRfRXhwYW5kQWxsQnV0dG9uO1xuZXhwb3J0cy5NUlRfRXhwYW5kQnV0dG9uID0gTVJUX0V4cGFuZEJ1dHRvbjtcbmV4cG9ydHMuTVJUX0ZpbHRlckNoZWNrYm94ID0gTVJUX0ZpbHRlckNoZWNrYm94O1xuZXhwb3J0cy5NUlRfRmlsdGVyRm5zID0gTVJUX0ZpbHRlckZucztcbmV4cG9ydHMuTVJUX0ZpbHRlck9wdGlvbk1lbnUgPSBNUlRfRmlsdGVyT3B0aW9uTWVudTtcbmV4cG9ydHMuTVJUX0ZpbHRlclJhbmdlRmllbGRzID0gTVJUX0ZpbHRlclJhbmdlRmllbGRzO1xuZXhwb3J0cy5NUlRfRmlsdGVyVGV4dElucHV0ID0gTVJUX0ZpbHRlclRleHRJbnB1dDtcbmV4cG9ydHMuTVJUX0dsb2JhbEZpbHRlclRleHRJbnB1dCA9IE1SVF9HbG9iYWxGaWx0ZXJUZXh0SW5wdXQ7XG5leHBvcnRzLk1SVF9HcmFiSGFuZGxlQnV0dG9uID0gTVJUX0dyYWJIYW5kbGVCdXR0b247XG5leHBvcnRzLk1SVF9Qcm9ncmVzc0JhciA9IE1SVF9Qcm9ncmVzc0JhcjtcbmV4cG9ydHMuTVJUX1Jvd0FjdGlvbk1lbnUgPSBNUlRfUm93QWN0aW9uTWVudTtcbmV4cG9ydHMuTVJUX1NlbGVjdENoZWNrYm94ID0gTVJUX1NlbGVjdENoZWNrYm94O1xuZXhwb3J0cy5NUlRfU2hvd0hpZGVDb2x1bW5zQnV0dG9uID0gTVJUX1Nob3dIaWRlQ29sdW1uc0J1dHRvbjtcbmV4cG9ydHMuTVJUX1Nob3dIaWRlQ29sdW1uc01lbnUgPSBNUlRfU2hvd0hpZGVDb2x1bW5zTWVudTtcbmV4cG9ydHMuTVJUX1Nob3dIaWRlQ29sdW1uc01lbnVJdGVtcyA9IE1SVF9TaG93SGlkZUNvbHVtbnNNZW51SXRlbXM7XG5leHBvcnRzLk1SVF9Tb3J0aW5nRm5zID0gTVJUX1NvcnRpbmdGbnM7XG5leHBvcnRzLk1SVF9UYWJsZSA9IE1SVF9UYWJsZTtcbmV4cG9ydHMuTVJUX1RhYmxlQm9keSA9IE1SVF9UYWJsZUJvZHk7XG5leHBvcnRzLk1SVF9UYWJsZUJvZHlDZWxsID0gTVJUX1RhYmxlQm9keUNlbGw7XG5leHBvcnRzLk1SVF9UYWJsZUJvZHlDZWxsVmFsdWUgPSBNUlRfVGFibGVCb2R5Q2VsbFZhbHVlO1xuZXhwb3J0cy5NUlRfVGFibGVCb2R5Um93ID0gTVJUX1RhYmxlQm9keVJvdztcbmV4cG9ydHMuTVJUX1RhYmxlQm9keVJvd0dyYWJIYW5kbGUgPSBNUlRfVGFibGVCb2R5Um93R3JhYkhhbmRsZTtcbmV4cG9ydHMuTVJUX1RhYmxlQ29udGFpbmVyID0gTVJUX1RhYmxlQ29udGFpbmVyO1xuZXhwb3J0cy5NUlRfVGFibGVEZXRhaWxQYW5lbCA9IE1SVF9UYWJsZURldGFpbFBhbmVsO1xuZXhwb3J0cy5NUlRfVGFibGVGb290ZXIgPSBNUlRfVGFibGVGb290ZXI7XG5leHBvcnRzLk1SVF9UYWJsZUZvb3RlckNlbGwgPSBNUlRfVGFibGVGb290ZXJDZWxsO1xuZXhwb3J0cy5NUlRfVGFibGVGb290ZXJSb3cgPSBNUlRfVGFibGVGb290ZXJSb3c7XG5leHBvcnRzLk1SVF9UYWJsZUhlYWQgPSBNUlRfVGFibGVIZWFkO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkQ2VsbCA9IE1SVF9UYWJsZUhlYWRDZWxsO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkQ2VsbEZpbHRlckNvbnRhaW5lciA9IE1SVF9UYWJsZUhlYWRDZWxsRmlsdGVyQ29udGFpbmVyO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkQ2VsbEZpbHRlckxhYmVsID0gTVJUX1RhYmxlSGVhZENlbGxGaWx0ZXJMYWJlbDtcbmV4cG9ydHMuTVJUX1RhYmxlSGVhZENlbGxHcmFiSGFuZGxlID0gTVJUX1RhYmxlSGVhZENlbGxHcmFiSGFuZGxlO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkQ2VsbFJlc2l6ZUhhbmRsZSA9IE1SVF9UYWJsZUhlYWRDZWxsUmVzaXplSGFuZGxlO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkQ2VsbFNvcnRMYWJlbCA9IE1SVF9UYWJsZUhlYWRDZWxsU29ydExhYmVsO1xuZXhwb3J0cy5NUlRfVGFibGVIZWFkUm93ID0gTVJUX1RhYmxlSGVhZFJvdztcbmV4cG9ydHMuTVJUX1RhYmxlUGFnaW5hdGlvbiA9IE1SVF9UYWJsZVBhZ2luYXRpb247XG5leHBvcnRzLk1SVF9UYWJsZVBhcGVyID0gTVJUX1RhYmxlUGFwZXI7XG5leHBvcnRzLk1SVF9Ub2dnbGVEZW5zZVBhZGRpbmdCdXR0b24gPSBNUlRfVG9nZ2xlRGVuc2VQYWRkaW5nQnV0dG9uO1xuZXhwb3J0cy5NUlRfVG9nZ2xlRmlsdGVyc0J1dHRvbiA9IE1SVF9Ub2dnbGVGaWx0ZXJzQnV0dG9uO1xuZXhwb3J0cy5NUlRfVG9nZ2xlRnVsbFNjcmVlbkJ1dHRvbiA9IE1SVF9Ub2dnbGVGdWxsU2NyZWVuQnV0dG9uO1xuZXhwb3J0cy5NUlRfVG9nZ2xlR2xvYmFsRmlsdGVyQnV0dG9uID0gTVJUX1RvZ2dsZUdsb2JhbEZpbHRlckJ1dHRvbjtcbmV4cG9ydHMuTVJUX1RvZ2dsZVJvd0FjdGlvbk1lbnVCdXR0b24gPSBNUlRfVG9nZ2xlUm93QWN0aW9uTWVudUJ1dHRvbjtcbmV4cG9ydHMuTVJUX1Rvb2xiYXJBbGVydEJhbm5lciA9IE1SVF9Ub29sYmFyQWxlcnRCYW5uZXI7XG5leHBvcnRzLk1SVF9Ub29sYmFyRHJvcFpvbmUgPSBNUlRfVG9vbGJhckRyb3Bab25lO1xuZXhwb3J0cy5NUlRfVG9vbGJhckludGVybmFsQnV0dG9ucyA9IE1SVF9Ub29sYmFySW50ZXJuYWxCdXR0b25zO1xuZXhwb3J0cy5NUlRfVG9wVG9vbGJhciA9IE1SVF9Ub3BUb29sYmFyO1xuZXhwb3J0cy5NYW50aW5lUmVhY3RUYWJsZSA9IE1hbnRpbmVSZWFjdFRhYmxlO1xuZXhwb3J0cy5NZW1vX01SVF9UYWJsZUJvZHkgPSBNZW1vX01SVF9UYWJsZUJvZHk7XG5leHBvcnRzLk1lbW9fTVJUX1RhYmxlQm9keUNlbGwgPSBNZW1vX01SVF9UYWJsZUJvZHlDZWxsO1xuZXhwb3J0cy5NZW1vX01SVF9UYWJsZUJvZHlSb3cgPSBNZW1vX01SVF9UYWJsZUJvZHlSb3c7XG5leHBvcnRzLmNvbW1vblRvb2xiYXJTdHlsZXMgPSBjb21tb25Ub29sYmFyU3R5bGVzO1xuZXhwb3J0cy5jcmVhdGVSb3cgPSBjcmVhdGVSb3c7XG5leHBvcnRzLmZsZXhSZW5kZXIgPSBmbGV4UmVuZGVyO1xuZXhwb3J0cy5nZXRBbGxMZWFmQ29sdW1uRGVmcyA9IGdldEFsbExlYWZDb2x1bW5EZWZzO1xuZXhwb3J0cy5nZXRDYW5SYW5rUm93cyA9IGdldENhblJhbmtSb3dzO1xuZXhwb3J0cy5nZXRDb2x1bW5JZCA9IGdldENvbHVtbklkO1xuZXhwb3J0cy5nZXRDb21tb25DZWxsU3R5bGVzID0gZ2V0Q29tbW9uQ2VsbFN0eWxlcztcbmV4cG9ydHMuZ2V0RGVmYXVsdENvbHVtbkZpbHRlckZuID0gZ2V0RGVmYXVsdENvbHVtbkZpbHRlckZuO1xuZXhwb3J0cy5nZXREZWZhdWx0Q29sdW1uT3JkZXJJZHMgPSBnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHM7XG5leHBvcnRzLmdldElzRmlyc3RDb2x1bW4gPSBnZXRJc0ZpcnN0Q29sdW1uO1xuZXhwb3J0cy5nZXRJc0ZpcnN0UmlnaHRQaW5uZWRDb2x1bW4gPSBnZXRJc0ZpcnN0UmlnaHRQaW5uZWRDb2x1bW47XG5leHBvcnRzLmdldElzTGFzdENvbHVtbiA9IGdldElzTGFzdENvbHVtbjtcbmV4cG9ydHMuZ2V0SXNMYXN0TGVmdFBpbm5lZENvbHVtbiA9IGdldElzTGFzdExlZnRQaW5uZWRDb2x1bW47XG5leHBvcnRzLmdldExlYWRpbmdEaXNwbGF5Q29sdW1uSWRzID0gZ2V0TGVhZGluZ0Rpc3BsYXlDb2x1bW5JZHM7XG5leHBvcnRzLmdldFByaW1hcnlDb2xvciA9IGdldFByaW1hcnlDb2xvcjtcbmV4cG9ydHMuZ2V0UHJpbWFyeVNoYWRlID0gZ2V0UHJpbWFyeVNoYWRlO1xuZXhwb3J0cy5nZXRUb3RhbFJpZ2h0ID0gZ2V0VG90YWxSaWdodDtcbmV4cG9ydHMuZ2V0VHJhaWxpbmdEaXNwbGF5Q29sdW1uSWRzID0gZ2V0VHJhaWxpbmdEaXNwbGF5Q29sdW1uSWRzO1xuZXhwb3J0cy5tcnRGaWx0ZXJPcHRpb25zID0gbXJ0RmlsdGVyT3B0aW9ucztcbmV4cG9ydHMucGFyc2VDU1NWYXJJZCA9IHBhcnNlQ1NTVmFySWQ7XG5leHBvcnRzLnByZXBhcmVDb2x1bW5zID0gcHJlcGFyZUNvbHVtbnM7XG5leHBvcnRzLnJhbmtHbG9iYWxGdXp6eSA9IHJhbmtHbG9iYWxGdXp6eTtcbmV4cG9ydHMucmVvcmRlckNvbHVtbiA9IHJlb3JkZXJDb2x1bW47XG5leHBvcnRzLnNob3dFeHBhbmRDb2x1bW4gPSBzaG93RXhwYW5kQ29sdW1uO1xuZXhwb3J0cy51c2VNYW50aW5lUmVhY3RUYWJsZSA9IHVzZU1hbnRpbmVSZWFjdFRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mantine-react-table/dist/cjs/index.js\n");

/***/ })

};
;